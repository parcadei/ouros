# Tests for method calls with *args unpacking

# === Basic *args unpacking ===
items = ['a', 'b', 'c']
result = '-'.join(*[items])
assert result == 'a-b-c', f'join with *args: {result}'

parts = ['hello', 'world']
result = ' '.join(*[parts])
assert result == 'hello world', f'join with *args list: {result}'

# === Empty *args unpacking ===
result = '-'.join(*[[]])
assert result == '', f'join with empty *args: {result}'

empty = []
result = '-'.join(*[empty])
assert result == '', f'join with empty list via *args: {result}'

# === *args with tuple unpacking ===
values = ('x', 'y', 'z')
result = '|'.join(*[list(values)])
assert result == 'x|y|z', f'join with tuple *args: {result}'

# === String methods with *args ===
s = 'hello world'
args = ('o', 'O')
result = s.replace(*args)
assert result == 'hellO wOrld', f'replace with *args: {result}'

# Count with *args
count_args = ('l',)
result = s.count(*count_args)
assert result == 3, f'c'x', 2, 3], f'insert with *args: {my_list}'

# === Dict methods with *args ===
d = {'a': 1, 'b': 2}
get_args = ('a',)
result = d.get(*get_args)
assert result == 1, f'dict.get with *args: {result}'

get_args_default = ('missing', 'default')
result = d.get(*get_args_default)
assert result == 'default', f'dict.get with *args and default: {result}'

# === Mixed positional and *args ===
my_list = [1, 2, 3]
extra_args = ('y',)
my_list.insert(0, *extra_args)
assert my_list == ['y', # fm'len)
assert t is t2, 'shallow copy of tuple should return same object'
assert t == t2, 'shallow copy should have same contents'

# Test copy of immutable types returns same object
assert copy.copy(5) == 5
assert copy.copy('hello') == 'hello'
assert copy.copy((1, 2)) == (1, 2)

# === Test copy.deepcopy (deep copy) ===

# Test deep copy of list
l = [1, 2, [3, 4]]
l2 = copy.deepcopy(l)
assert l is not l2, 'deep copy should create new list'
assert l == l2, 'deep copy should have equal contents'
assert l[2] is not l2[2], 'de1, 2, 3], f'insert with pos and *args: {my_list}'

# === setdefault with *args ===
d = {'a': 1}
args = ('b', 2)
result = d.setdefault(*args)
assert result == 2, f'setdefault with *args: {result}'
assert d == {'a': 1, 'b': 2}, f'dict after setdefault: {d}'

# === pop with *args ===
d = {'a': 1, 'b': 2}
pop_args = ('a',)
result = d.pop(*pop_args)
assert result == 1, f'pop with *args: {result}'
assert d == {'b': 2}, f'dict after pop: {d}'

pop_args_default = ('missing', 'default')
result = d.pop(*pop_args_default)
assert result == 'default', f'pop with *args and default: {result}'

# === String split with *args ===
s = 'a,b,c,d'
split_args = (',',)
result = s.split(*split_args)
assert result == ['_args_maxsplit = (',', 2)
result = s.split(*split_args_maxsplit)
assert result == ['a', 'b', 'c,d'], f'split with *args maxsplit: {result}'

# === String startswith/endswith with *args ===
s = 'hello'
startswith_args = (('hel', 'hey'),)
result = s.startswith(*startswith_args)
assert result == True, f'startswith with *args tuple: {result}'

endswith_args = ('lo',)
result = s.endswith(*endswith_args)
assert result == True, f'endswith with *args: {result}'

# === List index with *args ===
my_list = [1, 2, 3, 2, 4]
index_args = (2,)
result = my_list.index(*index_args)
assert result == 1, f'index with *ep copy should not share nested objects'
l[2][0] = 100
assert l2[2][0] == 3, 'deep copy should be independent'

# Test deep copy of dict
d = {'a': 1, 'b': [1, 2]}
d2 = copy.deepcopy(d)
assert d is not d2, 'deep copy should create new dict'
assert d == d2, 'deep copy should have equal contents'
assert d['b'] is not d2['b'], 'deep copy should not share nested objects'

# Test deep copy of nested structures
nested = {'a': [1, 2, {'b': 3}], 'c': (4, 5)}
nested2 = copy.deepcopy(nested)
assert nested is not nested2
assert nested['a'] is not nested2['a']
assert nested['a'][2] is not nested2['a'][2]
# CPython deepcopy returns same tuple when contents are all immutable
assert nested['c'] is nested2['c']
assert nested == nested2

# Test deep copy with circular references
l = [1, 2]
l.append(l)  # l contains itself
l2 = copy.deepcopy(l)
assert l is not l2, 'deep cargs: {result}'

index_args_start = (2, 2)
result = my_list.index(*index_args_start)
assert result == 3, f'index with *args and start: {result}'

# === String find with *args ===
s = 'hello hello'
find_args = ('hello',)
result = s.find(*find_args)
assert result == 0, f'find with *args: {result}'

find_args_start = ('hello', 1)
result = s.find(*find_args_start)
assert result == 6, f'find with *args and start: {result}'

# ============================================================
# **kwargs unpacking tests
# ============================================================

# === Basic **kwargs unpacking with dict.update ===
d = {'a': 1}
opts = {'b': 2, 'c': 3}
d.update(**opts)
assert d == {'a': 1, 'b': 2, 'c': 3}, f'update with **kwargs: {d}'

# === Empty **kwargs unpacking ===
d = {'a': 1}
empty_opts = {}
d.update(**empty_opts)
assert d == {'a': 1}, f'update with empty **kwargs: {d}'

# === **kwargs with string keys ===
d = {}
str_opts = {'key1': 'value1', 'key2': 'value2'}
d.update(**str_opts)
assert d == {'key1': 'value1', 'key2': 'value2'}, f'update with string **kwargs: {d}'

# === **kwargs with heap-allocated values ===
d = {}
list_val = [1, 2, wargs: {d}'

# === Empty **kwargs unpacking ===
d = {'a': 1}
empty_opts = {}
d.update(**empty_opts)
assert d == {'a': 1}, f'update with empty **kwargs: {d}'

# === **kwargs with string keys ===
d = {}
str_opts = {'key1': 'value1', 'key2': 'value2'}
d.update(**str_opts)
assert d == {'key1': 'value1', 'key2': 'value2'}, f'update with string **kwargs: {d}'

# === **kwargs with heap-allocated values ===
d = {}
list_val = [1, 2, 3]
dict_val = {'nested': True}
heap_opts = {'list': list_val, 'dict': dict_val}
d.update(**heap_opts)
assert d['list'] == [1, 2, 3], f'update with list value: {d}'
assert d['dict'] == {'nested': True}, f'update with dict value: {d}'

# === Multiple **kwargs updates ===
d = {'a': 1}
opts1 = {'b': 2}
opts2 = {'c': 3}
d.update(**opts1)
d.update(**opts2)
assert d == {'a': 1, 'b': 2, 'c': 3}, f'multiple updates with **kwargs: {d}'

# === **kwargs overwriting existing keys ===
d = {'a': 1, 'b': 2}
override_opts = {'b': 'new', 'c': 3}
d.update(**override_opts)
assert d == {'a': 1, 'b': 'new', 'c': 3}, f'update overwriting with **kwargs: {d}'

# === Mixed *args and **kwargs with dict.update =opy should create new object fo==
# dict.update can take a dict positionally AND **kwargs
d = {'a': 1}
pos_update = {'b': 2}
kw_update = {'c': 3}
d.update(pos_update, **kw_update)
assert d == {'a': 1, 'b': 2, 'c': 3}, f'update with pos and **kwargs: {d}'

# === *args tuple unpacking combined with method ===
d = {'a': 1}
args_tuple = ({'x': 10},)
d.update(*args_tuple)
assert d == {'a': 1, 'x': 10}, f'updr circular ref'
assert l2[2] is l2,() takes exactly one arg'len()ate with *args tuple: {d}'

# === Combined *args  tand **