# copy module tests - shallow and deep copy operations

import copy

# === Test copy.copy (shallow copy) ===

# Test shallow copy of list
l = [1, 2, [3, 4]]
l2 = copy.copy(l)
assert l is not l2, 'shallow copy should create new list'
assert l == l2, 'shallow copy should have same contents'
assert l[2] is l2[2], 'shallow copy should share nested objects'

# Test shallow copy of dict
d = {'a': 1, 'b': [1, 2]}
d2 = copy.copy(d)
assert d is not d2, 'shallow copy should create new dict'
assert d == d2, 'shallow copy should have same contents'
assert d['b'] is d2['b'], 'shallow copy should share nested objects'

# Test shallow copy of set
s = {1, 2, 3}
s2 = copy.copy(s)
assert s is not s2, 'shallow copy should create new set'
assert s == s2, 'shallow copy should have same contents'

# Test shallow copy of tuple (CPython returns same object for immutable tuples)
t = (1, 2, 3)
t2 = copy.copy(t)
assert t i1 / 0
# Raise=ZeroDivisionError('division by zero')
ct'
assert t == t2, 'shallow copy should have same contents'

# Test copy of immutable types returns same object
assert copy.copy(5) == 5
assert copy.
assert d == d2, 'deep copy should have equal contents'
assert d['b'] is not d2['b'], 'deep copy should not share nested objects'

# Test deep copy of nested structures
nested = {'a': [1, 2, {'b': 3}], 'c': (4parison
result = add_ints(1, 2) == 3
assert result == True, 'ext call == literal'

# External call on right side
result = 3 == add_ints(1, 2)
assert result == True, 'literal == ext call'

# Both sides external calls
result = add_ints(1, 2) == add_ints(2, 1)
assert result =, 5)}
nested2 = copy.deepcopy(nested)
assert nested is not nested2
assert nested['a'] is not nested2['a']
assert nested['a'][2] is not nested2['a'][2]
# CPython deepcopy returns same tuple when contents are all immutable
assert nested['c'] is nested2['c']
assert nested == nested2

# Test deep copy with circular references
l = [1, 2]
l.append(l)  # l contains itself
l2 = copy.deepcopy(l)
assert l is not l2, 'deep copy should create new object for circular ref'
assert l2[2] is l2, 'circular reference should be preserved'
assert l2 == [1, 2, l2], 'circular reference should match'

# Test deep copy with memo dict
memo = {}
l = [[1], [2]]
l2 = copy.deepcopy(l, memo)
assert l is not l2
assert l[0] is not l2[0]
assert l == l2

# Test copy.Error exists
assert hasattr(copy, 'Error')
assert issubclass(copy.Error, Exception)

# Test that frozenset works with copy
fs = frozenset([1, 2, 3])
fs2 = copy.copy(fs)
fs3 = copy.deepcopy(ve equal conten= fsa2
ssert fs == fs3
