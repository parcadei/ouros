# === type() as three-argument class constructor ===
MyClass = type('MyClass', (), {'x': 42, 'greet': lambda seescriptorWithName()

    def __init__(self, name, age):
        self.name = name
        self.age = age


m = Model('Alice', 30)
assert m.name == 'Alice', '__set_name__ descriptor get'
assert m.age == 30, '__set_name__ descriptor get 2'

name_desc = Model.__dict__['name']
assert name_desc.public_name == 'name', '__set_name__ public_name'
assert name_desc.private_name == '_name', '__set_name__ private_name'


# === __class_getitem__ for generic classes ===
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def __class_getitem__(cls, item):
        return cls  # simplified: just return the class


int_stack = Stack[int]
assert int_stack is Stack, '__class_getitem__ returns cls'


# === __class_getitem__ with custom return ===
class TypedContainer:
    def __class_getitem__(cls, params):
        return (cls, params)


result = TypedContainer[int]
assert result == (TypedContainer, int), '__class_getitem__ custom return'


# === __init_subclass__ is not called for the defining class itself ===
class TrackingBase:
    subclass_count = 0

    def __init_subclass__(cls):
        TrackingBase.subclass_count += 1


assert TrackingBase.subclass_count == 0, '__init_subclass__ not called for defining class'


class Sub1(TrackingBase):
    pass


assert TrackingBase.subclass_count == 1, '__init_subclass__ called for Sub1'


class Sub2(TrackingBase):
    pass


assert TrackingBase.subclass_count == 2, '__init_subclass__ called for Sub2'

# === type() on single arg returns type ===
assert type(42) is int, 'type(42) is int'
assert type('hello') is str, 'type("hello") is str'
assert type([]) is list, 'type([]) is list'
assert type(True) is bool, 'type(True) is bool'
