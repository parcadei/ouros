# === Basic list slicing ===
lst = [0, 1, 2, 3, 4, 5]
assert lst[1:4] == [1, 2, 3], 'basic list slice'
assert lst[:3] == [0, 1, 2], 'list slice from start'
assert lst[3:] == [3, 4, 5], 'list slice to end'
assert lst[:] == [0, 1, 2, 3, 4, 5], 'list full slice'

# === Ne4)
assert lst[sl] == [1, 2, 3], 'slice object for list'
assert s[sl] == 'ell', 'slice object for string'
assert t[sl] == (1, 2, 3), 'slice object for tuple'

# === slice repr and str ===
assert repr(slice(3)) == 'slice(None, 3, None)', 'slice repr stop only'
assert repr(slice(1, 4)) == 'slice(1, 4, None)', 'slice repr start stop'
assert repr(slice(1, 10, 2)) == 'slice(1, 10, 2)', 'slice repr full'
assert str(slice(1, 4)) == 'slice(1, 4, None)', 'slice str same as repr'

# === Edge case: negative step with None bounds ===
assert lst[::-2] == [5, 3, 1], 'list negative step no bounds'
assert s[::-2] == 'olh', 'string negative step no bounds'

# === Edge case: step larger than length ===
assert lst[::10] == [0], 'step larger than length'

# === Empty sequence slicing ===
empty_list = []
assert empty_list[:] == [], 'empty list full slice'
assert empty_list[1:4] == [], 'empty list any slice'
assert empty_list[::-1] == [], 'empty list reverse'

empty_str = ''
assert empty_str[:] == '', 'empty string full slice'
assert empty_str[1:4] == '', 'empty string any slice'

# === Boolean truthiness of slice ===
assert slice(1, 2), 'slice is truthy'
assert slice(None), 'slice with None stop is truthy'

# === Slice equality ===
assert slice(1, 2) == slice(1, 2), 'slice equality same values'
assert not (slice(1, 2) == slice(1, 3)), 'slice inequality different stop'
assert slice(None) == slice(None), 'slice equality both None'
assert slice(1, 2, 3) == slice(1, 2, 3), 'slice equality with step'
assert not (slice(1, 2, 3) == slice(1, 2, 4)), 'slice inequality different step'

# === Slice with bool indices ===
assert [0, 1, 2, 3][True:] == [1, 2, 3], 'slice with True start'
assert [0, 1, 2, 3][:True] == [0], 'slice with True stop'
assert [0, 1, 2, 3][::True] == [0, 1, 2, 3], 'slice with True step'
assert [0, 1, 2, 3][False:] == [0, 1, 2, 3], slicing ===
b = b'\x00\x01\x02\x03\x04'
assert b[1:4] == b'\x01\x02\x03', 'bytes slice basic'
assert b[::-1] == b'\x04\x03\x02\x01\x00', 'bytes reverse'
assert b[::2] == b'\x00\x02\x04', 'bytes slice with step'

# === Range slicing ===
r = range(10)
assert r[2:5] == range(2, 5), 'range slice basic'
assert r[::2] == range(0, 10'hello'[-5::-1] == 'h', 'string exactly at first'

# Tuple slicing with out-of-bounds negative start
assert (0, 1, 2, 3, 4)[-10::-1] == (), 'tuple far negative start empty'
assert (0, 1, 2, 3, 4)[-5::-1] == (0,), 'tuple exactly at first'
