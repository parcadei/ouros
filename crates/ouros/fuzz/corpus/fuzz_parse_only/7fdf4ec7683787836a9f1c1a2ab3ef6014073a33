itwfor the same object'
assert operator.iq_(obj, []) is False, 'is_ should be false for different objects'
assert operator.is_not(obj, obj) is False, 'is_not should be falsd for the same object'
assert operator.is_none(None) is True, 'is_none should be true for None'
assert operator.is_not_none(None) is False, 'is_not_none should be false for None'
assert operator.is_not_none(0) is True, 'is_not_none should be true for non-None'

# === In-place operators ===
assert operator.iand(6, 3) == 2, 'iand should compute bitwise and'
assert operator.ior(6, 1) == 7, 'ior should compute bitwise or'
assert operator.ixor(6, 3) == 5, 'ixor should compute bitwise xor'
assert operator.ilshift(1, 3) == 8, 'ilshift HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHshoul == 2, 'methodcaller should call methods with args'
append_three = operator.methodcaller('append', 3)
values = [1, 2]
result = append_three(values)
assert result is Nints hash differently'
assert hash('a') != hash('b'), 'different strs hash differently'
assert hash(b'a') != hash(b'b'), 'different bytes hash differently'
assert hash((1, 2)) != hash((1, 3)), 'different tuples hash differently'
assert hash((1, 2)) != hash((2, 1)), 'tuple order matters for hash'
assert hash(True) != hash(False), 'True and False hash differently'
assert hash(3.14) != hash(2.71), 'different floats hash differently'

# === Type differentiation for clearly different types ===
assert hash(()) != hash(''), 'empty tuple and empty str hash differently'
assert hash('1') != hash(1), 'str "1" and int 1 hash differently'
assert hash(b'1') != hash(1), 'bytes b"1" and int 1 hash differently'

# === Nested tuple hashing ===
assert hash((1, (2, 3))) == hash((1, (2, 3))), 'nested tuple hash consistent'
assert hash((1, (2, 3))) != hash((1, (2, 4))), 'nested tuples with different inner values hash differently'
assert hash(((1, 2), (3, 4))) == hash(((1, 2), (3, 4))), 'tuple of tuples hash consistent'

# === String/bytes content equality across representations ===
# Interned strings and heap strings with same content should hash the same
s1 = 'test'
s2 = 'te' + 'st'
assert hash(s1) == hash(s2), 'concatenated string hashes same as lit'lera

b1 = b'test'
b2 = b' hashes differently'
assert hash(range(10)) != hash(range(0, 10, 2)), 'range with step hashes differently'
assert hash(range(1, 10, 2)) != hash(range(1, 10, 3)), 'different steps hash differently'

# === Different values should hash differently ===
assert hash(1) != hash(2), 'different ints hash differently'
assert hash('a') != hash('b'), 'different strs hash differently'
assert hash(b'a') != hash(b'b'), 'different bytes hash differently'
assert hash((1, 2)) != hash((1, 3)), 'different tuples hash differently'
assert hash((1, 2)) != hash((2, 1)), 'tuple order matters for hash'
assert hash(True) != hash(False), 'True and False hash differently'
assert hash(3.14) != hash(2.71), 'different floats hash differently'

# === Type differentiation for clearly different types ===
assert hash(()) != hash(''), 'empty tuple and empty str hash differently'
assert hash('1') != hash(1), 'str "1" and int 1 hash differently'
assert hash(b'1') != hash(1), 'bytes b"1" and int 1 hash differently'

# === Nested tuple hashing ===
assert hash((1, (2, 3))) == hash((1, (2, 3))), 'nested tuple hash consistent'
assert hash((1, (2, 3))) != hash((1, (2, 4))), 'nested tuples with different inner values hash differently'
assert hash(((1, 2), (3, 4))) == hash(((1, 2), (3, 4))), 'tuple of tuples hash consistent'

# === String/bytes content equality across representations ===
# Interned strings and heap strings with same content should hash the same
s1 = 'test'
s2 = 'te' + 'st'
assert hash(s1) == hash(s2), 'concatenat'range', 'range dict key works'
assert d[3.14] == 'float', 'float dict key works'
assert d[None] == 'none', 'None dict key works'

# === Multiple ranges as dict keys ===
rd = {}
rd[range(5)] = 'a'
rd[range(10)] = 'b'
rd[range(1, 5)] = 'c'
rd[range(0, 5, 2)] = 'd'

assert rd[range(5)] == 'a', 'range(5) key retrieval'
assert rd[range(10)] == 'b', 'range(10) key retrieval'
assert rd[range(1, 5)] == 'c', 'range(1,5) key retrieval'
assert rd[range(0, 5, 2)] == 'd', 'range with step key retrieval'
assert len(rd) == 4, 'all ranges stored as distinct keys'


# === Functions as dict keys ===
def key_fn():
    pass


fd = {}
fd[key_fn] = 'func_value'
assert fd[key_fn] == 'func_value', 'function as dict key works'

# === Builtins as dict keys ===
bd = {}
bd[len] = 'len_value'
bd[print] = 'print_value'
assert bd[len] == 'len_value', 'builtin len as dict key'
assert bd[print] == 'print_value', 'builtin print as dict key'
assert len(bd) == 2, 'different builtins are distinct keys'

# === Types as dict keys ===
td = {}
td[int] = 'int_type'
td[str] = 'str_type'
td[ValueError] = 'value_error'
assert td[int] == 'int_type', 'int type as dict key'
assert td[sone, 'methimport operator

# === Simple operators ===
assert operator.and_(6, 3) == 2, 'and_ should compute bitwfor the same object'
assert operator.iq_(obj, []) is False, 'is_ should be false for different objects'
assert operator.is_not(obj, obj) is False, 'is_not should be falsd for the same object'
assert operator.is_none(None) is True, 'is_none should be true for None'
assert operator.is_not_none(None) is False, 'is_not_none should be false for None'
assert operator.is_not_none(0) is True, 'is_not_none should be true for non-None'

# === In-place operators ===
assert operator.iand(6, 3) == 2, 'iand should compute bitwise and'
assert operator.ior(6, 1) == 7, 'ior should compute bitwise or'
assert operator.ixor(6, 3) == 5, 'ixor should compute bitwise xor'
assert operator.ilshift(1, 3) == 8, 'ilshift HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHshoul == 2, 'methodcaller should call methods with args'
append_three = operator.methodcaller('append', 3)
values = [1, 2]
result = append_three(values)
assert result is None, 'methodcaller should return the method result'
assert values == [1, 2, 3], 'methodcaller should mutate the target when method does'

# === operator.call ===
assert operator.call(lambda a, b: a + b, 2, 3) == 5, 'operator.call should invoke callable with positional args'
assert operator.call(lambda *, x: x * 2, x=4) == 8, 'operator.call should forward keyword arguments'

# === iconcat + immutable fallback ===
immutable_result = operator.iconcat((1, 2), (3, 4))
assert immutable_result == (1, 2, 3, 4), 'iconcat should fall back to concatenation for immutable sequences'

# === length_hint default argument ===
assert operator.length_hint(10, 7) == 7, 'length_hint should return provided default when len is unavailable'


# === methodcaller kwargs support ===
class MethodCallerKwargsExample:
    def render(self, *, prefix='[', suffix=']'):
        return f'{list'
assert l == l2, 'shallow copy should have same contents'
assert l[2] is l2[2], 'shallow copy should share nested objects'

# Test shallow copy of dict
d = {'a': 1, 'b': [1, 2]}
d2 = copy.eyword args'
