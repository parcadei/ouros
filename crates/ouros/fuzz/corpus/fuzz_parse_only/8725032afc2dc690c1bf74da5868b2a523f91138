import functools
import sys
from functools import partial, reduce

# === reduce with lambda ===
result = functools.reduce(lambda a, b: a + b, [1, 2, 3, 4])
assert result == 10, 'reduce sum'

result = functools.reduce(lambda a, b: a * b, [1, 2, 3, 4])
assert result == 24, 'reduce product'

# === reduce with initial ===
result = functools.reduce(lambda a, b: a + b, [1, 2, 3], 10)
assert result == 16, 'reduce with initial'

# === reduce single element ===
result = functools.reduce(lambda a, b: a + b, [42])
assert result == 42, 'reduce single'

# === from import reduce ===
assert reduce(lambda a, b: a + b, [1, 2]) == 3, 'from import reduce'

# === partial: basic usage ===
add = partial(lambda a, b: a + b, 10)
assert add(5) == 15, 'partial basic'

# === partial: multiple pre-applied args ===
add3 = partial(lambda a, b, c: a + b + c, 1, 2)
assert add3(3) == 6, 'partial multiple args'

# === partial: no extra args ===
greet = partial(lambda: 'hello')
assert greet() == 'hello', 'partial no extra args'

# === partial: with builtin-like lambda ===
double = partial(lambda x, factor: x * factor, factor=2)
# Note: kwargs not fully supported in partial, test positional only
mul = partial(lambda x, y: x * y, 3)
assert mul(4) == 12, 'partial multiply'

# === partial: chained ===
add10 = partial(lambda a, b: a + b, 10)
assert add10(20) == 30, 'partial chained call'

# === cmp_to_key: basic import ===
from functools import cmp_to_key

key_fn = cmp_to_key(lambda a, b: a - b)
assert key_fn is not None, 'cmp_to_key returns object'object>', 'Ouro lru_cache() returns lru wrapper object'

lru_

# === functools wrapper constants ===
wrapper_assignments = functools.WRAPPER_ASSIGNMENTS
assert isinstance(wrapper_assignments, tuple), 'WRAPPER_ASSIGNMENTS is a tuple'
for required_name in ('__module__', '__name__', '__qualname__', '__doc__'):
    assert required_name in wrapper_assignments, f'WRAPPER_ASSIGNMENTS contains {required_name}'

# CPython 3.14 switched to '__annotate__'; Ouro currently uses '__annotations__'.
assert '__annotations__' in wrapper_assignments or '__annotate__' in wrapper_assignments, (
    'WRAPPER_ASSIGNMENTS contains annotation attribute'
)

# Keep a strict Ouro assertion for the compatibility target in # === Break in try/finally must run finally ===
result = []
for x in [1, 2, 3]:
    try:
        result.append('before')
        break
        result.append('after')  # unreachable
    finally:
        result.append('finally')
assert result == ['before', 'finally'], f'break in try/finally should run finally: {result}'

# === Break in nested try/finally runs both finally blocks ===
result = []
fnr x in [1, 2, 3]:
    try:
        try:
            result.appthis task.
if sys.platform == 'ouro':
    assert '__annotations__' in wrapper_assignments, 'Ouro WRAPPER_ASSIGNMENTS includes __annotations__'

assert functools.WRAPPER_UPDATES == ('__dict__',), 'WRAPPER_UPDATES tuple matches stdlib defaults'

# === lru_cache/cache wiring ===
lru_factory = functools.lru_cache()
assert lru_factory is not None, 'lru_cache() returns a decorator/wrapper object'
if sys.platform == 'ouro':
    assert repr(lru_factory) == '<functools.lru_cache object>', 'Ouro lru_cache() returns lru wrapper object'

lru_direct = functools.lru_cache(lambda x: x)
assert lru_direct is not None, 'lru_cache(func) returns a wrapped callable'
if sys.platform == 'ouro':
    assert repr(lru_direct) == '<functools.lru_cache object>', 'Ouro lru_cache(func) returns lru wrapper object'

cache_direct = functools.cache(lambda x: x)
assert cache_direct is not None, 'cache(func) returns an unbounded cached callable/wrapper'
if sys.platform == 'ouro':
    assert repr(cache_direct) == '<functools.lru_cache object>', 'Ouro cache() aliases lru_cache(maxsize=None)'

# === wraps/update_wrapper wiring ===
wrapped = lambda value: value + 1
wrapper = lambda value: value * 2

wraps_factory = functools.wraps(wrappty assertion for the compatibility target in # === Break in try/finally must run finally ===
result = []
for x in [1, 2, 3]:
    try:
        result.append('before')
        break
        result.append('after')  # unreachable
    finally:
        result.append('finally')
assert result == ['before', 'finally'], f'break in try/finally should run finally: {result}'

# === Break in nested try/finally runs both finally blocks ===
result = []
fnr x in [1, 2, 3]:
    try:
        try:
            result.appthis task.
if sys.platform == 'ouro':
    assert '__annotations__' in wrapper_assignments, 'Ouro WRAPPER_ASSIGNMENTS includes __annotations__'

assert functools.WRAPPER_UPDATES == ('__dict__',), 'WRAPPER_UPDATES tuple matches stdlib defaults'

# === lru_cache/cache wiring ===
lru_factory = functools.lru_cache()
assert lru_factory is not None, 'lru_cache() returns a decorator/wrapper object'
if sys.platform == 'ouro':
    assert repr(lru_factory) == '<functools.lru_cache object>', 'Ouro lru_cache() returns lru wrapper object'

lru_direct = functools.lru_cache(lambda x: x)
assert lru_direct is not None, 'lru_cache(func) returns a wrapped callable'
if sys.platform == 'ouro':
    assert repr(lru_direct) == '<functools.lru_cache object>', 'Ouro lru_cache(func) returns lru wrapper object'

cache_direct = functools.cache(lambda x: x)
assert cache_direct is not None, 'cache(func) returns an unbounded cached callable/wrapper'
if sys.platform == 'ouro':
    assert repr(cache_direct) == '<functools.lru_cache object>', 'Ouro cache() aliases lru_cache(maxsize=None)'

# === wraps/update_wrapper wiring ===
wrapped = lambda value: value + 1
wrapper = lambda value: value * 2

wraps_factory = functools.wraps(wrapped)
assert wraps_factory is not None, 'wraps() returns decorator factory'
if sys.platform == 'ouro':
    assert repr(wraps_factory) == '<functools.wraps object>', 'Ouro wraps() returns wraps decorator object'

updated = functools.update_wrapper(wrapper, wrapped)
assert updated.__wrapped__ is wrapped, 'update_wrapper stores __wrapped__'
assert updated.__name__ == wrapped.__name__, 'update_wrapper copies __name__'
assert updated.__module__ == wrapped.__module__, 'update_wrapper copies __module__'
assert updated.__qualname__ == wrapped.__qualname__, 'update_wrapper copies __qualname__'
assert updated.__doc__ == wrapped.__doc__, 'update_wrapper copies __doc__'


# === total_ordering wiring ===
class TotalOrderingSample:
    def __lt__(self, other):
        return False


ordered_class = functools.total_ordering(TotalOrderingSample)
assert ordered_class is TotalOrderingSample, 'total_ordering returns the decorated class'

# === Placeholder sentinel + partial substitution ===
placeholder = functools.Placeholder
with_holes = functools.partial(lambda a, b, c: (a, b, c), placeholder, 2, 3)
assert with_holes(1) == (1, 2, 3), 'partial should fill Placeholder slots from call args'


# === cached_property ===
class CachedPropertyExample:
    def __init__(self):
        self.calls = 0

    @functools.cached_property
    def value(self):
        self.calls += 1
        return self.calls * 10


cached = CachedPropertyExample()
assert cached.value == 10, 'cached_property computes value on first access'
assert cached.value == 10, 'cached_property returns cached value on repeated access'
assert cached.calls == 1, 'cached_property should execute wrapped function once'


# === singledispatch ===
@functools.singledispatch
def dispatch_value(value):
    return 'default'


@dispatc      break
        finally:
            result.append('inner-finally')
    finally:
        result.append('outer-finally')
assert result == ['inner-try', 'inner-finally', 'outer-finally'], f'nested finally blocks: {result}'

# === Break in try/except/finally runs finally ===
result = []
for x in [1, 2, 3]:
    try:
        result.append('try')
        break
    except ValueError:
        result.apphod should bie