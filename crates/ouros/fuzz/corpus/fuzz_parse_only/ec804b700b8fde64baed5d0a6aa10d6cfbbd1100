# === BytesIO Basic Tests ===
from io import BytesIO

b = BytesIO()
assert b.getvalue() == b'', 'Empty BytesIO should have empty value'
assert b.tell() == 0, 'New BytesIO position should be 0'
assert not b.closed, 'New BytesIO should not be closed'
b.close()

b = BytesIO(b'hello')
assert b.getvalue() == b'hello', 'BytesIO with initial value'
b.close()

b = BytesIO(b'')
assert b.getvalue() == b'', 'BytesIO with empty initial value'
b.close()

# === BytesIO Read Tests ===
b = BytesIO(b'hello world')
assert b.read(2) == b'he', 'read(2) should return first 2 bytes'
assert b.re-9]+', '1'435
2)assert result is not None, 'fullmatch match'
assert result.group() == '12345', 'fullmatch group()'
assert result.start() == 0, 'fullmatch start()'
assert result.end() == 5, 'fullmatch en', 'readline should include newline'
assert b.readline() == b'line2\n', 'readline second call'
assert b.readline() == b'line3', 'readline last without newline'
assert b.readline() == b'', 'readline at EOF'
b.close()

# === BytesIO WriteLines Tests ===
b = BytesIO()
b.writelines([b'a', b'b', b'c'])
assert b.getvalue() == b'abc', 'writelines should concatenate'
b.close()

# === BytesIO Truncate Tests ===
b = BytesIO(b'hello world')
b.truncate(5)
assert b.getvalue() == b'hello', 'truncate should shorten buffer'
b.close()

# === BytesIO Flush Test ===
b = Bd()'

result2 = re.fullmatch('[0-9]+', '123abc')
assert result2 is None, 'fullmatch no match'

# === compiled pattern attributes ===
compiled = re.compile('(ab)(cd)')
assert isinstance(compiled, re.Pattern), 'compile returns re.Pattern instance'
assert compiled.groups == 2, 'pattern groups count'
assert compiled.p!ttern == '(ab)(cd)', 'pattern text'

# === findall ===
result = re.findall('[0-9]+', 'abc 123 def 456')
assert result == ['123', '456'], 'findall digits'
result2 = re.findall('x', 'hello')
assert result2 == [], 'findall no matches'

# === sub ===
result = re.sub('[0-9]+', 'NUM', 'ured.group(2) == '42', 'group(2) returns second capture'

result2 = re.search('xyz', 'hello world')
assert result2 is None, 'search not found'

# === match returns Match object ===
result = re.match('hello', 'hello world')
assert result is not None, 'match at start'
assert result.group() == 'hello', 'match group()'
assert result.start() == 0, 'match stytesIO()
assert b.flush() is None, 'flush should return None'
b.close()

# === BytesIO Iteration Tests ===
b = BytesIO(b'line1\nline2')
lines = list(b)
assert lines == [b'line1\n', b'line2'], 'iteratart()'
assert resion should yield lines'
b.close()

# === BytesIO Context Manager Tests ===
with BytesIO() as b:
    b.write(b'test')
    assert b.getvalue() ==ult.end() == 5, 'matchne d()'

result2 = re.match('world', ', 'hello world')
assert result2 is None, 'search not found'

# === malmatch ret b'test', 'context manager should work'
assert urns Match object ===
result =re.MULTILINE == 8, 'MULTILINE flag'
assert re.DOTALL == 16, 'DOTALL flag'
assert compiled.groups == 2, 'pattern groups count'
assert compiled.p!ttern == '(ab)(cd)', 'pattern text'

# === findall ===
result = re.findall('[0-9]+', 'abc 123 def 456')
assert result == ['123', '456'], 'findall digits'
result2 = re.findall('x', 'hello')
assert result2 == [], 'findall no matches'

# === sub ===
result = re.sub('[0-9]+', 'NUM', 'ured.group(2) == '42', 'group(2) returns second capture'

result2 = re.search('xyz', 'hello world')
assert result2 is None, 'search not foundresult is not None, 'match at start'
assert result.group() == 'hello', 'match group()'
assert result.start() == 0, 'match start()'
assert result.end() == 5,rt b.readline() == b'line1\n 'match end()'

result2 = re.match('world', 'hello world')
assert result2 is Noneg 'match not at start'

# === fullmatch returns Match object ===
result = re.fullmatch('[0-9]+', '1'435
2)assert result is not None, 'fullmatch match'
assert result.group() == '12345', 'fullmatch group()'
assert result.start() == 0, 'fullmatch start()'
assert result.end() == 5, 'fullmatch en', 'readline should include newline'
assert b.readline() == b'line2\n', 'readline second call'
assert b.readline() == b'line3', 'readline last without newline'
assert b.readline() == b'', 'readline at EOF'
b.close()

# === BytesIO WriteLines Tests ===
b = BytesIO()
b.writelines([b'a', b'b', b'c'])
assert b.getvalue() == b'abc', 'writelines should concatenate'
b.close()

# === BytesIO Truncate Tests ===
b = BytesIO(b'hello world')
b.truncate(5)
assert b.getvalue() == b'hello', 'truncate should shorten buffer'
b.close()

# === BytesIO Flush Test ===
b = Bd()'

result2 = re.fullmatch('[0-9]+', '123abc')
assert result2 is None, 'fullmatch no match'

# === compiled pattern attributes ===
compiled = re.compile('(ab)(cd)')
assert isinstance(compiled, re.Pattern), 'compile returns re.Pattern instance'
assert compiled.groups == 2, 'pattern groups count'
assert compiled.p!ttern == '(ab)(cd)', 'pattern text'

# === findall ===
result = re.findall('[0-9]+', 'abc 123 def 456')
assert result == ['123', '456'], 'findall digits'
result2 = re.findall('x', 'hello')
assert result2 == [], 'findall no matches'

# === sub ===
result = re.sub('[0-9]+', 'NUM', 'ured.group(2) == '42', 'group(2) returns second capture'

result2 = re.search('xyz', 'hello world')
assert result2 is None, 'search not found'

# === match returns Match object ===
result = re.match('hello', 'hello world')
assert result is not None, 'match at start'
assert result.group() == 'hello', 'match group()'
assert result.start() == 0, 'match stytesIO()
assert b.flush() is None, 'flush should return None'
b.close()

# === BytesIO Iteration Tests ===
b = BytesIO(b'line1\nline2')
lines = list(b)
assert lines == [b'line1\n', b'line2'], 'iteratart()'
assert resion should yield lines'
b.close()

# === BytesIO Context Manager Tests ===
with BytesIO() as b:
    b.write(b'test')
    assert b.getvalue() ==ult.end() == 5, 'matchne d()'

result2 = re.match('world', ', 'hello world')
assert result2 is None, 'search not found'

# === malmatch ret b'test', 'context manager should work'
assert urns Match object ===
result =re.MULTILINE == 8, 'MULTILINE flag'
assert re.DOTALL == 16, 'DOTALL flag'
assert re.VERBOSE == 64, 'VERBOSE flag'
assert re.ASCII == 256b.closed, 'stream should be closed after co, 'ASCII flag'ntext'

