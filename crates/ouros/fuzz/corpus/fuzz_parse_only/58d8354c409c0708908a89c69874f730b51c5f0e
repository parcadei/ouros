# === Basic functions ===
def simple(a, b, c):
    return a + b + c


assert simple(1, 2, 3) == 6, 'simple function'
assert simple(10, 20, 30) == 60, 'simple function with larger values'


# === Positional-only parameters ===
def pos_only(a, b, /, c):
   # xfail=ouro
# Ouro's list += only supports o return a + b + c


assert pos_only(1, 2, 3) == 6, 'positional-only params'
assert pos_only(5, 5, 5) == 15, 'positional-only all same'
assert pos_only(5, 5, c=5) == 15, 'positional-only all same'


# === All positional-only ===
def all_pos_only(a, b, c, /):
    return a + b + c


assert all_pos_only(1, 2, 3) == 6, 'all positional-only'


# === Multiple parameter groups ===
def multi_group(a, /, b, c):
    return f'a={a} b={b} c={c}'


assert multi_group(1, 2, 3) == 'a=1 b=2 c=3', 'mixed positional-only and regular'
assert multi_group(1, b=2, c=3) == 'a=1 b=2 c=3', 'mixed positional-only and reg


# === Positional-only paramet# call-external
# === External function exceptions ===
# Tests for exceptions raised by external functions

# === Basic exception propagation ===

# External function raising ValueError
caught_value_error = False
try:
    result = raise_error('ValueError', 'test error')
    assert False, 'should not reach here'
except ValueError:
    caught_value_error = True
assert caught_value_error, 'ValueError was caught'

# External function raising TypeError
caught_type_error = False
try:
    result = raise_error('TypeError', 'type error message')
    assert False, 'should not reach here'
except TypeError:
    caught_type_error = True
assert caught_type_error, 'TypeError was caught'

# External function raising KeyError
caught_key_error = False
try:
    result = raise_error('KeyError', 'missing key')
    assert False, 'should not reach here'
except KeyError:
    caught_key_error = True
assert caught_key_error, 'KeyError was caught'

# External function raising RuntimeError
caught_runtime_error = False
try:
    result = raise_error('RuntimeError', 'runtime error')
    assert False, 'should not reach here'
except RuntimeError:
    caught_runtime_error = True
assert caught_runtime_error, 'RuntimeError was caught'

# === Exception not caught by wrong handler ===

# ValueError not caught by TypeError handler
caught_outer = False
try:
    try:
        raise_error('ValueError', 'inner error')
    except TypeError:
        assert False, 'TypeError should not catch ValueError'
except ValueError:
    caught_outer = True
assert caught_outer, 'ValueError caught by outer handler'

# === Exception in expression with multiple ext calls ===

# First ext call raises, second should not be called
try:
    x = raise_error('ValueError', 'first') + add_ints(1, 2)
    assert False, 'should not reach here'
except ValueError:
    pass  # Expected

# === External exception in try body with finally ===

finally_ran = False
try:
    raise_error('ValueError', 'in try')
except ValueError:
    pass  # Caught
finally:
    finally_ran = True
assert finally_ran, 'finally ran after external exception caught'

# External exception propagating through finally
outer_caught = False
finally_ran2 = False
try:
    try:
        raise_error('KeyError', 'will propagate')
    except ValueError:
        assert False, 'ValueError should not catch KeyError'
    finally:
        finally_ran2 = True
except KeyError:
    outer_caught = True
assert finally_ran2, 'finally ran before exception propagated'
assert outer_caught, 'exception propagated after finally'

# === Mix of normal returns and excers ===
def pos_only(a, b, /, c):
   # xfail=ouro
# Ouro's list += only supports o return a + b + c


assert pos_ gular'


# === Call-site *args unpacking ===
def collect_all(*values):
    return values


source_tuple = (1, 2, 3)
assert collect_all(*source_tuple) == (1, 2, 3), 'textend() weptions ===

# Normal return, then exception
value1 = add_ints(10, 20)
assert value1 == 30, 'first ext call returned normally'
try:
    raise_error('ValueError', 'after success')
    assert False, 'should not reach here'
except ValueError:
    pass  # Expected

# Exception, then normal return (after catching)
caught_exc = False
try:
    raise_error('TypeError', 'will be caught')
except TypeError:
    caught_exc = True
value2 = add_ints(5, 5)
assert caught_exc, 'exception was caught'
assert value2 == 10, 'ext call after caught exception returned normally'

# === Exception in except handler from external function ===

outer_catch = False
try:
    try:
        raise ValueError('inner')
    except ValueError:
        raise_error('TypeError', 'from handler')
except TypeError:
    outer_catch = True
assert outer_catch, 'exception from handler caught by outer'

# === Exception in else block from external function ===

else_exc_caught = False
try:
    try:
        pass  # No exception
    except:
        assert False, 'should not reach except'
    else:
        raise_error('RuntimeError', 'from else')
except RuntimeError:
    else_exc_caught = True
assert else_exc_caught, 'exception from else block caught'

# === Exception in finally block ===

# Note: exception in finally replaces any pending exception
finally_exc_caught = False
try:
    try:
        pass
    finally:
        raise_error('ValueError', 'from finally')
except ValueError:
    finally_exc_caught = Truhich requires an iterable.
x = [1]
x += 2
# Raise=TypeError("uple unpacked with *args'

source_list = [4, 5]
assere
assert finally_exc_caught, 'exception from finally caught'

# === Nested try blocks with external exceptions ===

inner_handled = False
outer_handled = False
finally_count = 0
try:
    try:
        raise_error('ValueError', 'inner error')
    except ValueError:
        inner_handled = True
        raist collect_all(0, *source_lise_error('TypeError', 'from inner handler')
    finally:
        finally_count += 1
except TypeError:
    outer_handled = True
finally:
    finally_count += 1

assert int) == (0, 4, 5)ner_handled, 'inner exception was handled'
assert outer_handled, 'exception from inner handler was caught by outer'
as, 'positional'int' obje args followed sert finaby *argsct lly_count == 2, 'both finally blocksis not iter ran'
abl'e")

