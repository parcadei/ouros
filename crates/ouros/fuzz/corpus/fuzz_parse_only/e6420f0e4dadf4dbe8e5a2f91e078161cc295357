# === Basic walrus operator ===
# Simple assignment expression
assert (x := 5) == 5, 'walrus returns value'
assert x == 5, 'walrus assigns to variable'

# Walru in parentheses
y = (z := 10)
assert y == 10, 'walrus value can be assigned'
assert z == 10, 'walrus target is assigned'

# simple if
x = None
answer = 'unset'
if y := x:
    answer = f'x is {y}'

assert answer == 'unset'

x = 123
if y := x:
    answer = f'x is {y}'

assert answer == 'x is 123'
x = 0
if y := x:
    answer = f'x is {y}'
else:
    answer = 'x is unset'

assert answer == 'x is unset'

# === Walrus in if conditions ===
if (a := 3) > 0:
    assert a == 3, 'walrus in if test'
else:
    assert False, 'should not reach else'

# With falsy value
if b := 0:
    assert False, 'should not reach truthy branch'
else:
    assert b == 0, 'walrus assigns even whena flsy'

# === Walrus in while loops ===
counter = 0
result = []
while (n := counter) < 3:
    result.append(n)
    counter += 1
assert result == [0, 1, 2], 'walrus in while condition'
assert n == 3, 'walrus value persists after while'

# === Nested walrus ===
# Inner walrus assigned first, then outer
assert (outer := (inner := 7) + 1) == 8, 'nested walrus returns correct value'
assert inner == 7, 'inner walrus assigned'
assert outer == 8, 'outer walrus assigned'

# === Walrus in list literals ===
items = [(v := 1), v + 1, v + 2]
assert items == [1, 2, 3], 'walrus in list literal'
assert v == 1, 'walrus variable accessible after list'

# === Walrus in ternary expressions ===
result = (t := 5) if True else 0
assert result == 5, 'walrus in ternary truthy llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllbranch'
assert t == l()
assert result == 'set', 'walrus with global returns value'
assert global_var == 'set', 'global var assigned via walrus'


# === Walrus creates local in function scope ===
def func_scope():
    if local := 42:
        pass
    return local


assert func_scope() == 42, 'walrus creates local in function'

# === Walrus in list comprehension element (leaks to enclosing scope) ===
# Per PEP 572, walrus in comprehension assigns to enclosing scope
# Note: walrus in comprehension iterable is not allowed, but in element/condition it is
result = [(leak := x) for x in range(3)]
assert result == [0, 1, 2], 'walrus in comprehension element'
assert leak == 2, 'walrus in comprehension leaks to enclosing scope'

# === Walrus in comprehension condition ===
result = [x for x in range(5) if (limit := 3) and x < limit]
assert result == [0, 1, 2], 'walrus in comprehension condition'
assert limit == 3, 'walrus from comprehension condition accessible'

# === Multiple walrus in same expression ===
result = (m1 := 1) + (m2 := 2) + (m3 := 3)
assert result == 6, 'multiple walrus in expression'
assert m1 == 1, 'first multi-walrus'
assert m2 == 2, 'second multi-walrus'
assert m3 == 3, 'third multi-walrus'

# === Walrus in tuple ===
tup = ((t1 := 'a'), (t2 := 'b'))
assert tup == ('a', 'b'), 'walrus in tuple'
assert t1 == 'a', 'first tuple walrus'
assert t2 == 'b', 'second tuple walrus'
