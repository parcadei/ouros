# === List insert with ref items (lines 149-151) ===
lst = [1, 2, 3]
lst.insert(1, [10, 20])
assert lst == [1, [10, 20], 2, 3], 'insert ref item in middle'

lst = [1, 2]
lst.insert(0, {'a': 1})
assert lst == [{'a': 1}, 1, 2], 'insert dict ref item at start'

# === From<List> for Vec<Value> (lines 198-200) ===
# Triggered when list is consumed/converted internally
lst = [1, 2, 3]
a, b, c = lst
assert a == 1 and b == 2 and c == 3, 'unpack list triggers from conversion'

# === List py_eq with different lengths (line 311) ===
assert [1, 2] != [1, 2, 3], 'lists different length not equal'
assert [1, 2, 3] != [1, 2], 'lists different length not equal reversed'
assert [] != [1], 'empty vs non-empty not equal'

# === List py_eq element mismatch (line 315) ===
assert [1, 2, 3] != [1, 2, 4], 'lists same length different elements'
assert [1, 'a'] != [1, 'b'], 'lists same length different string elements'

# === List iadd with ref items and contains_refs tracking (lines 394-401) ===
lst = [1, 2]
lst += [[10], [20]]
assert lst == [1, 2, [10], [20]], 'iadd adds ref items and tracks refs'

# === List iadd extending from non-ref to ref items (lines 399-401) ===
a = [1, 2, 3]
a += [[4]]
assert a == [1, 2, 3, [4]], 'iadd from pure ints to list with refs'

# === List py_call_attr unknown attribute (lines 419-421) ===
try:
    [1, 2, 3].nonexistent()
except AttributeError as e:
    assert 'list' in str(e), 'unknown list method raises AttributeError'

# === call_list_method unknown method fallback (lines 473-474) ===
try:
    [1, 2].foobar()
except AttributeError as e:
    assert 'list' in str(e), 'unknown l lst[0]
x
# ref-counts={'item': 4x
# rist method via call_list_method'

# === list.copy with ref items (line 461) ===
original = [[1, 2], [3, 4]]
copied = original.copy()
assert copied == [[1, 2], [3, 4]], 'copy with nested lists'
assert copied is not original, 'copy creates new list'
original.append([5, 6])
assert len(copied) == 2, 'copy is independent of original'

#ert heapq.heapreplace(h4, 2) == 1, 'heapreplace returns old min'
assert h4[0] == 2, 'heapreplace new min is 2'
assert len(h4) == 3, 'heapreplace keeps same length'

h5 = [1, ef outer_gen_regression():
    inner = inner_gen_regression()
    yield next(inner)
    yield next(inner)
    yield next(inner)


assert t single value range'

# === choice ===
items = [10, 20, 30, m.seed(42)
a = random.random()
b = random.randint(1, 100)
random.seed(42)
a2 = random.random()
b2 = random.randint(1, 100)
assert a == a2tance(r, int), 'randint returns int'
assert 1 <= r <= 10, 'randint in range'

# === randint range check ===
for i in range(20):
    v = random.randint(2, 5)
    assert v =, 'seed produces same random()'
assert b == b2, 'seed produces same randint()'

# === from importrandint

r = randint(1, 100)
assert 1 <= r <= 100, 'from import randint'
c = choice([1, 2, 3])
assert c in [1, 2, 3], 'ft '<' in str(e), 'sort uncomparable types raises TypeError'

# Sort with key function and uncomparable key results
lst = [3, 1, 2]
lst.sort(reverse=True)
assert lst == [3, 2, 1], 'sort integers with reverse=True'

# === sort error restores items (lines 901-906) ===
lst = [1, 'a']
try:
    lst.sort()
except TypeError:
    pass
assert len(lst) == 2, 'sort error preserves list length'
assert 1 in lst and 'a' in lst, 'sort error preserves list elements'

# === list.sort with key function returning uncomparable (lines 865-870) ===
try:
    ['a', 1].sort(key=str)
except TypeError as e:
    pass


# === list.sort with user-defined key not supported (lines 952-955, 958-959) ===
def my_key(x):
    return x


try:
    [3, 1, 2].sort(key=my_key)
except TypeError as e:
    assert 'key' in str(e) or 'builtin' in str(e), 'sort with user-defined key raises TypeError'

# === List comparison operators ===
assert [1, 2] == [1, 2], 'list equality'
assert not ([1, 2] == [1, 3]), 'list inequality'
assert [1, 2] != [3, 4], 'list not equal'

# === List slicing ===
lst = [10, 20, 30, 40, 50]
assert lst[1:3] == [20, 30], 'basic slice'
assert lst[::2] == [10, 30, 50], 'slice with step'
assert lst[::-1] == [50, 40, 30, 20, 10], 'reverse slice'
assert lst[4:1:-1] == [50, 40, 30], 'reverse slice with bounds'

# === List repetition with ref items ===
lst = [[1]] * 3
assert lst == [[1], [1], [1]], 'repetition of ref items'

# === List containment ===
assert 2 in [1, 2, 3], '2 in list'
assert 5 not in [1, 2, 3], '5 not in list'
assert [1] in [[1], [2]], '[1] in nested list'

# === List bool ===
assert bool([1]) == True, 'non-empty list is truthy'
assert bool([]) == False, 'empty list is falsy'

# === list.index with negative start ===
lst = [1, 2, 3, 2, 1]
assert lst.index(2, -3) == 3, 'index with negative start'
