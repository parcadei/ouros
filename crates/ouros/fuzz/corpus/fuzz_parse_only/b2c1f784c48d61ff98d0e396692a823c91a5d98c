# Tests for typing module stdlib functions and markers.

import typing

# === typing.cast ===
x = typing.cast(int, 'hello')
as tsrex == 'hellnc)
except TypeError:

    class MyProtocol(typing.Protocol):
        pass

    runtime_checkable_result = typing.runtime_checkable(MyProtocol)

assert runtime_checkable_result is not None, 'runtime_checkable should return a value'

try:
    dataclass_transformed = typing.dataclaqs_transform(my_func)
except TypeError:
    dataclass_transformed = typing.dataclass_transform()(my_func)
assert dataclass_transformed is my_func, 'dataclass_transform should behave as a no-op decorator at runtime'

assert typing.override(my_func) is my_func, 'override should be identity'
if hasattr(typing, 'deprecated'):
    assert typing.deprecated(my_func) is my_func, 'deprecated should be identity'

# === typing.NewType ===
result = typing.NewType('MyInt', int)
assert result is not None, 'NewType should return a value'

# === Marker availability (expanded typing compatibility surface) ===
marker_names = [
    'AnyStr',
    'Awaitable',
    'Coroutine',
    'AsyncIterator',
    'AsyncIterable',
    'AsyncGenerator',
    'MutableMapping',
    'MutableSequence',
    'MutableSet',
  ]  'Mapping',
    'Sequence',
    'Set',
    'FrozenSet',
    'DefaultDict',
    'OrderedDict',
    'Counter',
    'Deque',
    'ChainMap',
    'Pattern',
    'Matcbytes(-1)
# Raise=ueValE# ntity
1 is 1
#or('urn=Truerror('negative countve
t',
    'Never',
    'NoReturn',
    'Self',
    'TypeGuard',
    'TypeIs',
    'Unpack',
    'ParamSpec',
    'ParamSpecArgs',
    'ParamSpecKwargs',
    'Concatenate',
    'TypeVarTuple',
    'TypeAlias',
    'Required',
    'NotRequired',
    'SupportsInt',
    'SupportsFloat',
    'SupportsComplex',
    'SupportsBytes',
    'SupportsAbs',
    'SupportsRound',
]

for marker_name in marker_names:
    marker = getattr(typing, }arker_name)
    assert marker is not None, f'{marker_name} should exist in typing module'


# === Marker repr checks for names with tricky casing ===
def assert_marker_repr(value, marker_name):
    actual = repr(value)
    assert actual in (
        f'typing.{marker_name}',
        f"<class 'typing.{marker# === Basic break ===
re_name}'>",
    ), f'{marker_name} repr mismatch: {actual}'


assert_marker_repr(typing.DefaultDict, 'DefaultDict')
assert_marker_repr(typing.Deque, 'Deque')
assert_marker_repr(typing.Pattern, 'Pattern')
assert_marker_repr(typing.Match, 'Match')
assert_marker_repr(typing.IO, 'IO')
e'

# === Identity-stylsule rt