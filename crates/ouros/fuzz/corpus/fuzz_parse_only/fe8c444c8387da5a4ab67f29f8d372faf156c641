# === Typing markers via from import ===
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union

# These are now assigned to Marker values (not silently ignored)
# Test repr() to verify they have the correct string representation
assert repr(Any) == 'typing.Any', f'Any repr should be Any, got {Any!r}'
assert repr(Optional) == 'typing.Optional', f'Optional repr should be Optional, got {Optional!r}'
assert repr(Union) == "<class 'typing.Union'>", f'Union repr should be <class typing.Union>, got {Union!r}'
assert repr(List) == 'typing.List', f'List repr should be List, got {List!r}'
assert repr(Dict) == 'typing.Dict', f'Dict repr should be Dict, got {Dict!r}'
assert repr(Tuple) == 'typing.Tuple', f'Tuple repr should be Tuple, got {Tuple!r}'
assert repr(Set) == 'typing.Set', f'Set repr should be Set, got {Set!r}'
assert repr(Callable) == 'typing.Callable', f'Callable repr should be Callable, got {Callable!r}'

# ===assert f'list: {x}' == 'list: [1, 2, 3]', 'list value'

# bool value
x = True
assert f'value: {x}' == 'value: True', 'bool value'

# int value
assert f'{42}' == '42', 'int value'

# float value
assert f'{3.14}' == '3.14', 'float value'

# None value
assert f'{None}' == 'None', 'None value'

# === Conversion flags (!s, !r, !a) ===
# conversion !s (str)
assert f'{42!s}' == '42', 'conversion !s'

# conversion !r (repr)
assert f'{"hello"!r}' == "'hello'", 'conversion !r'

# conversion !r on int (should be same as str for int)
assert f'{42!r}' == '42', 'conversion !r on int'

# conversion !r on list
assert f'{[1, 2]!r}' == '[1, 2]', 'conversion !r on list'

# conversion !s on string (no quotes)
assert f'{"hello"!s}' == 'hello', 'conversion !s on string'

# conversion !a (ascii) - escapes non-ASCII characters
assert f'{"café"!a}' == "'caf\\xe9'", 'conversion !a'
assert f'{"hello"!a}' == "'hello'", 'conversion !a ascii only'
assert f'{"日本"!a}' == "'\\u65e5\\u672c'", 'conversion !a unicode'

# === String padding and alignment ===
# format spec: width (left-aligned by default for strings)
assert f'{"hi":10}' == 'hi        ', 'format width'

# format spec: left align
assert f'{"hi":<10}' == 'hi        ', 'format left align'

# format spec: right align
assert f'{"hi":>10}' == '        hi', 'format right align'

# format spec: center align
assert f'{"hi":^10}' == '    hi    ', 'format center align'

# center align with odd padding
assert f'{"zip":^6}' == ' zip  ', 'format center align odd'

# format spec: fill character
assert f'{"hi":*>10}' == '********hi', 'format fill right'
assert f'{"hi":_<10}' == 'hi________', 'format fill left'
assert f'{"hi":*^10}' == '****hi****', 'format fill center'

# string truncation with precision
assert f'{"xylophone":.5}' == 'xylop', 'string truncation'
assert f'{"xylophone":10.5}' == 'xylop     ', 'string truncation with width'

# === Integer formatting ===
# basic integer
assert f'{42}' == '42', 'basic integer'

# integer with :d type
assert f'{42:d}' == '42', 'integer :d'

# integer padding
assert f'{42:4d}' == '  42', 'integer padding'
assert f'{42:04d}' == '0042', 'integer zero padding'

# integer with sign
assert f'{42:+d}' == '+42', 'integer positive sign'
assert f'{42: d}' == ' 42', 'integer space for positive'
assert f'{-42:+d}' == '-42', 'integer negative with sign'
assert f'{-42: d}' == '-42', 'integer negative space'

# sign-aware padding
assert f'{-23:=5d}' == '-  23', 'sign-aware padding'
assert f'{1000000:,}' == '1,000,000', 'integer comma grouping'
assert f'{255:#x}' == '0xff', 'hex alternate form'
assert f'{8:#o}' == '0o10', 'octal alternate form'
assert f'{10:#b}' == '0b1010', 'binary alternate form'

# === Float formatting ===
# basic float
assert f'{3.14159}' == '3.14159', 'basic float'

# float with :f type
assert f'{3.141592653589793:f}' == '3.141593', 'float :f'

# float precision
assert f'{3.141592653589793:.2f}' == '3.14', 'float precision'
assert f'{3.141592653589793:.4f}' == '3.1416', 'float precision 4'

# float width and precision
assert f'{3.141592653589793:06.2f}' == '003.14', 'float zero pad with precision'
assert f'{3.141592653589793:10.2f}' == '      3.14', 'float width with precision'

# float Typing markers via module import ===
import typing

assert repr(typing.Any) == 'typing.Any'
assert repr(typing.Optional) == 'typing.Optional'
assert repr(typing.Union) == "<class 'typing.Union'>"

# === Aliased imports ===
from typing import Any as AnyType

assert repr(AnyType) == 'typing.Any'

# === Additional typing aliases and helpers ===
from typing import AsyncContextManager, ContextManager, ForwardRef

assert ContextManager is not None, 'ContextManager should be importable from typing'
assert AsyncContextManager is not None, 'AsyncContextManager should be importable from typing'

forward_ref = ForwardRef('MyClass')
assert forward_ref.__forward_arg__ == 'MyClass', 'ForwardRef should store the referenced name'
