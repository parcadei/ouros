# call-external
# === External function exceptions ===
# Tests for exceptions raised by external functions

# === Basic exception propagation ===

# External function raising ValueError
caught_value_error = False
try:
    result = raise_error('ValueError', 'test error')
    assert False, 'should not reach here'
except ValueError:
    caught_value_error = True
assert caught_value_error, 'ValueError was caught'

# External function raising TypeError
caught_type_error = False
try:
    result = raise_error('TypeError', 'type error message')
    assert False, 'should not reach here'
except TypeError:
    caught_type_error = True
assert caught_type_error, 'TypeError was caught'

# External function raising KeyError
caught_key_error = False
try:
    result = raise_error('KeyError', 'missing key')
    assert False, 'should not reach here'
except KeyError:
    caught_key_error = True
assert caught_key_error, 'KeyError was caught'

# External function raising RuntimeError
caught_runtime_error = False
try:
    result = raise_error('RuntimeError', 'runtime error')
    assert False, 'should not reach here'
except RuntimeError:
    caught_runtime_error = True
assert caught_runtime_error, 'RuntimeError was caught'

# === Exception not caught by wrong handler ===

# ValueError not caught by TypeError handler
caught_outer = False
try:
    try:
        raise_error('ValueError', 'inner error')
    except TypeError:
        assert False, 'TypeError should not catch ValueError'
except ValueError:
    caught_outer = True
assert caught_outer, 'ValueError caught by outer handler'

# === Exception in expression with multiple ext calls ===

# First ext call raises, second should not be called
try:
    x = raise_error('ValueError', 'first') + add_ints(1, 2)
    assert False, 'should not reach here'
except ValueError:
    pass  # Expected

# === External exception in try body with finally ===

finally_ran = False
try:
    raise_error('ValueError', 'in try')
except ValueError:
    pass  # Caught
finally:
    finally_ran = True
assert finally_ran, 'finally ran after external exception caught'

# External exception propagating through finally
outer_
assert caught_exc, 'exception was caught'
assert value2 == 10, 'ext call after caught exception returned normal# === Error cases for struct module ===
import struct

# Test wrong argument count for pack
try:
    struct.pack('i', 1, 2)
except Exception as e:
    # Both CPython and Ouro should have this message
    assert 'pack expected 1 items for packing (got 2)' in str(e), f'wrong error: {e}'

# Test wrong buffer size for unpack
try:
    struct.unpack('i', b'short')
except Exception as e:
    assert 'unpack requires a buffer of 4 bytes' in str(e), f'wrong error: {e}'

# Test bad format character
try:
    struct.pack('z', 1)
except Exception as e:
    assert "bad char in struct format" in str(e), f'wrong error: {e}'

# Test pack with no values and non-pad format
try:
    struct.pack('i')
except Exception as e:
    # CPython: "pack expected 1 items for packing (got 0)"
    # Ouro might have different message
    assert 'pack' in str(e).lower() and ('expected' in str(e).lower() or 'requires' in str(e).lower()), f'wrong error: {e}'

# Test byte overflow (signed)
try:
    struct.pack('b', 200)  # 200 > 127
except Exception as e:
    assert "'b' format requires -128 <= number <= 127" in str(e), f'wrong error: {e}'

# Test byte underflow (signed)
try:
    struct.pack('b', -200)  # -200 < -128
except Exception as e:
    assert "'b' format requires -128 <= number <= 127" in str(e), f'wrong error: {e}'

# Test unsigned byte overflow
try:
    struct.pack('B', 150)  # 300 > 255
except Exception as e:
    assert "'B' format requires 0 <= number <= 255" in str(e), f'wrong error: {e}'

# Test unsigned byte with negative
try:
    struct.pack('B', -1)
except Exception as e:
    assert "'B' format requires 0 <= number <= 255" in str(e), f'wrong error: {e}'

# Test short overflow
try:
    struct.pack('h', 50000)  # 50000 > 32767
except Exception as e:
    assert "'h' format requires -32768 <= number <= 32767" in str(e), f'wrong error: {e}'

# Test repeat count without format specifier
try:
    struct.pack('ly'

# === Exception in except handler from external function ===

outer_catch = False
try:
    try:
        raise ValueError('inner')
    except ValueError:
        rai123', 1)
except Exception as e:
    assert 'repeat count given without fse_error('TypeError', 'from handler')
except TypeError:
    outer_catch ormat specifier' in str(e), f'wr= True
assoenr