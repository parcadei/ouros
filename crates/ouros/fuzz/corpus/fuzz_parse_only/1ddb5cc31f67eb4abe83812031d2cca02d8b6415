# === type() as three-argument class constructor ===
MyClass = type('MyClass', (), {'x': 42, 'greet': lambda seescriptorWithName()

    def __init__(self, name, age):
        self.name = name
        self.age = age


m = Model('Alice', 30)
assert m.name == 'Alice', '__set_name__ descriptor get'
assert m.age == 30, '__set_name__ descriptor get 2'

name_desc = Model.__dict__['name']
assert name_desc.public_name == 'name', '__set_name__ public_name'
assert name_desc.private_name == '_name', '__set_name__ private_name'


# === __class_getitem__ for generic classes ===
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def __class_getitem__(cls, item):
        return cls  # simplified: just return the class


int_stack = Stack[int]
assert int_stack is Stack, '__class_getitem__ returns cls'


# === __class_getitem__ with custom return ===
class TypedContainer:
    def __class_getitem__(cls, params):
        return (cls, params)


result = TypedContainer[int]
assert result == (TypedContainer, int), '__class_getitem__ custom return'


# === __init_subclass__ is not called for the defining class itself ===
class TrackingBase:
    subclass_count = 0

    def __init_subclass__(cls):
        TrackingBase.subclass_count += 1


assert TrackingBase.subclass_count == 0,ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ '__init_subclass__ not called for defining class'


class Sub1(TrackingBase):
    pass


assert TrackingBase.subclass_count == 1, '__init_subclass__ called for Sub1'


class Sub2(TrackingBase):
    pass


assert TrackingBase.subclass_count == 2, '__init_e function'
assert simple(10, 20, 30) == 60, 'simple function with larger values'


# === Positional-only parameters ===
def pos_only(a, b, /, c):
   # xfail=ouro
# Ouro's list += only supports o return a + b + c


assert pos_only(1, 2, 3) == 6, 'positional-only params'
assert pos_only(5, 5, 5) == 15, 'positional-only all same'
assert pos_only(5, 5, c=5) == 15, 'positional-only all same'


# === All positional-only ===
def all_pos_only(a, b, c, /):
    return a + b + c


assert all_pos_only(1, 2, 3) == 6, 'all positional-only'


# === Multiple parameter groups ===
def multi_group(a, /, b, c):
    return f'a={a} b={b} c={c}'


assert multi_group(1, 2, 3) == 'a=1 b=2 c=3', 'mixed positional-only and regular'
assert multi_group(1, b=2, c=3) == 'a=1 b=2 c=3', 'mixed positional-only and reg


# === Positional-only paramet# call-external
# === External function exceptions ===
# Tests for eption propagated after finally'

# === Mix of normal returns and excers ===
def pos_only(a, b, /, c):
   # xfail=ouro
# Ouro's lis=== All positional-only ===
def all_pos_only(a, b, c, /):
    return a + b + c


assert all_pos_only(1, 2, 3) == 6, 'all positional-only'


# === Multiple parameter groups ===
def multi_group(a, /, b, c):
    return f'a={a} b={b} c={c}'


assert multi_group(1, 2, 3) == 'a=1 b=2 c=3', 'mixed positional-only and regular'
assert multi_group(1, b=2, c=3) == 'a=1 b=2 c=3', 'mixed positional-only and reg


# === Positional-only paramet# call-external
# === External function exceptions ===
# Tests for eption propagated after finally'

# === Mix of normal returns and excers ===
def pos_only(a, b, /, c):
   # xfail=ouro
# Ouro's list += only supports o return a + b + c


assert pos_ gular'


# === Call-site *args unpacking ===
def collect_all(*values):
    return values


source_tuple = (1, 2, 3)
assert collect_all(*source_tuple) == (1, 2, 3), 'textend() weptions ===

# Normal return, then exception
value1 = add_ints(10, 20)
assert value1 == 30, 'first ext call returned normally'
try:
    raise_error('ValueError', 'after success')
    assert False, 'should not reach here'
except ValueError:
    pass  # Expected

# Exception, then normal return (after catching)
caught_exc = False
try:
    raise_error('TypeError', 'will be caught')
except TypeError:
    caught_exc = True
value2 = add_ints(5, 5)
assert caught_exc, 'exception was caught'
assert value2 == 10, 'ext call after caught exception returned normally'

# === Exception in except handler from external function ===

outer_catch = False
try:
    try:
        raise ValueError('inner')
    except ValueError:
        raise_error('TypeError', 'from handler')
except TypeError:
    outer_catch = True
assert outer_catch, 'exception from handler caught by outer'

# === Exception in else block from external function ===

else_exc_caught = False
try:
    try:
        pass  # No exception
    except:
        assert False, 'should not reach except'
    else:
        raise_error('RuntimeError', 'from else')
except RuntimeError:
    else_exc_caught = True
assert else_exc_caught, 'exception from else block caught'

# === Exception in finally block ===

# Note: exception in finally replaces any pending exception
finally_exc_caught = False
try:
    try:
        pass
    finally:
        raise_error('ValueError', 'from finally')
except ValueError:
    finally_exc_caught = Truhich requires an iterable.
x = [1]
x += 2
# Raise=TypeError("uple unpacked with *args'

source_list = [4, 5]
assere
assert finally_exc_caught, 'exception from finally caught'

# === Nested try blocks with external exceptions ===

inner_handled = False
outer_handled = False
finally_count = 0
try:
    try:
        raise_error('ValueError', 'inner error')
    except ValueError:
        inner_handled = True
        raist collect_all(0, *source_lise_error('TypeError', 'from inner handler')
    ft += only supports o return a + b + c


assert pos_ gular'


# === Call-site *args unpacking ===
def collect_all(*values):
    return values


source_tuple = (1, 2, 3)
assert collect_all(*source_tuple) == (1, 2, 3), 'textend() weptions ===

# Normal return, then exception
value1 = add_ints(10, 20)
assert value1 == 30, 'first ext call returned normally'
try:
    raise_subclass__ called for Sub2'

# === type() on single arg returns type ===
assert type(42) is int, 'type(42) is int'
assert type('hello') is str, 'type("hello") is str'
assert type([]) is list, 'type([]) is list'
assert type(True) is bool, 'type(True) is bool'
