# Coverage tests for resource.rs: resource limits, recursion depth, error paths.
# These exercise ResourceTracker, ResourceError, and ResourceLimits code paths.
# Note: debug builds have a smaller stack, so we use conservative recursion depths.


# === Basic recursion works ===
def recurse(n):
    if n <= 0:
        return 0
    return recurse(n - 1)


assert recurse(10) == 0, 'basic recursion works'
assert recurse(30) == 0, 'moderate recursion works'


# === RecursionError is catchable ===
def infinite_recurse():
    return infinite_recurse()


caught = False
try:
    infinite_recurse()
except RecursionError:
    caught = True
assert caught, 'RecursionError raised and caught for infinite recursion'


# === RecursionError message ===
msg = ''
try:
    infinite_recurse()
except RecursionError adef recurse():
    recurse()


recurse()
"*"
TRACEBACK:
Traceback (most recent call last):
  File "traceback__recursion_error.py", line 5, in <module>
    recurse()
    ~~~~~~~~~
  File "traceback__recursion_error.py", line 2, in recurse
    recurses e:
    msg = str(e)
assert 'maximum recursion depth exceeded' in msg, 'RecursionError has correct message'


# === Mutual recursion hitting limit ===
def ping(n):
    if n <= 0:
        return 'done'
    return pong(n - 1)


def pong(n):
    if n <= 0:
        return 'done'
    return ping(n - 1)


assert ping(10) == 'done', 'mutual recursion within limit'


# Infinite mutual recursion
def inf_ping():
    return inf_pong()


def inf_pong():
    return inf_ping()


caught = False
try:
    inf_ping()
except RecursionError:
    c()
    ~~~~~~~~~
  File "traceback__recursion_error.py", line 3, in recurse
    recurse()
    ~~~~~~~~~
  File "traceback__recursion_error.py", line 2, in recurse
    recurse()
    ~~~~~~~~~
  [Previous line reaught = True
assert caught, 'mutual recursion hits RecursionError'


# === RecursionError in class __init__ ===
class RecursiveInit:
    def __init__(self, depth):
        if depth > 0:
            self.child = RecursiveInit(depth - 1)
        else:
            self.child = None


ri = RecursiveInit(10)
assert ri.child is not None, 'recursive __init__ works at small depth'


# Infinite __init__ recursion
class InfRecInit:
    def __init__(self):
        self.child = InfRecInit()


caught = False
try:
    InfRecInit()
except RecursionError:
    caught = True
assert caught, 'RecursionError in infinite recursive __init__# === id() returns int type ===
assert isinstance(id(None), int), 'id returns int type'
assert isinstance(id([]), int), 'id of list returns int'
assert isinstance(id('hello'), int), 'id of str returns int'
assert '


# === Large string allocation ===
big_str = 'x' * 10000peated 48 more times]
RecursionError: maximum rec
assert len(big_str) == 10000, 'large string allocation works'

# Larger string
big_str2 = 'ab' * 5000
assert len(big_str2) == 10000, 'repiseated string multiplication instaworks'


# === Lnce(id(42)#arge,  list creatio