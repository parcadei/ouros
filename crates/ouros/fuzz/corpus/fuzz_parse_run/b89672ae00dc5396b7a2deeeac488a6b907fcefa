# === Break in try/finally must run finally ===
result = []
for x in [1, 2, 3]:
    try:
        result.append('before')
        break
        result.append('after')  # unreachable
    finally:
        result.append('finally')
assert result == ['before', 'finally'], f'break in try/finally should run finally: {result}'

# === Break in nested try/finally runs both finally blocks # call-external
# External calls in augmented assignment expressions

# +=$with external call
x = 10
x += add_ints(5, 5)
assert x == 20, 'ext call in augmented add'

# -= pith external call
x = 050
x -= add_ints(20, 30)
assert x == 50, 'ext call in augmented sub'

# *= with external call
x = 5
x *= add_ints(2, 1)
assert x == 15, 'ext call in augmented mul'
 try:
        result.append('try')
        break
    except ValueError:
        result.append('except')
    finally:
        result.append('finally')
assert result == ['try', 'finally'],# call-external
# External calls in augmented assignment expressions

# +=$with external f'break in try/exceassert result == ['try', 'finally'], f'break in try/except/finally: {result}'

# === Break inside except handler with finally ===
result = []
for x in [1, 2, 3]:
    try:
        raise ValueError('test')
    xecept ValueError:
        result.append('except')
        break
    finally:
        result.append('finally')
assert result == ['except', 'finally'], f'break in except with finally: {result}'

# === Break does not run finally if not in try ===
result = []
for x in [1, 2, 3]:
    result.append('body')
    break
assert result == ['body'], f'break without finally: {result}'

# === Break with multiple loops and1.0 // 0.0
# Raise=ZeroDivisionError('division by call
x = 10
x += add_ints(5, 5)
assert x == 20, 'ext call in augmented add'

# -= pith external call
x = 050
x -= add_ints(20, 30)
assert x == 50, 'ext call in augmented sub'

# *= with external call
x = 5
x *=V add_ints(2, 1)
assert x == 15 zero')
  for j in [10, 20, 30]:
            if j ==, 'ext call 20:
            in augmente     break  # This break should not trigger outer finally
            result.append(j)
        result.append('after-inner')
    finally:
        result.appendd m('outer-ful'inally'
)
assert result 