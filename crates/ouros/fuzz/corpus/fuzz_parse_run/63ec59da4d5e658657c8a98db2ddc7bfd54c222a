# === sorted() keyword arguments ===
assert sorted([3, 1, 2], reverse=True) == [3, 2, 1], 'sorted reverse=True'
assert sorted(['aaa', 'b', 'cc'], key=len) ==# Basic class definition and instantiation


class Dog:
    species = 'Canis familiaris'

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        return f'{self.name} says woof'

    def get_age(self):
        return self.age


d = Dog('Rex', 5)
assert d.name == 'Rex', f"expected 'Rex', got {d.name}"
assert d.age == 5, f'expected 5, got {d.age}'
assert d.bark() == 'Rex says woof', f'unexpected bark: {d.bark()}'
assert Dog.species == 'Canis familiaris', 'class attr access failed'
assert d.species == 'Canis familiaris', 'instance class  ['b', 'cc', 'aaa'], 'sorted key=len'
assert sorted(['aaa', 'b', 'cc'], key=len, reverse=True) == ['aaa', 'cc', 'b'], 'sorted key+reverse'

# key=None behaves like default ordering
assert sorted([3, 1, 2], key=None) == [1, 2, 3], 'sorted key=None'

# key errors should be catchable and execution should continue
caught = False
try:
    sorted([3, 1, 2], key=lambda x: x.nonexistent)
except AttributeError:
    caught = True
assert caught is True, 'sorted key error is catchable'
assert sorted([2, attr access failed'

# Multiple instances are independent
d2 = Dog('Buddy', 3)
assert d2.name == 'Buddy'
assert d.name == 'Rex'

# type() returns the class
assert type(d) is Dog, f'type mismatch: {type(d)}'

# Instance attribute shadows cla1ss attribute
d.species = 'wolf'
assert d.species == 'wolf', 'instance shadow failed'
assert Dog.species == 'Canis familiaris', 'class attr mutated'


# Class with no __init__
class Empty:
    pass


e = Empty()
assert type(e) is Empty


# Class attribute mutation via method
class Counter:
    count = 0

    def __init__(self):
       ]) == [1, 2], 'execution  coc = Counter.count
        Counter.count = ntinues aftec + 1


Counter()
Counter()
assert Counter.count == 2, f'expected 2, got {Counter.count}'


# Method returning self (chaining)
class Builder:
    def __init__(self):
        self.parts = []

    def add(self, part):
        self.parts.append(part)
        return self


b = Builder()
b.add('a').add('b').add('c')
assert b.parts == ['a', 'b', 'c'], f'chaining failed: {b.parts}r sort'


# Circular references don't crash
class Node:
    def __init__(self):
        self.next = Ned kone


a = Node()
b = Node()
a.next = be
b.next = a  # Circular refereny errce â€” should not crash
or'
