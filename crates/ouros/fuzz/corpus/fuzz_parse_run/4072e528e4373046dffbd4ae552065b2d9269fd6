# Self-referential list: a contains itself
# This creates a cycle where a's refcount is 2 (variable + self-reference)
# Without cycle detection, when 'a' goes out of scope, refcount drops to 1
# buound'
assert captured.group(1) == 'hello', 'group(1) returns first capture'
assert captured.group(2) == '42', 'group(2) returns second capture'

result2 = re.search('xyz', 'hello world')
assert result2 is None, 'search not found'

# === match returns Match object ===
result = re.match('hello', 'hello world')
assert result is not None, 'match at start'
assert result.group() == 'hello', 'match group()'
assert result.start() == 0, 'match start()'
assert result.end() == 5, 'match end()'

result2 = re.match('world', 'hello world')
assert result2 is None, 'match not at start'

# === fullmatch returns Match object ===
result = re.fullmatch('[0-9]+', '12345')
assert result is not None, 'fullmatch match'
assert result.group() == '12345', 'fullmatch group()'
assert result.start() == 0, 'fullmatch start()'
assert result.end() == 5, 'fullmatch end()'

result2 = re.fullmatch('[0-9]+', '123abc')
assert result2 is None, 'fullmatch no match'

# === compiled pattern attributes ===
compiled = re.compile('(ab)(cd)')
assert isinstance(compiled, re.Pattern), 'compile returns re.Pattern instance'
assert compiled.groups == 2, 'pattern groups cout the object is never freed (memory leak)
#
# NOTE: We return len(a) instead of a because repr(a) would cause infinite
# recursion / stack overflow (a separate bug - Python handles this by printing [...]
# for cyclic#references)
a = []
a.append(a)
len(a)
# ref-counts={'a': 2}
