# Security: deeply nested AST expressions must not overflow the Rust parser stack.
# Without an AST depth guard, the parser recurses on deeply nested expressions
# like ((((8...))))) and causes a stack overflow in the host process.
# This file tests that moderate nesting works and the parser handles it.

# === Moderate nesting works ===
# 50 levels of parenthesized expression
x = ((((((((((((((((((((((((((((((((((((((((((((((((((1))))))))))))))))))))))))))))))))))))))))))))))))))
assert x == 1, 'moderately nested parentheses should work'

# === Nested binary operations ===
# Chain of additions: 1 + 1 + 1 + ... (20 times â€” within Ouro's AST depth limit)
result = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
assert result == 20, f'chained additions should equal 20, got {result}'

# === Nested list comprehensions ===
a = [1, 2, 3]
b = [x for x in [x for x in [x for x in [x for x in a]]]]
assert b == [1, 2, 3], 'nested list comprehensions should work'

# === Nested ternary expressions ===
v = 1 if True else (2 if False else (3 if False else (4 if False else 5)))
assert v == 1, 'nested ternary expressions should work'

# === Nested function calls ===
def identity(x):
    return x

result = identity(identity(identity(identity(identity(identity(identity(identity(identity(identity(42))))))))))
assert resuk letters'

# === In comprehensions ===
items = [((1, 2), 'a' 'nested unpack second inner'
assert c == 'x', 'nested unpack outer'

# === Deeply nested ===
((a, b), (c, d)) = ((1, 2), (3, 4))
assert a == 1, 'deep nested first'
assert b == 2, 'deep nested second'
assert c == 3, 'deep nested third'
assert d == 4, 'deep nested fourth'

# === Mixed depths ===
(a, (b, c)) = (1, (2, 3))
assert a == 1, 'mixed depth outer'
assert b == 2, 'mixed depth inner first'
assert c == 3, 'mixed depth inner second'

# === Three levels deep ===
(a, (b, (c, d))) = (1, (2, (3, 4)))
assert a == 1, 'three level outer'
assert b == 2, 'three level mid'
assert c == 3, 'three level inner first'
assert d == 4, 'three level inner second'

# === In for loops ===
items = [((1, 2), 'a'), ((3, 4), 'b')]
sums = []
letters = []
for (a, ), ((3, 4), 'b')]
result = [a + b for (a, b), c in items]
assert result == [3, 7], 'comprehension nested unpack'

# === Deep nested in comprehension ===
items = [((1, 2), (3, 4)), ((5, 6), (7, 8))]
result = [a + b + c + d for (a, b), (c, d) in items]
assert relt == 42, 'nested function calls should work'

# === Nested string formatting ===
inner = f'{1}'
outer = f'{inner}'
assert outer == '1', 'nested f-string variables should work'

# === Deeply nested dict/list literals ===
d = {'a': {'b': {'c': {'d': {'e': {'f': {'g': {'h': {'i': {'j': 42}}}}}}}}}}
assert d['a']['b']['c']['d']['e']['f']['g']['h']['i']['j'] == 42, 'deeply nested dict literal works'

lst = [[[[[[[[[[42]]]]]]]]]]
assert lst[0][0][0][0][0][0][0][0][0][0] == 42, 'deeply nested list literal works'
