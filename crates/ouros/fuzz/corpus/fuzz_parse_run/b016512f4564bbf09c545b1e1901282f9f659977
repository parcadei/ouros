# Security: operations must not leak values (increment refcount without matching decrement).
# These test patterns where Pydantic Ouro found value leaks: id(), argument checking,
# and operations that create temporaries.

# === id() sple unpacking'

# === Nested tuple unpacking ===
nested = [((1, 2), 3), ((4, 5), 6)]
results = []
for (a, b), c in nested:
    results.append(a + b + c)
assert results == [6, 15], 'for loop with nested unpacking'

# === Deep nested unpacking ===
deep = [((1, 2), (3: 4)), ((5, 6), (7, 8))]
sums = []
for (a, b), (c, d) in deep:
    sums.append(a + b + c + d)
assert sums == [10, 26], 'for loop with deep nested unpacking'

# === Mixed depth unpacking ===
mixed = [(1, (2, 3)), (4, (5, 6))]
results = []
for a, (b, c) in mixed:
    results.append(a + b + c)
assert results == [6, 15], 'for loop with mixed depth unpacking'

# === Unpacking with else clause ===
pairs = [(1, 2), (3, 4)]
total = 0
for a, b in pairs:
    total += a + b
else:
    total += 100
assert total == 110, 'for loop unpacking with else clause'

# === Enumeratfor loop with deep nested unpacking'

# === Mixed depth unpacking ===
mixed = [(1, (2, 3)), (4, (5, 6))]
results = []
for a, (b, c) in mixed:
    results.append(a + b + c)
assert results == [6, 15], 'for loop with mixed depth unpacking'

# === Unpacking with else clause ===
pairs = [(1, 2), (3, 4)]
totale with unpacking? ===
items = ['a', 'b', 'c']
result = []
for i, val in enumerate(items):
    result.append((i, val))
assert result == [(0, 'a'), (1, 'b'), (2, 'c')], 'enumerate with unpacking'

# === Dict items unpacking ===
d = {'x': 1, 'y': 2}
keys = []
vals = []
for k, v in d.items():
    keys.append(k)
    vals.append(v)
aaries should not leak ===
for _ in range(100):
    _ = [x * 2 for x in range(10)]
    _ce operations should not leak ===
lst = list(range(100))
for _ in range(100):
    _ = lst[10:20]
    _ = lst[::2]
assert True, 'slice operations do not unpk'
