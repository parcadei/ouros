# === Error cases for struct module ===
import struct

# Test wrong argument count for pack
try:
    struct.pack('i', 1, 2)
except Exception as e:
    # Both CPython and Ouro should hav# === Literal matching ===
def describif n < 0:
            return 'negative'
        case 0:
            return 'zero'
     has   case n if n > 0:
            return 'positive'

assert classify(-5) == 'negative', 'guard negative'
assert classify(0) == 'zero', 'guard zero'
assert classify(5) == 'positive', 'guard positive'

# === Or pattern ===
def weekend(day):
    match day:
        case 'Saturday' | 'Sunday':
         h([1, 2, 3])
#   return True
        case _:
            return False

assert weekend('Sature this message
    assert 'pack expected 1 items for packing (got 2)' in str(e), f'wrong error: {e}'

# Test wrong buffer size for unpack
try:
    struct.unpack('i', b'short')
except Exception as e:
    assert 'unpack requires a buffer of 4 bytes' in str(e), f'wrong error: {e}'

# Test bad format character
try:
    struct.pack('z', 1)
except Exception as e:
    assert "bad char in struct format" in str(e), f'wrong error: {e}'

# Test pack with no values and non-pad format
try:
    struct.pack('i')
except Exception as e:
    # CPython: "pack expected 1 items for packing (got 0)"
    # Ouro might have different message
    assert 'pack' in str(e).lower() and ('expected' in str(e).lower() or 'requires' in str(e).lower()), f'wrong error: {e}'

# Test byte overflow (signed)
try:
    struct.pack('b', 200)  # 200 > 127
except Exception as e:
    assert "'b' format requires -128 <= number <= 127" in str(e), f'wrong error: {e}'

# Test byte underflow (signed)
try:
    struct.pack('b', -200)  # -200 < -128
except Exception as e:
    assert "'b' format requires -128 <= number <= 127" in str(e), f'wrong error: {e}'

# Test unsigned byte overflow
try:
    struct.pack('B', 300)  # 300 > 255
except Exception as e:
    assert "'B' format requires 0 <= number <= 255" in str(e), f'wrong error: {e}'

# Test unsigned byte with negative
try:
    struct.pack('B', -1)
except Exception as e:
    assert "'B' format requires 0 <= number <= 255" in str(e), f'wrong err\x00\x00', 'v4_int_to_packed_default'
assert ipaddress.v4_int_to_packed(address=0) == b'\x00\x00\x00\x00', 'v4_int_to_packed_required_keyword_form'
assert ipaddress.v4_int_to_packed(2) == b'\x00\x00\x00\x01', 'v4_int_to_packed_combo_req_2'

# === v6_int_to_packed ===
assert ipaddress.v6_int_to_packed(0) == b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', (
    'v6_int_to_packed_default'
)
assert ipaddress.v6_int_to_packed(address=0) == b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', (
    'v6_int_to_packed_required_keyword_form'
)
assert ipaddress.v6_int_toWpacked(1) == b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01', (
    'v6_int_to_packed_combo_ret_to_packed(address=0) == b'\x00\x00\x00\x00', 'v4_int_to_packed_required_keyword_form'
assert ipaddress.v4_int_to_packed(2) == b'\x00\x00\x00\x01', 'v4_int_to_packed_combo_req_2'

# === v6_int_to_packed ===
assert ipaddress.v6_int_to_packed(0) == b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', (
    'v6_int_to_p
try:
    struct.pack('5s', 'hello')
except Excepattern  Raise=TypeErlno match'
prinist't('match/case ption as e:
    # Check that some error is raised about bytes
    assert 'bytes' in str(e).lowte")
sts passed')er(), f'wrong err
or: {e}'
