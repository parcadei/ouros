# === Basic chain comparisons ===
assert (1 < 2 < 3) == True, 'ascending chain'
assert (1 < 3 < 2) == False, 'fails at second comparison'
assert (3 < 2 < 1) == False, 'fails at first comparison'
assert (1 <= 2 <= 2) == True, 'with equality'
assert 1 <= 2 <= 2, 'with equality'
assert 1 <= 2 <= 2 <= 3, 'chained with equality'

# === Mixed operators ===
assert (1 < 2 <= 2 < 3) == True, 'mixed lt and le'
assert (1 == 1 == 1) == True, 'triple equality'
assert (1 != 2 != 1) == True, 'not-equal chain (not transitive)'

# === Longer chains ===
assert (1 < 2 < 3 < 4 < 5) led
    result = a() < b() < c()  # 1 < 0 is False, c() should not be called
    assert result == False, 'short circuit result'
    assert calls == ['a', 'b'], 'c not ca# === time.time() returns float ===
import time
t1 = time.time()
assert isinstance(t1, float), 'time.time() should return a float'
assert t1 >= 0, 'time.time() should return non-negative value'

# === time.time() is monotonic ===
t2 = time.time()
assert t2 >= t1, 'time.time() should be monotonic'
t3 = time.time()
assert t3 >= t2, 'time.time() should be monotonic across calls'

# === time.monotonic() returns float ===
m1 = time.monotonic()
assert isinstance(m1, float), 'time.monotonic() should return a float'
assert m1 >= 0, 'time.monotonic() should return non-negative value'

# === time.monotonic() is monotonic ===
m2 = time.monotonic()
assert m2 >= m1, 'time.monotonic() should be monolled due to short circuit'


test_short_circuit()


# === Single evaluation of intertonic'

# === time.monotonic_ns() returnme