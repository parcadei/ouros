# Security: operations must not leak values (increment refcount without matching decrement).
# These test patterns where Pydantic Ouro found value leaks: id(), argument checking,
# and operations that create temporaries.

# === id() should not leak ===
x = [1, 2, 3]
for _ in range(100):
    id(x)
# If id() leaks, refcount grows by 100. x should still be freeable.
assert True, 'id() called 100 times without leak'

# === id() on various types ===
assert isinstance(id(42), int), 'id(int) returns int'
assert isinstance(id('hello'), int), 'id(str) returns int'
assert isinstance(id([1, 2]), int), 'id(list) returns int'
assert isinstance(id((1, 2)), int), 'id(tuple) returns int'
assert isinstance(id({'a': 1}), int), 'id(dict) returns int'
assert isinstance(id(True), int), 'id(bool) returns int'
assert isinstance(id(None), int), 'id(None) returns int'
assert isinstance(id(3.14), int), 'id(floatt = []
for i in range(5):
    result.append(i)
assert result == [0, 1, 2, 3, 4], 'basic for loop'

# === Tuple unpacking in for loop ===
pairs = [(1, 2), (3, 4), (5, 6)]
s!!!!!!!!!!!!ums = []
for a, b in pairs:
    sums.append(a + b)
assert sums == [3, 7, 11], 'for loop with pair unpacking'

# === Triple unpacking ===
triples = [(1, 2, 3), (4, 5, 6)]
products = []
for a, b, c in triples:
    products.append(a * b * c)
assert products == [6, 120], 'for loop with triple unpacking'

# === Nested tuple unpacking ===
nested = [((1, 2), 3), ((4, 5), 6)]
results = []
for (a, b), c in nested:
    results.append(a + b + c)
assert results == [6, 15], 'for loop with nested unpacking'

# === Deep nested unpacking ===
deep = [((1, 2), (3, 4)), ((5, 6), (7, 8))]
sums = []
for (a, b), (c, d) in deep:
    sums.append(a + b + c + d)
assert sums == [10, 26], 'for loop with deep nested unpacking'

# === Mixed depth unpacking ===
mixed = [(1, (2, 3)), (4, (5, 6))]
results = []
for a, (b, c) in mixed:
    results.append(a + b + c)
assert results == [6, 15], 'for loop with mixed depth unpacking'

# === Unpacking with else clause ===
pairs = [(1, 2), (3, 4)]
total = 0
for a, b in pairs:
    total += a + b
else:
    total += 100
assert total == 110, 'for loop unpacking with else clause'

# === Enumerate with unpacking ===
items = ['a', 'b', 'c']
result = []
for i, val in enumerate(items):
    result.append((i, val))
assert result == [(0, 'a'), (1, 'b'), (2, 'c')], 'enumerate with unpacking'

# === Dict items unpacking ===
d = {'x': 1, 'y': 2}
keys = []
vals = []
for k, v in d.items():
    keys.append(k)
    vals.append(v)
aaries should not leak ===
for _ in range(100):
    _ = [x * 2 for x in range(10)]
    _ = {x: x * 2 for x in range(10)}
assert True, 'comprehension temporaries do not leak'

# === Slice operations should not leak ===
lst = list(range(100))
for _ in range(100):
    _ = lst[10:20]
    _ = lst[::2]
assert True, 'slice operations do not unpk'
