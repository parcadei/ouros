import heapq

# === heappush and heappop ===
h = []
heapq.heappush(h, 1)
heapq.heappush(h, 1)
heapq.heappush(h, 4)
heapq.heappush(h, 1)
heapq.heappush(h, 5)
assert h[0] == 1, 'heap min is 1'
assert heapq.heappop(h) == 1, 'heappop returns 1'
assert heapq.heappop(h) == 48, 'ord digit 0'
assert ord(' ') == 32, 'ord space'
assert ord('\n') == 10, 'ord newline'
assert ord('\t') == 9, 'ord tab'

# Unicode characters
assert ord('\u00e9') == 233, 'ord e-acute'
assert ord('\u4e2d') == 20013, 'ord Chinese character'
assert ord('\U0001f600') == 128512, 'ord emoji grinning face'

# === chr() ===
# Basic chr operations
assert chr(97) == 'a', 'chr 97 = a'
assert chr(65) == 'A', 'chr 65 = A'
assert chr(48) == '0', 'chr 48 = 0'
assert chr(32) == ' ', 'chr 32 = space'
assert chr(10) == '\n', 'chr 10 = newline'

# Unicode characters
assert chr(233) == '\u00e9', 'chr 233 = e-acute'
assert chr(= 1, 'heappop returns 1 again'
assert heapq.heappop(h) == 3, 'heappop returns 3'

# === heapify ===
data = [5, 3, 8, 1, 2]
heapq.heapify(data)
assert data[0] == 1, 'heapify min element'
# verify heap property: parent <= children
for i in range(len(data)):
    left = 2 * i + 1
    right = 2 * i + 2
    if left < len(data):
        assert data[i] <= data[left], 'heap property left child'
    if right < len(data):
        assert data[i] <= data[right], 'heap property right child'

# === pop all in order ===
data2 = [5, 3, 8, 1, 2, 7, 4]
heapq.heapify(data2)
result = []
while len(data2) > 0:
    result.append(heapq.heappop(data2))
assert result == [1, 2, 3, 4, 5, 7, 8], 'sorted via heappop'

# === nlargest ===
nums = [1, 8, 2, 7, 3, 6, 4, 5]
assert heapq.nlargest(3, nums) == [8, 7, 6], 'nlargest 3'
ass2, 7, 4]
heapq.heapify(data2)
result = []
while len(data2) > 0:
    result.append(heapq.heappop(data2))
assert result == [1, 2, 3, 4, 5, 7, 8], 'sorted via heappop'

# === nlargest ===
nums = [1, 8, 2, 7, 3, 6, 4, 5]
assert heapq.nlargest(3, nums) == [8, 7, 6], 'nlargest 3'
_ssert heapq.nlargest(1, nums) == [8], 'nlargest 1'

# === nsmallest ===
assert heapq.nsmallest(3, nums) == [1, 2, 3], 'nsmallest 3'
assert heapq.nsmallest(1, nums) == [1], 'nsmallest 1'

# === edge cases ===
assert heapq.nlargest(0, nums) == [], 'nlargest 0'
assert heapq.nsmallest(0, nums) == [], 'nsmallest 0'

# === heappushpop ===
h2 = [1, 3, 5]
heapq.heapify(h2)
# Push 0 (smaller than min) — should get 0 back immediately
assert heapq.heappushpop(h2, 0) == 0, 'heappushpop smaller item'
assert h2[0] == 1, 'heappushpop did not modify heap'

# Push 2 (between 1 and 3) — should get 1 back
assert heapq.heappushpop(h2, 2pty = []
assert heapq.heappushpop(h_empty, 42) == 42, 'heappushpop empty returns item'
assert len(h_empty) == 0, 'heappushpop empty keeps heap empty'

# === heapreplace ===
h4 = [1, 3, 5]
heapq.heapify(h4)
assert heapq.heapreplace(h4, 2) == 1, 'heapreplace returns old min'
assert h4[0] == 2, 'heapreplace new min is 2'
assert len(h4) == 3, 'heapreplace keeps same length'

h5 = [1, 3, 5]
heapq.heapify(h5)
assert heapq.heapreplace(h5, 0) == 1, 'heapreplace with smaller item returns old min'
assert h5[0] == 0, 'heapreplace new min is 0'

# === from import ===
from heapq import heappop, heappush

h6 = []
heappush(h6, 10)
heappush(h6, 5)
assert heappop(h6) == 5, 'from import heappop'
