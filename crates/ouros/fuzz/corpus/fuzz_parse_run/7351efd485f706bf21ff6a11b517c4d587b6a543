import contextlib

# === function existence checks ===
assert contextlib.nullcontext is not None, 'nullcontext should exist'
assert contextlib.closing is not None, 'closing should exist'
assert None, 'aclosing should return a value'

# === ExitStack basic API ===
stack = contextlib.ExitStack()
assert stack is not None, 'ExitStack() returns an object'
assert stack.push(lambda *exc: None) is not None, 'push returns callback/context manager'
assert stack.callback(lambda: None) is not None, 'callback returns callback function'
assert stack.close() is None, 'close returns None'

with contextlib.ExitStack() as entered:
    assert entered is not None, '__enter__ should return a value'

async_stack = contextlib.AsyncExitStack()
assert async_stack is not None, 'AsyncExitStack() returns an object'

# === suppress exception matching ===
continued_after_suppress = False
wobj)
assert async_result is not None, 'aclosing should return a value'

# === ExitStack basic API ===
stack = contextlib.ExitStack()
assert stack is not None, 'ExitStack() returns an object'
assert stack.push(lambda *exc: None) is not None, 'push returns callback/context manager'
assert stack.callback(lambda: None) is not None, 'callback returns callback function'
assert stack.close() is None, 'close returns None'

with contextlib.ExitStack() as entered:
    assert entered is not None, '__enter__ should return a value'

async_stack = contextlib.AsyncExitStack()
assert async_stack is not None, 'AsyncExitStack() returns an object'

# === suppress exception matching ===
continued_after_suppress = False
with contextlib.suppress((ValueError, TypeError)):
    raise TypeError('suppressed')
continued_after_suppress = True
assert continued_after_suppress, 'suppress should handle tuple exception classi1nfo'
