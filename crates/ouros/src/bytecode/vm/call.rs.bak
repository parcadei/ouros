//! Function call helpers for the VM.
//!
//! This module contains the implementation of call-related opcodes and helper
//! functions for executing function calls. The main entry points are the `exec_*`
//! methods which are called from the VM's main dispatch loop.

use std::{cmp::Ordering, str::FromStr};

use smallvec::SmallVec;

use super::{
    CallFrame, PendingBuiltinFromList, PendingBuiltinFromListKind, PendingFilter, PendingListSort, PendingMap,
    PendingNewCall, PendingReduce, PendingSumFromList, VM,
};
use crate::{
    args::{ArgValues, KwargsValues},
    asyncio::Coroutine,
    builtins::{Builtins, BuiltinsFunctions},
    exception_private::{ExcType, RunError, RunResult},
    heap::{DropWithHeap, Heap, HeapData, HeapGuard, HeapId},
    intern::{ExtFunctionId, FunctionId, Interns, StaticStrings, StringId},
    io::PrintWriter,
    modules::{ModuleFunctions, typing::TypingFunctions},
    os::OsFunction,
    resource::ResourceTracker,
    tracer::VmTracer,
    types::{
        AttrCallResult, Dict, Instance, List, OuroIter, PyTrait, Type, UserProperty, allocate_tuple,
        bytes::{bytes_fromhex, call_bytes_method},
        class::PropertyAccessorKind,
        dict::dict_fromkeys,
        make_generic_alias,
        str::{call_str_method, str_maketrans},
    },
    value::{EitherStr, Value},
};

/// Result of executing a call opcode.
///
/// Used by the `exec_*` methods to communicate what action the VM's main loop
/// should take after the call completes.
#[derive(Debug)]
pub(super) enum CallResult {
    /// Call completed successfully - push this value onto the stack.
    Push(Value),
    /// A new frame was pushed for a defined function call.
    /// The VM should reload its cached frame state.
    FramePushed,
    /// External function call requested - VM should pause and return to caller.
    External(ExtFunctionId, ArgValues),
    /// OS operation call requested - VM should yield `FrameExit::OsCall` to host.
    ///
    /// The host executes the OS operation and resumes the VM with the result.
    OsCall(OsFunction, ArgValues),
}

impl From<AttrCallResult> for CallResult {
    fn from(result: AttrCallResult) -> Self {
        match result {
            AttrCallResult::Value(v) => Self::Push(v),
            AttrCallResult::OsCall(func, args) => Self::OsCall(func, args),
            AttrCallResult::ExternalCall(ext_id, args) => Self::External(ext_id, args),
            AttrCallResult::PropertyCall(_, _) => {
                // PropertyCall should be handled by the VM's load_attr, not generic conversion.
                // This variant is only used by load_attr to defer property execution.
                // If we reach here, it indicates a bug in the VM's attribute loading logic.
                unreachable!("PropertyCall must be handled by load_attr, not generic conversion")
            }
            AttrCallResult::DescriptorGet(_) => {
                // DescriptorGet should be handled by the VM's load_attr, not generic conversion.
                // This variant is only used by load_attr to defer descriptor protocol execution.
                // If we reach here, it indicates a bug in the VM's attribute loading logic.
                unreachable!("DescriptorGet must be handled by load_attr, not generic conversion")
            }
            AttrCallResult::ReduceCall(_, _, _) => {
                // ReduceCall must be handled by the VM's call_attr/call_function, not generic conversion.
                unreachable!("ReduceCall must be handled by the VM, not generic conversion")
            }
            AttrCallResult::MapCall(_, _) => {
                // MapCall must be handled by the VM's call_attr/call_function, not generic conversion.
                unreachable!("MapCall must be handled by the VM, not generic conversion")
            }
            AttrCallResult::FilterCall(_, _) => {
                // FilterCall must be handled by the VM's call_attr/call_function, not generic conversion.
                unreachable!("FilterCall must be handled by the VM, not generic conversion")
            }
            AttrCallResult::CallFunction(_, _) => {
                // CallFunction must be handled by the VM's call_attr/call_function, not generic conversion.
                unreachable!("CallFunction must be handled by the VM, not generic conversion")
            }
        }
    }
}

impl<T: ResourceTracker, P: PrintWriter, Tr: VmTracer> VM<'_, T, P, Tr> {
    // ========================================================================
    // Call Opcode Executors
    // ========================================================================
    // These methods are called from the VM's main dispatch loop to execute
    // call-related opcodes. They handle stack operations and return a result
    // indicating what the VM should do next.

    /// Executes `CallFunction` opcode.
    ///
    /// Pops the callable and arguments from the stack, calls the function,
    /// and returns the result.
    ///
    /// Contains an inlined fast path for calling simple sync `def` functions
    /// (no closures, no defaults, no async, no cells, simple signature).
    /// This avoids the 4-level dispatch chain (`exec_call_function` -> `call_function` ->
    /// `call_def_function` -> `call_sync_function`) that dominates recursive workloads
    /// like `fib(n)`.
    #[inline]
    pub(super) fn exec_call_function(&mut self, arg_count: usize) -> Result<CallResult, RunError> {
        // Peek at callable to check for fast path before popping args
        let callable = self.peek_at_depth(arg_count);
        if let Value::DefFunction(func_id) = callable {
            let func_id = *func_id;
            let func = self.interns.get_function(func_id);
            if func.is_simple_sync() {
                // Extract scalar values before dropping the borrow on `func`
                let param_count = func.signature.param_count();
                let namespace_size = func.namespace_size;
                return self.exec_call_function_simple(func_id, param_count, namespace_size, arg_count);
            }
        }
        // Slow path: full dispatch chain for complex cases
        let args = self.pop_n_args(arg_count);
        let callable = self.pop();
        self.call_function(callable, args)
    }

    /// Fast path for calling a simple sync `def` function with positional args only.
    ///
    /// Inlines the entire call setup that normally goes through `call_function` ->
    /// `call_def_function` -> `call_sync_function`. For the common case of a simple
    /// function (no closures, no defaults, no cells, no async), this:
    /// 1. Moves args directly from operand stack to namespace (no `ArgValues` intermediate)
    /// 2. Skips the callable type dispatch
    /// 3. Skips the async check
    /// 4. Skips cell/free-var creation
    /// 5. Avoids allocating empty `Vec`s for defaults and cells
    #[inline]
    fn exec_call_function_simple(
        &mut self,
        func_id: FunctionId,
        param_count: usize,
        namespace_size: usize,
        arg_count: usize,
    ) -> Result<CallResult, RunError> {
        // Validate arg count matches param count (simple signatures have no defaults)
        if arg_count != param_count {
            // Pop args and callable, then delegate to full path for proper error reporting
            let args = self.pop_n_args(arg_count);
            let _callable = self.pop();
            return self.call_sync_function(func_id, &[], Vec::new(), args);
        }

        // Get call position BEFORE borrowing namespaces mutably
        let call_position = self.current_position();

        // Allocate namespace
        let namespace_idx = match self.namespaces.new_namespace(namespace_size, self.heap) {
            Ok(idx) => idx,
            Err(e) => {
                // Clean up stack on allocation failure: pop args + callable
                for _ in 0..arg_count {
                    let v = self.stack.pop().expect("stack underflow");
                    v.drop_with_heap(self.heap);
                }
                let _callable = self.stack.pop(); // DefFunction has no heap data
                return Err(e.into());
            }
        };

        // Move args from operand stack directly into namespace without intermediate allocation.
        // Stack layout: [..., callable, arg0, arg1, ..., argN-1]
        // We access `self.stack` and `self.namespaces` as separate fields to split the borrow.
        {
            let namespace = self.namespaces.get_mut(namespace_idx).mut_vec();

            // Drain the top arg_count values from the stack directly into the namespace.
            // These are the args in correct order (arg0 is deepest, argN-1 is on top).
            let stack_len = self.stack.len();
            let args_start = stack_len - arg_count;
            namespace.extend(self.stack.drain(args_start..));

            // Fill remaining namespace slots with Undefined (local variables)
            namespace.resize_with(namespace_size, || Value::Undefined);
        }

        // Pop the callable (DefFunction variant has no heap data to clean up)
        let _callable = self.stack.pop();

        // Re-lookup function from interns for the correct lifetime on code reference.
        // The function data hasn't changed - we just need the 'a lifetime from interns.
        let func = self.interns.get_function(func_id);
        let code = &func.code;

        // Push new frame (no cells needed for simple functions)
        self.frames.push(CallFrame::new_simple_function(
            code,
            self.stack.len(),
            namespace_idx,
            func_id,
            call_position,
        ));
        self.tracer
            .on_call(Some(self.interns.get_str(func.name.name_id)), self.frames.len());

        Ok(CallResult::FramePushed)
    }

    /// Executes `CallBuiltinFunction` opcode.
    ///
    /// Calls a builtin function directly without stack manipulation for the callable.
    /// This is an optimization that avoids constant pool lookup and stack manipulation.
    ///
    /// Intercepts certain builtins to dispatch dunders on instances:
    /// - `repr(x)` -> `x.__repr__()`
    /// - `hash(x)` -> `x.__hash__()`
    /// - `len(x)` -> `x.__len__()`
    /// - `abs(x)` -> `x.__abs__()`
    /// - `next(x)` -> `x.__next__()`
    pub(super) fn exec_call_builtin_function(
        &mut self,
        builtin_id: u8,
        arg_count: usize,
    ) -> Result<CallResult, RunError> {
        if let Some(builtin) = BuiltinsFunctions::from_repr(builtin_id) {
            // sum(generator[, start]) needs VM-driven generator iteration; handle it here.
            if matches!(builtin, BuiltinsFunctions::Sum) {
                let args = self.pop_n_args(arg_count);
                return self.call_sum_builtin(args);
            }
            // any/all on generators need VM-driven materialization first.
            if matches!(builtin, BuiltinsFunctions::Any) {
                let args = self.pop_n_args(arg_count);
                return self.call_any_builtin(args);
            }
            if matches!(builtin, BuiltinsFunctions::All) {
                let args = self.pop_n_args(arg_count);
                return self.call_all_builtin(args);
            }
            // min/max on generators need VM-driven materialization first.
            if arg_count == 1 && matches!(builtin, BuiltinsFunctions::Min) {
                let args = self.pop_n_args(arg_count);
                return self.call_min_builtin(args);
            }
            if arg_count == 1 && matches!(builtin, BuiltinsFunctions::Max) {
                let args = self.pop_n_args(arg_count);
                return self.call_max_builtin(args);
            }
            if matches!(builtin, BuiltinsFunctions::Enumerate) {
                let args = self.pop_n_args(arg_count);
                return self.call_enumerate_builtin(args);
            }
            if matches!(builtin, BuiltinsFunctions::Zip) {
                let args = self.pop_n_args(arg_count);
                return self.call_zip_builtin(args);
            }

            // super() needs VM context (frame stack) - handle it here instead of in builtins
            if matches!(builtin, BuiltinsFunctions::Super) {
                let args = self.pop_n_args(arg_count);
                let result = self.call_super(args)?;
                return Ok(CallResult::Push(result));
            }

            // getattr/setattr/hasattr need dynamic string -> StringId conversion via mutable interns
            if matches!(
                builtin,
                BuiltinsFunctions::Getattr | BuiltinsFunctions::Setattr | BuiltinsFunctions::Hasattr
            ) {
                let args = self.pop_n_args(arg_count);
                let result = match builtin {
                    BuiltinsFunctions::Getattr => self.builtin_getattr(args)?,
                    BuiltinsFunctions::Setattr => self.builtin_setattr(args)?,
                    BuiltinsFunctions::Hasattr => self.builtin_hasattr(args)?,
                    _ => unreachable!(),
                };
                return Ok(CallResult::Push(result));
            }

            // Check for instance dunder dispatch on single-arg builtins
            if arg_count == 1 {
                let arg = self.peek();
                // Check for generator with __next__
                if let Value::Ref(arg_id) = arg
                    && matches!(self.heap.get(*arg_id), HeapData::Generator(_))
                {
                    let arg_id = *arg_id;
                    if matches!(builtin, BuiltinsFunctions::Next) {
                        let arg_val = self.pop();
                        let result = self.generator_next(arg_id);
                        arg_val.drop_with_heap(self.heap);
                        return result;
                    }
                }
                if let Value::Ref(arg_id) = arg
                    && matches!(self.heap.get(*arg_id), HeapData::Instance(_))
                {
                    let arg_id = *arg_id;
                    let dunder = match builtin {
                        BuiltinsFunctions::Repr => Some(StaticStrings::DunderRepr),
                        BuiltinsFunctions::Hash => Some(StaticStrings::DunderHash),
                        BuiltinsFunctions::Len => Some(StaticStrings::DunderLen),
                        BuiltinsFunctions::Abs => Some(StaticStrings::DunderAbs),
                        BuiltinsFunctions::Next => Some(StaticStrings::DunderNext),
                        _ => None,
                    };

                    if let Some(dunder_name) = dunder {
                        let dunder_id = dunder_name.into();
                        if let Some(method) = self.lookup_type_dunder(arg_id, dunder_id) {
                            let arg_val = self.pop();
                            let result = self.call_dunder(arg_id, method, ArgValues::Empty)?;
                            arg_val.drop_with_heap(self.heap);
                            return Ok(result);
                        }
                        // For hash(): if no __hash__ but has __eq__, raise TypeError
                        if matches!(builtin, BuiltinsFunctions::Hash) {
                            let eq_id = StaticStrings::DunderEq.into();
                            if let Some(eq_method) = self.lookup_type_dunder(arg_id, eq_id) {
                                // __eq__ defined without __hash__ - unhashable
                                eq_method.drop_with_heap(self.heap);
                                let arg_val = self.pop();
                                // Get class name
                                let class_name = match self.heap.get(arg_id) {
                                    HeapData::Instance(inst) => match self.heap.get(inst.class_id()) {
                                        HeapData::ClassObject(cls) => cls.name(self.interns).to_string(),
                                        _ => "instance".to_string(),
                                    },
                                    _ => "instance".to_string(),
                                };
                                arg_val.drop_with_heap(self.heap);
                                return Err(ExcType::type_error(format!("unhashable type: '{class_name}'")));
                            }
                        }
                    }
                }
            }

            let args = self.pop_n_args(arg_count);
            let result = builtin.call(self.heap, args, self.interns, self.print_writer)?;
            Ok(CallResult::Push(result))
        } else {
            Err(RunError::internal("CallBuiltinFunction: invalid builtin_id"))
        }
    }

    /// Executes `CallBuiltinType` opcode.
    ///
    /// Calls a builtin type constructor directly without stack manipulation for the callable.
    /// This is an optimization for type constructors like `list()`, `int()`, `str()`.
    ///
    /// For instances, intercepts to call dunder methods:
    /// - `str(x)` -> `x.__str__()` or `x.__repr__()`
    /// - `repr(x)` -> `x.__repr__()`
    /// - `int(x)` -> `x.__int__()`
    /// - `float(x)` -> `x.__float__()`
    /// - `bool(x)` -> `x.__bool__()` or `x.__len__()`
    /// - `hash(x)` -> `x.__hash__()`
    /// - `len(x)` -> `x.__len__()`
    /// - `list(x)` -> `x.__iter__()` then repeatedly `__next__()` for instances with `__iter__`
    pub(super) fn exec_call_builtin_type(&mut self, type_id: u8, arg_count: usize) -> Result<CallResult, RunError> {
        if let Some(t) = Type::callable_from_u8(type_id) {
            // Check if the single argument is an instance that has a relevant dunder
            if arg_count == 1 {
                // Peek at the arg (TOS) without popping
                let arg_ref_id = match self.peek() {
                    Value::Ref(id) => Some(*id),
                    _ => None,
                };
                if t == Type::List
                    && let Some(arg_id) = arg_ref_id
                    && matches!(self.heap.get(arg_id), HeapData::Generator(_))
                {
                    let iterator = self.pop();
                    return self.list_build_from_iterator(iterator);
                }
                if t == Type::Tuple
                    && let Some(arg_id) = arg_ref_id
                    && matches!(self.heap.get(arg_id), HeapData::Generator(_))
                {
                    let iterator = self.pop();
                    return match self.list_build_from_iterator(iterator)? {
                        CallResult::Push(list_value) => {
                            let tuple_value = Type::Tuple.call(self.heap, ArgValues::One(list_value), self.interns)?;
                            Ok(CallResult::Push(tuple_value))
                        }
                        CallResult::FramePushed => {
                            self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                                kind: PendingBuiltinFromListKind::Tuple,
                            });
                            Ok(CallResult::FramePushed)
                        }
                        other => Ok(other),
                    };
                }
                if t == Type::List
                    && let Some(arg_id) = arg_ref_id
                    && matches!(self.heap.get(arg_id), HeapData::ClassObject(_))
                {
                    let dunder_id: StringId = StaticStrings::DunderIter.into();
                    if let Some(method) = self.lookup_metaclass_dunder(arg_id, dunder_id) {
                        let arg_val = self.pop();
                        match self.call_class_dunder(arg_id, method, ArgValues::Empty)? {
                            CallResult::Push(iterator) => {
                                arg_val.drop_with_heap(self.heap);
                                return self.list_build_from_iterator(iterator);
                            }
                            CallResult::FramePushed => {
                                arg_val.drop_with_heap(self.heap);
                                self.pending_list_iter_return = true;
                                return Ok(CallResult::FramePushed);
                            }
                            other => {
                                arg_val.drop_with_heap(self.heap);
                                return Ok(other);
                            }
                        }
                    }
                }
                if let Some(arg_id) = arg_ref_id
                    && matches!(self.heap.get(arg_id), HeapData::Instance(_))
                {
                    // Check for type-specific dunders
                    let dunder = match t {
                        Type::Str => Some((StaticStrings::DunderStr, Some(StaticStrings::DunderRepr))),
                        Type::Int => Some((StaticStrings::DunderInt, None)),
                        Type::Float => Some((StaticStrings::DunderFloat, None)),
                        Type::Bool => Some((StaticStrings::DunderBool, Some(StaticStrings::DunderLen))),
                        _ => None,
                    };

                    if let Some((primary_dunder, fallback_dunder)) = dunder {
                        let primary_id = primary_dunder.into();
                        if let Some(method) = self.lookup_type_dunder(arg_id, primary_id) {
                            // Pop the arg and call the dunder
                            let arg_val = self.pop();
                            let result = self.call_dunder(arg_id, method, ArgValues::Empty)?;
                            arg_val.drop_with_heap(self.heap);
                            return Ok(result);
                        }
                        // Try fallback dunder if primary not found
                        if let Some(fallback) = fallback_dunder {
                            let fallback_id = fallback.into();
                            if let Some(method) = self.lookup_type_dunder(arg_id, fallback_id) {
                                let arg_val = self.pop();
                                let result = self.call_dunder(arg_id, method, ArgValues::Empty)?;
                                arg_val.drop_with_heap(self.heap);
                                return Ok(result);
                            }
                        }
                    }

                    // Special handling for list(instance_with___iter__)
                    // We need to call __iter__() then repeatedly __next__() until StopIteration
                    if t == Type::List {
                        let dunder_id: StringId = StaticStrings::DunderIter.into();
                        if let Some(method) = self.lookup_type_dunder(arg_id, dunder_id) {
                            let arg_val = self.pop();
                            // Call __iter__() to get the iterator
                            match self.call_dunder(arg_id, method, ArgValues::Empty)? {
                                CallResult::Push(iterator) => {
                                    // __iter__ returned synchronously - start collecting items
                                    arg_val.drop_with_heap(self.heap);
                                    return self.list_build_from_iterator(iterator);
                                }
                                CallResult::FramePushed => {
                                    // __iter__ pushed a frame - store state for continuation
                                    arg_val.drop_with_heap(self.heap);
                                    // Mark that we're waiting for __iter__ to return
                                    self.pending_list_iter_return = true;
                                    return Ok(CallResult::FramePushed);
                                }
                                other => {
                                    arg_val.drop_with_heap(self.heap);
                                    return Ok(other);
                                }
                            }
                        }
                    }
                }
            }

            let args = self.pop_n_args(arg_count);
            let result = t.call(self.heap, args, self.interns)?;
            Ok(CallResult::Push(result))
        } else {
            Err(RunError::internal("CallBuiltinType: invalid type_id"))
        }
    }

    /// Builds a list from an iterator by repeatedly calling `__next__()`.
    ///
    /// This handles the case where `list(instance_with___iter__)` is called, and
    /// also handles generator iterators directly via `generator_next()`.
    /// If `__next__()`/generator resume pushes frames, stores state in
    /// `pending_list_build` and returns `FramePushed`.
    pub(super) fn list_build_from_iterator(&mut self, iterator: Value) -> Result<CallResult, RunError> {
        if let Value::Ref(iter_id) = &iterator {
            // Generators are VM-driven iterators; resume with generator_next().
            if matches!(self.heap.get(*iter_id), HeapData::Generator(_)) {
                match self.generator_next(*iter_id) {
                    Ok(CallResult::FramePushed) => {
                        self.pending_list_build = Some(super::PendingListBuild {
                            iterator,
                            items: Vec::new(),
                        });
                        self.pending_list_build_return = true;
                        return Ok(CallResult::FramePushed);
                    }
                    Err(e) if e.is_stop_iteration() => {
                        iterator.drop_with_heap(self.heap);
                        let list_id = self.heap.allocate(HeapData::List(List::new(Vec::new())))?;
                        return Ok(CallResult::Push(Value::Ref(list_id)));
                    }
                    Err(e) => {
                        iterator.drop_with_heap(self.heap);
                        return Err(e);
                    }
                    Ok(other) => {
                        iterator.drop_with_heap(self.heap);
                        return Ok(other);
                    }
                }
            }

            // Check if the iterator is an instance with __next__
            if matches!(self.heap.get(*iter_id), HeapData::Instance(_)) {
                let dunder_id: StringId = StaticStrings::DunderNext.into();
                if let Some(method) = self.lookup_type_dunder(*iter_id, dunder_id) {
                    // Call __next__() on the iterator
                    match self.call_dunder(*iter_id, method, ArgValues::Empty)? {
                        CallResult::Push(item) => {
                            // __next__ returned synchronously - add item and continue
                            let items = vec![item];
                            return self.list_build_continue(iterator, items);
                        }
                        CallResult::FramePushed => {
                            // __next__ pushed a frame - store pending state
                            self.pending_list_build = Some(super::PendingListBuild {
                                iterator,
                                items: Vec::new(),
                            });
                            self.pending_list_build_return = true;
                            return Ok(CallResult::FramePushed);
                        }
                        other => {
                            iterator.drop_with_heap(self.heap);
                            return Ok(other);
                        }
                    }
                }
            }
        }

        // Fast path: use OuroIter to collect items from built-in iterators
        // Note: OuroIter::new takes ownership of value, so we can't use iterator after
        match OuroIter::new(iterator, self.heap, self.interns) {
            Ok(mut iter) => {
                let items: Vec<Value> = iter.collect(self.heap, self.interns)?;
                iter.drop_with_heap(self.heap);
                let list_id = self.heap.allocate(HeapData::List(List::new(items)))?;
                Ok(CallResult::Push(Value::Ref(list_id)))
            }
            Err(e) => Err(e),
        }
    }

    /// Continues building a list from an iterator after a successful `__next__()` call.
    ///
    /// Repeatedly calls `__next__()` until StopIteration, collecting items into the list.
    /// Supports both instance iterators and generator iterators.
    fn list_build_continue(&mut self, iterator: Value, items: Vec<Value>) -> Result<CallResult, RunError> {
        // Guards guarantee both iterator and collected items are dropped on every
        // early-return path (`?`, errors, unexpected call results).
        let this = self;
        let mut items_guard = HeapGuard::new(items, this);
        let (items, this) = items_guard.as_parts_mut();
        let mut iterator_guard = HeapGuard::new(iterator, this);
        let (iterator, this) = iterator_guard.as_parts_mut();

        let iter_id = if let Value::Ref(id) = iterator {
            *id
        } else {
            let type_name = iterator.py_type(this.heap);
            return Err(ExcType::type_error_not_iterable(type_name));
        };

        let dunder_id: StringId = StaticStrings::DunderNext.into();

        loop {
            if matches!(this.heap.get(iter_id), HeapData::Generator(_)) {
                match this.generator_next(iter_id) {
                    Ok(CallResult::FramePushed) => {
                        let (iterator, _this) = iterator_guard.into_parts();
                        let (items, this) = items_guard.into_parts();
                        this.pending_list_build = Some(super::PendingListBuild { iterator, items });
                        this.pending_list_build_return = true;
                        return Ok(CallResult::FramePushed);
                    }
                    Err(e) if e.is_stop_iteration() => {
                        let list_items = std::mem::take(items);
                        let list_id = this.heap.allocate(HeapData::List(List::new(list_items)))?;
                        return Ok(CallResult::Push(Value::Ref(list_id)));
                    }
                    Err(e) => return Err(e),
                    Ok(other) => return Ok(other),
                }
            }

            if let Some(method) = this.lookup_type_dunder(iter_id, dunder_id) {
                match this.call_dunder(iter_id, method, ArgValues::Empty)? {
                    CallResult::Push(item) => {
                        items.push(item);
                    }
                    CallResult::FramePushed => {
                        let (iterator, _this) = iterator_guard.into_parts();
                        let (items, this) = items_guard.into_parts();
                        this.pending_list_build = Some(super::PendingListBuild { iterator, items });
                        this.pending_list_build_return = true;
                        return Ok(CallResult::FramePushed);
                    }
                    other => return Ok(other),
                }
            } else {
                let type_name = iterator.py_type(this.heap);
                return Err(ExcType::type_error_not_iterable(type_name));
            }
        }
    }

    /// Handles the result of a `__next__()` call during list construction.
    ///
    /// Called from the ReturnValue handler when `pending_list_build_return` is true.
    /// On normal return: append item and call next `__next__()`.
    /// On StopIteration: finish list construction and push the list.
    pub(super) fn handle_list_build_return(&mut self, item: Value) -> Result<CallResult, RunError> {
        self.pending_list_build_return = false;

        let Some(pending) = self.pending_list_build.take() else {
            return Err(RunError::internal("handle_list_build_return: no pending list build"));
        };

        let super::PendingListBuild { iterator, mut items } = pending;
        items.push(item);
        self.list_build_continue(iterator, items)
    }

    /// Handles StopIteration during list construction from an iterator.
    ///
    /// Called from the exception handler when `pending_list_build_return` is true
    /// and the exception is StopIteration.
    pub(super) fn handle_list_build_stop_iteration(&mut self) -> Result<CallResult, RunError> {
        self.pending_list_build_return = false;

        let Some(pending) = self.pending_list_build.take() else {
            return Err(RunError::internal(
                "handle_list_build_stop_iteration: no pending list build",
            ));
        };

        let super::PendingListBuild { iterator, items } = pending;
        iterator.drop_with_heap(self.heap);

        // Create the list from collected items
        let list_id = self.heap.allocate(HeapData::List(List::new(items)))?;
        Ok(CallResult::Push(Value::Ref(list_id)))
    }

    // ---- AttrCallResult dispatch ----

    /// Handles an `AttrCallResult` that may require VM-level processing.
    ///
    /// Most variants are handled by the generic `Into<CallResult>` conversion,
    /// but `ReduceCall`, `MapCall`, and `FilterCall` require VM access to call
    /// user-defined functions.
    fn handle_attr_call_result(&mut self, result: AttrCallResult) -> Result<CallResult, RunError> {
        match result {
            AttrCallResult::ReduceCall(function, accumulator, remaining_items) => {
                if remaining_items.is_empty() {
                    function.drop_with_heap(self.heap);
                    Ok(CallResult::Push(accumulator))
                } else {
                    self.reduce_continue(function, accumulator, remaining_items)
                }
            }
            AttrCallResult::MapCall(function, iterators) => {
                if iterators.is_empty() || iterators[0].is_empty() {
                    // Empty result - return empty list
                    function.drop_with_heap(self.heap);
                    for iter in iterators {
                        for item in iter {
                            item.drop_with_heap(self.heap);
                        }
                    }
                    let list_id = self.heap.allocate(HeapData::List(List::new(Vec::new())))?;
                    Ok(CallResult::Push(Value::Ref(list_id)))
                } else {
                    self.map_continue(function, iterators, Vec::new(), 0)
                }
            }
            AttrCallResult::FilterCall(function, items) => {
                if items.is_empty() {
                    // Empty result - return empty list
                    function.drop_with_heap(self.heap);
                    let list_id = self.heap.allocate(HeapData::List(List::new(Vec::new())))?;
                    Ok(CallResult::Push(Value::Ref(list_id)))
                } else {
                    self.filter_continue(function, items, Vec::new(), 0)
                }
            }
            AttrCallResult::CallFunction(callable, args) => self.call_function(callable, args),
            other => Ok(other.into()),
        }
    }

    // ---- functools.reduce() VM-level implementation ----

    /// Continues a reduce operation, calling the function for each remaining item.
    ///
    /// If the function call completes synchronously (`CallResult::Push`), the result
    /// becomes the new accumulator and we continue with the next item. If the function
    /// pushes a frame (`CallResult::FramePushed`), we stash the state in `pending_reduce`
    /// and return `FramePushed` to let the VM execute the frame.
    fn reduce_continue(
        &mut self,
        function: Value,
        mut accumulator: Value,
        mut remaining_items: Vec<Value>,
    ) -> Result<CallResult, RunError> {
        while !remaining_items.is_empty() {
            let item = remaining_items.remove(0);

            // Build args: (accumulator, item)
            let call_args = ArgValues::Two(accumulator, item);

            // Clone the function for this call (function is reused across iterations)
            let func_clone = function.clone_with_heap(self.heap);

            match self.call_function(func_clone, call_args)? {
                CallResult::Push(result) => {
                    // Function completed synchronously - result is the new accumulator
                    accumulator = result;
                }
                CallResult::FramePushed => {
                    // Function pushed a frame (user-defined function/lambda/closure).
                    // Stash state and let the VM execute the frame.
                    self.pending_reduce = Some(PendingReduce {
                        function,
                        // accumulator was consumed by call_args; new value comes from frame return
                        accumulator: Value::None, // placeholder, replaced by return value
                        remaining_items,
                    });
                    self.pending_reduce_return = true;
                    return Ok(CallResult::FramePushed);
                }
                other => {
                    // External calls etc. not supported in reduce
                    function.drop_with_heap(self.heap);
                    for item in remaining_items {
                        item.drop_with_heap(self.heap);
                    }
                    return Ok(other);
                }
            }
        }

        // All items processed - clean up and return the final accumulator
        function.drop_with_heap(self.heap);
        Ok(CallResult::Push(accumulator))
    }

    /// Handles the return value from a user-defined function during `functools.reduce()`.
    ///
    /// Called from the `ReturnValue` handler when `pending_reduce_return` is true.
    /// The return value becomes the new accumulator, and we continue processing
    /// remaining items.
    pub(super) fn handle_reduce_return(&mut self, value: Value) -> Result<CallResult, RunError> {
        let Some(pending) = self.pending_reduce.take() else {
            return Err(RunError::internal("handle_reduce_return: no pending reduce state"));
        };

        let PendingReduce {
            function,
            accumulator: placeholder,
            remaining_items,
        } = pending;

        // Drop the placeholder accumulator (it was Value::None)
        placeholder.drop_with_heap(self.heap);

        // The return value is the new accumulator
        if remaining_items.is_empty() {
            // All done - return the final result
            function.drop_with_heap(self.heap);
            Ok(CallResult::Push(value))
        } else {
            // More items to process
            self.reduce_continue(function, value, remaining_items)
        }
    }

    // ---- map() VM-level implementation ----

    /// Continues a map operation, calling the function for each set of iterator items.
    ///
    /// If the function call completes synchronously (`CallResult::Push`), the result
    /// is added to results and we continue with the next index. If the function pushes
    /// a frame (`CallResult::FramePushed`), we stash the state in `pending_map` and
    /// return `FramePushed` to let the VM execute the frame.
    fn map_continue(
        &mut self,
        function: Value,
        mut iterators: Vec<Vec<Value>>,
        mut results: Vec<Value>,
        current_idx: usize,
    ) -> Result<CallResult, RunError> {
        let num_iters = iterators.len();

        while current_idx < iterators[0].len() {
            // Build args from each iterator at current_idx
            let mut call_args = Vec::with_capacity(num_iters);
            for iter in &iterators {
                call_args.push(iter[current_idx].clone_with_heap(self.heap));
            }

            // Build ArgValues from call_args
            let arg_values = match call_args.len() {
                0 => ArgValues::Empty,
                1 => ArgValues::One(call_args.into_iter().next().unwrap()),
                2 => {
                    let mut iter = call_args.into_iter();
                    ArgValues::Two(iter.next().unwrap(), iter.next().unwrap())
                }
                _ => ArgValues::ArgsKargs {
                    args: call_args,
                    kwargs: crate::args::KwargsValues::Empty,
                },
            };

            // Clone the function for this call (function is reused across iterations)
            let func_clone = function.clone_with_heap(self.heap);

            match self.call_function(func_clone, arg_values)? {
                CallResult::Push(result) => {
                    // Function completed synchronously - add to results
                    results.push(result);
                }
                CallResult::FramePushed => {
                    // Function pushed a frame (user-defined function/lambda/closure).
                    // Stash state and let the VM execute the frame.
                    self.pending_map = Some(super::PendingMap {
                        function,
                        iterators,
                        results,
                        current_idx: current_idx + 1,
                    });
                    self.pending_map_return = true;
                    return Ok(CallResult::FramePushed);
                }
                other => {
                    // External calls etc. not supported in map
                    function.drop_with_heap(self.heap);
                    for iter in iterators {
                        for item in iter {
                            item.drop_with_heap(self.heap);
                        }
                    }
                    for result in results {
                        result.drop_with_heap(self.heap);
                    }
                    return Ok(other);
                }
            }
        }

        // All items processed - create the result list
        function.drop_with_heap(self.heap);
        for iter in iterators {
            for item in iter {
                item.drop_with_heap(self.heap);
            }
        }
        let list_id = self.heap.allocate(HeapData::List(List::new(results)))?;
        Ok(CallResult::Push(Value::Ref(list_id)))
    }

    /// Handles the return value from a user-defined function during `map()`.
    ///
    /// Called from the `ReturnValue` handler when `pending_map_return` is true.
    /// The return value is added to results, and we continue processing remaining items.
    pub(super) fn handle_map_return(&mut self, value: Value) -> Result<CallResult, RunError> {
        let Some(pending) = self.pending_map.take() else {
            return Err(RunError::internal("handle_map_return: no pending map state"));
        };

        let super::PendingMap {
            function,
            iterators,
            mut results,
            current_idx,
        } = pending;

        // Add the return value to results
        results.push(value);

        // Continue processing remaining items
        self.map_continue(function, iterators, results, current_idx)
    }

    // ---- filter() VM-level implementation ----

    /// Continues a filter operation, calling the function for each remaining item.
    ///
    /// If the function call completes synchronously (`CallResult::Push`), we check
    /// if the result is truthy and add the original item to results if so. If the
    /// function pushes a frame (`CallResult::FramePushed`), we stash the state in
    /// `pending_filter` and return `FramePushed` to let the VM execute the frame.
    fn filter_continue(
        &mut self,
        function: Value,
        mut items: Vec<Value>,
        mut results: Vec<Value>,
        current_idx: usize,
    ) -> Result<CallResult, RunError> {
        let mut idx = current_idx;

        while idx < items.len() {
            let item = items[idx].clone_with_heap(self.heap);

            // Clone the function for this call (function is reused across iterations)
            let func_clone = function.clone_with_heap(self.heap);

            match self.call_function(func_clone, ArgValues::One(item))? {
                CallResult::Push(keep_result) => {
                    // Function completed synchronously - check if truthy
                    if keep_result.py_bool(self.heap, self.interns) {
                        results.push(items[idx].clone_with_heap(self.heap));
                    }
                    keep_result.drop_with_heap(self.heap);
                    idx += 1;
                }
                CallResult::FramePushed => {
                    // Function pushed a frame (user-defined function/lambda/closure).
                    // Stash state and let the VM execute the frame.
                    self.pending_filter = Some(super::PendingFilter {
                        function,
                        items,
                        results,
                        current_idx: idx,
                    });
                    self.pending_filter_return = true;
                    return Ok(CallResult::FramePushed);
                }
                other => {
                    // External calls etc. not supported in filter
                    function.drop_with_heap(self.heap);
                    for item in items {
                        item.drop_with_heap(self.heap);
                    }
                    for result in results {
                        result.drop_with_heap(self.heap);
                    }
                    return Ok(other);
                }
            }
        }

        // All items processed - create the result list
        function.drop_with_heap(self.heap);
        for item in items {
            item.drop_with_heap(self.heap);
        }
        let list_id = self.heap.allocate(HeapData::List(List::new(results)))?;
        Ok(CallResult::Push(Value::Ref(list_id)))
    }

    /// Handles the return value from a user-defined function during `filter()`.
    ///
    /// Called from the `ReturnValue` handler when `pending_filter_return` is true.
    /// The return value is checked for truthiness, and if true, the corresponding
    /// item is added to results. We then continue processing remaining items.
    pub(super) fn handle_filter_return(&mut self, value: Value) -> Result<CallResult, RunError> {
        let Some(pending) = self.pending_filter.take() else {
            return Err(RunError::internal("handle_filter_return: no pending filter state"));
        };

        let super::PendingFilter {
            function,
            items,
            mut results,
            current_idx,
        } = pending;

        // Check if the return value is truthy
        if value.py_bool(self.heap, self.interns) {
            results.push(items[current_idx].clone_with_heap(self.heap));
        }
        value.drop_with_heap(self.heap);

        // Continue processing remaining items
        self.filter_continue(function, items, results, current_idx + 1)
    }

    /// Executes `CallFunctionKw` opcode.
    ///
    /// Pops the callable, positional args, and keyword args from the stack,
    /// builds the appropriate `ArgValues`, and calls the function.
    pub(super) fn exec_call_function_kw(
        &mut self,
        pos_count: usize,
        kwname_ids: Vec<StringId>,
    ) -> Result<CallResult, RunError> {
        let kw_count = kwname_ids.len();

        // Pop keyword values (TOS is last kwarg value)
        let kw_values = self.pop_n(kw_count);

        // Pop positional arguments
        let pos_args = self.pop_n(pos_count);

        // Pop the callable
        let callable = self.pop();

        // Build kwargs as Vec<(StringId, Value)>
        let kwargs_inline: Vec<(StringId, Value)> = kwname_ids.into_iter().zip(kw_values).collect();

        // Build ArgValues with both positional and keyword args
        let args = if pos_args.is_empty() && kwargs_inline.is_empty() {
            ArgValues::Empty
        } else if pos_args.is_empty() {
            ArgValues::Kwargs(KwargsValues::Inline(kwargs_inline))
        } else {
            ArgValues::ArgsKargs {
                args: pos_args,
                kwargs: KwargsValues::Inline(kwargs_inline),
            }
        };

        self.call_function(callable, args)
    }

    /// Executes `CallAttr` opcode.
    ///
    /// Pops the object and arguments from the stack, calls the attribute,
    /// and returns a `CallResult` which may indicate an OS or external call.
    pub(super) fn exec_call_attr(&mut self, name_id: StringId, arg_count: usize) -> Result<CallResult, RunError> {
        let args = self.pop_n_args(arg_count);
        let obj = self.pop();
        self.call_attr(obj, name_id, args)
    }

    /// Executes `CallAttrKw` opcode.
    ///
    /// Pops the object, positional args, and keyword args from the stack,
    /// builds the appropriate `ArgValues`, and calls the attribute.
    /// Returns a `CallResult` which may indicate an OS or external call.
    pub(super) fn exec_call_attr_kw(
        &mut self,
        name_id: StringId,
        pos_count: usize,
        kwname_ids: Vec<StringId>,
    ) -> Result<CallResult, RunError> {
        let kw_count = kwname_ids.len();

        // Pop keyword values (TOS is last kwarg value)
        let kw_values = self.pop_n(kw_count);

        // Pop positional arguments
        let pos_args = self.pop_n(pos_count);

        // Pop the object
        let obj = self.pop();

        // Build kwargs as Vec<(StringId, Value)>
        let kwargs_inline: Vec<(StringId, Value)> = kwname_ids.into_iter().zip(kw_values).collect();

        // Build ArgValues with both positional and keyword args
        let args = if pos_args.is_empty() && kwargs_inline.is_empty() {
            ArgValues::Empty
        } else if pos_args.is_empty() {
            ArgValues::Kwargs(KwargsValues::Inline(kwargs_inline))
        } else {
            ArgValues::ArgsKargs {
                args: pos_args,
                kwargs: KwargsValues::Inline(kwargs_inline),
            }
        };

        self.call_attr(obj, name_id, args)
    }

    /// Executes `CallFunctionExtended` opcode.
    ///
    /// Handles calls with `*args` and/or `**kwargs` unpacking.
    pub(super) fn exec_call_function_extended(&mut self, has_kwargs: bool) -> Result<CallResult, RunError> {
        // Pop kwargs dict if present
        let kwargs = if has_kwargs { Some(self.pop()) } else { None };

        // Pop args tuple
        let args_tuple = self.pop();

        // Pop callable
        let callable = self.pop();

        // Unpack and call
        self.call_function_extended(callable, args_tuple, kwargs)
    }

    /// Executes `CallAttrExtended` opcode.
    ///
    /// Handles method calls with `*args` and/or `**kwargs` unpacking.
    pub(super) fn exec_call_attr_extended(
        &mut self,
        name_id: StringId,
        has_kwargs: bool,
    ) -> Result<CallResult, RunError> {
        // Pop kwargs dict if present
        let kwargs = if has_kwargs { Some(self.pop()) } else { None };

        // Pop args tuple
        let args_tuple = self.pop();

        // Pop the receiver object
        let obj = self.pop();

        // Unpack and call
        self.call_attr_extended(obj, name_id, args_tuple, kwargs)
    }

    // ========================================================================
    // Internal Call Helpers
    // ========================================================================

    /// Pops n arguments from the stack and wraps them in `ArgValues`.
    fn pop_n_args(&mut self, n: usize) -> ArgValues {
        match n {
            0 => ArgValues::Empty,
            1 => ArgValues::One(self.pop()),
            2 => {
                let b = self.pop();
                let a = self.pop();
                ArgValues::Two(a, b)
            }
            _ => ArgValues::ArgsKargs {
                args: self.pop_n(n),
                kwargs: KwargsValues::Empty,
            },
        }
    }

    /// Calls an attribute on an object.
    ///
    /// For heap-allocated objects (`Value::Ref`), dispatches to the type's
    /// `py_call_attr_raw` implementation via `heap.call_attr_raw()`, which may return
    /// `AttrCallResult::OsCall` or `AttrCallResult::ExternalCall` for operations that
    /// require host involvement.
    ///
    /// For interned strings (`Value::InternString`), uses the unified `call_str_method`.
    /// For interned bytes (`Value::InternBytes`), uses the unified `call_bytes_method`.
    ///
    /// Special handling: `list.sort(key=...)` is intercepted here to allow key
    /// callables that may push VM frames (e.g. user lambdas).
    pub(super) fn call_attr(&mut self, obj: Value, name_id: StringId, args: ArgValues) -> Result<CallResult, RunError> {
        let attr = EitherStr::Interned(name_id);

        match obj {
            Value::Ref(heap_id) => {
                // ExitStack-like shims should behave like context managers and
                // return themselves from __enter__.
                if name_id == StaticStrings::DunderEnter
                    && matches!(
                        self.heap.get(heap_id),
                        HeapData::StdlibObject(crate::types::StdlibObject::ExitStack(_))
                    )
                {
                    args.check_zero_args("__enter__", self.heap)?;
                    self.heap.inc_ref(heap_id);
                    obj.drop_with_heap(self.heap);
                    return Ok(CallResult::Push(Value::Ref(heap_id)));
                }
                // Check for list.sort - needs special handling for key functions
                if name_id == StaticStrings::Sort && matches!(self.heap.get(heap_id), HeapData::List(_)) {
                    let result = self.call_list_sort(heap_id, args);
                    obj.drop_with_heap(self.heap);
                    return result;
                }
                // Instance method calls need special handling: look up the method,
                // then call it with `self` prepended.
                // Inc_ref before dropping obj so the instance stays alive during lookup.
                // call_instance_method will inc_ref again for the self_arg if needed.
                // We dec_ref after the call completes to balance this temporary hold.
                if matches!(self.heap.get(heap_id), HeapData::Instance(_)) {
                    self.heap.inc_ref(heap_id);
                    obj.drop_with_heap(self.heap);
                    let result = self.call_instance_method(heap_id, name_id, args);
                    self.heap.dec_ref(heap_id);
                    return result;
                }
                // SuperProxy method calls: look up via MRO, call with instance as self
                if matches!(self.heap.get(heap_id), HeapData::SuperProxy(_)) {
                    // Extract info before dropping (SuperProxy may have refcount 1)
                    let (instance_id, current_class_id) = match self.heap.get(heap_id) {
                        HeapData::SuperProxy(sp) => (sp.instance_id(), sp.current_class_id()),
                        _ => unreachable!(),
                    };
                    obj.drop_with_heap(self.heap);
                    return self.call_super_method_with_ids(instance_id, current_class_id, name_id, args);
                }
                // ClassObject method calls: look up in namespace, unwrap descriptors,
                // handle @staticmethod (no self/cls), @classmethod (prepend cls), regular calls.
                if matches!(self.heap.get(heap_id), HeapData::ClassObject(_)) {
                    obj.drop_with_heap(self.heap);
                    return self.call_class_method(heap_id, name_id, args);
                }
                // singledispatch register/dispatch helper methods are handled as native
                // attributes on the dispatcher objects.
                if matches!(
                    self.heap.get(heap_id),
                    HeapData::SingleDispatch(_) | HeapData::SingleDispatchMethod(_)
                ) {
                    obj.drop_with_heap(self.heap);
                    return self.call_singledispatch_attr(heap_id, name_id, args);
                }
                // Generator method calls: __next__ and __iter__ need special handling
                if matches!(self.heap.get(heap_id), HeapData::Generator(_)) {
                    let dunder_next: StringId = StaticStrings::DunderNext.into();
                    let dunder_iter: StringId = StaticStrings::DunderIter.into();
                    let send: StringId = StaticStrings::Send.into();
                    let throw: StringId = StaticStrings::Throw.into();
                    let close: StringId = StaticStrings::Close.into();
                    if name_id == dunder_next {
                        args.check_zero_args("__next__", self.heap)?;
                        let result = self.generator_next(heap_id);
                        obj.drop_with_heap(self.heap);
                        return result;
                    }
                    if name_id == dunder_iter {
                        args.check_zero_args("__iter__", self.heap)?;
                        // __iter__ returns self
                        self.heap.inc_ref(heap_id);
                        obj.drop_with_heap(self.heap);
                        return Ok(CallResult::Push(Value::Ref(heap_id)));
                    }
                    if name_id == send {
                        let send_value = args.get_one_arg("send", self.heap)?;
                        let result = self.generator_send(heap_id, send_value);
                        obj.drop_with_heap(self.heap);
                        return result;
                    }
                    if name_id == throw {
                        let exc_value = args.get_one_arg("throw", self.heap)?;
                        let result = self.generator_throw(heap_id, exc_value);
                        obj.drop_with_heap(self.heap);
                        return result;
                    }
                    if name_id == close {
                        args.check_zero_args("close", self.heap)?;
                        let result = self.generator_close(heap_id);
                        obj.drop_with_heap(self.heap);
                        return result;
                    }
                }
                // Call the method on the heap object using call_attr_raw to support OS/external calls
                let result = self.heap.call_attr_raw(heap_id, &attr, args, self.interns);
                obj.drop_with_heap(self.heap);
                // Convert AttrCallResult to CallResult (handles ReduceCall via VM)
                self.handle_attr_call_result(result?)
            }
            Value::InternString(string_id) => {
                // Call string method on interned string literal using the unified dispatcher
                let s = self.interns.get_str(string_id);
                if name_id == StaticStrings::Join {
                    let iterable = args.get_one_arg("str.join", self.heap)?;
                    if let Value::Ref(iter_id) = &iterable
                        && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
                    {
                        match self.list_build_from_iterator(iterable)? {
                            CallResult::Push(list_value) => {
                                call_str_method(s, name_id, ArgValues::One(list_value), self.heap, self.interns)
                                    .map(CallResult::Push)
                            }
                            CallResult::FramePushed => {
                                self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                                    kind: PendingBuiltinFromListKind::Join(string_id),
                                });
                                Ok(CallResult::FramePushed)
                            }
                            other => Ok(other),
                        }
                    } else {
                        call_str_method(s, name_id, ArgValues::One(iterable), self.heap, self.interns)
                            .map(CallResult::Push)
                    }
                } else {
                    call_str_method(s, name_id, args, self.heap, self.interns).map(CallResult::Push)
                }
            }
            Value::InternBytes(bytes_id) => {
                // Call bytes method on interned bytes literal using the unified dispatcher
                let b = self.interns.get_bytes(bytes_id);
                call_bytes_method(b, name_id, args, self.heap, self.interns).map(CallResult::Push)
            }
            Value::Builtin(Builtins::Type(t)) => {
                // Handle classmethods on type objects like dict.fromkeys()
                call_type_method(t, name_id, args, self.heap, self.interns).map(CallResult::Push)
            }
            _ => {
                // Non-heap values without method support
                let type_name = obj.py_type(self.heap);
                args.drop_with_heap(self.heap);
                Err(ExcType::attribute_error(type_name, self.interns.get_str(name_id)))
            }
        }
    }

    /// Executes `list.sort()` with VM-aware `key=` support.
    ///
    /// Unlike the non-VM list sorter used by `sorted()`, this path can execute
    /// user-defined key callables that push frames (e.g. lambdas/closures). Key
    /// computation is resumable via `pending_list_sort` when a key call returns
    /// `FramePushed`.
    fn call_list_sort(&mut self, list_id: HeapId, args: ArgValues) -> Result<CallResult, RunError> {
        let (key_arg, reverse_arg) =
            args.extract_two_kwargs_only("list.sort", "key", "reverse", self.heap, self.interns)?;

        let reverse = if let Some(value) = reverse_arg {
            let reverse = value.py_bool(self.heap, self.interns);
            value.drop_with_heap(self.heap);
            reverse
        } else {
            false
        };

        let key_fn = match key_arg {
            Some(value) if matches!(value, Value::None) => {
                value.drop_with_heap(self.heap);
                None
            }
            other => other,
        };

        let items = {
            let HeapData::List(list) = self.heap.get_mut(list_id) else {
                if let Some(key) = key_fn {
                    key.drop_with_heap(self.heap);
                }
                return Err(RunError::internal("expected list in call_list_sort"));
            };
            list.as_vec_mut().drain(..).collect::<Vec<_>>()
        };

        if let Some(key_fn) = key_fn {
            let pending = PendingListSort {
                list_id,
                holds_list_ref: false,
                key_fn,
                reverse,
                items,
                key_values: Vec::new(),
                next_index: 0,
            };
            self.list_sort_compute_keys(pending)
        } else {
            self.finish_list_sort(list_id, items, None, reverse)?;
            Ok(CallResult::Push(Value::None))
        }
    }

    /// Continues key computation for an in-flight `list.sort(key=...)`.
    ///
    /// This calls the key function for each item in sequence. If a key call pushes
    /// a frame, we stash the remaining state and resume from `handle_list_sort_return`.
    fn list_sort_compute_keys(&mut self, mut pending: PendingListSort) -> Result<CallResult, RunError> {
        while pending.next_index < pending.items.len() {
            let item = pending.items[pending.next_index].clone_with_heap(self.heap);
            let key_fn = pending.key_fn.clone_with_heap(self.heap);
            let call_args = ArgValues::One(item);
            match self.call_function(key_fn, call_args)? {
                CallResult::Push(key_value) => {
                    pending.key_values.push(key_value);
                    pending.next_index += 1;
                }
                CallResult::FramePushed => {
                    pending.next_index += 1;
                    if !pending.holds_list_ref {
                        self.heap.inc_ref(pending.list_id);
                        pending.holds_list_ref = true;
                    }
                    self.pending_list_sort = Some(pending);
                    self.pending_list_sort_return = true;
                    return Ok(CallResult::FramePushed);
                }
                CallResult::External(_, ext_args) => {
                    ext_args.drop_with_heap(self.heap);
                    pending.key_fn.drop_with_heap(self.heap);
                    for value in pending.key_values {
                        value.drop_with_heap(self.heap);
                    }
                    self.restore_list_items(pending.list_id, pending.items)?;
                    if pending.holds_list_ref {
                        self.heap.dec_ref(pending.list_id);
                    }
                    return Err(ExcType::type_error(
                        "list.sort() key function cannot be an external callable",
                    ));
                }
                CallResult::OsCall(_, os_args) => {
                    os_args.drop_with_heap(self.heap);
                    pending.key_fn.drop_with_heap(self.heap);
                    for value in pending.key_values {
                        value.drop_with_heap(self.heap);
                    }
                    self.restore_list_items(pending.list_id, pending.items)?;
                    if pending.holds_list_ref {
                        self.heap.dec_ref(pending.list_id);
                    }
                    return Err(ExcType::type_error(
                        "list.sort() key function cannot perform os operations",
                    ));
                }
            }
        }

        pending.key_fn.drop_with_heap(self.heap);
        let sort_result = self.finish_list_sort(
            pending.list_id,
            pending.items,
            Some(pending.key_values),
            pending.reverse,
        );
        if pending.holds_list_ref {
            self.heap.dec_ref(pending.list_id);
        }
        sort_result?;
        Ok(CallResult::Push(Value::None))
    }

    /// Resumes `list.sort(key=...)` after a key callable frame returns.
    pub(super) fn handle_list_sort_return(&mut self, value: Value) -> Result<CallResult, RunError> {
        let Some(mut pending) = self.pending_list_sort.take() else {
            return Err(RunError::internal(
                "handle_list_sort_return: no pending list sort state",
            ));
        };
        pending.key_values.push(value);
        self.list_sort_compute_keys(pending)
    }

    /// Clears pending list-sort state and drops held values.
    pub(super) fn clear_pending_list_sort(&mut self) {
        self.pending_list_sort_return = false;
        let Some(pending) = self.pending_list_sort.take() else {
            return;
        };
        if pending.holds_list_ref {
            self.heap.dec_ref(pending.list_id);
        }
        pending.key_fn.drop_with_heap(self.heap);
        for value in pending.items {
            value.drop_with_heap(self.heap);
        }
        for value in pending.key_values {
            value.drop_with_heap(self.heap);
        }
    }

    /// Finalizes a list sort with optional precomputed key values.
    fn finish_list_sort(
        &mut self,
        list_id: HeapId,
        mut items: Vec<Value>,
        mut key_values: Option<Vec<Value>>,
        reverse: bool,
    ) -> RunResult<()> {
        let len = items.len();
        let mut indices: Vec<usize> = (0..len).collect();
        let mut sort_error: Option<RunError> = None;

        if let Some(keys) = key_values.as_ref() {
            indices.sort_by(|&a, &b| {
                if sort_error.is_some() {
                    return Ordering::Equal;
                }
                if let Some(ord) = keys[a].py_cmp(&keys[b], self.heap, self.interns) {
                    if reverse { ord.reverse() } else { ord }
                } else {
                    sort_error = Some(ExcType::type_error(format!(
                        "'<' not supported between instances of '{}' and '{}'",
                        keys[a].py_type(self.heap),
                        keys[b].py_type(self.heap)
                    )));
                    Ordering::Equal
                }
            });
        } else {
            indices.sort_by(|&a, &b| {
                if sort_error.is_some() {
                    return Ordering::Equal;
                }
                if let Some(ord) = items[a].py_cmp(&items[b], self.heap, self.interns) {
                    if reverse { ord.reverse() } else { ord }
                } else {
                    sort_error = Some(ExcType::type_error(format!(
                        "'<' not supported between instances of '{}' and '{}'",
                        items[a].py_type(self.heap),
                        items[b].py_type(self.heap)
                    )));
                    Ordering::Equal
                }
            });
        }

        if let Some(keys) = key_values.take() {
            for value in keys {
                value.drop_with_heap(self.heap);
            }
        }

        if let Some(err) = sort_error {
            self.restore_list_items(list_id, items)?;
            return Err(err);
        }

        let mut sorted_items = Vec::with_capacity(len);
        for &index in &indices {
            sorted_items.push(std::mem::replace(&mut items[index], Value::Undefined));
        }

        self.restore_list_items(list_id, sorted_items)
    }

    /// Restores list contents after a sort operation.
    fn restore_list_items(&mut self, list_id: HeapId, items: Vec<Value>) -> RunResult<()> {
        let HeapData::List(list) = self.heap.get_mut(list_id) else {
            for value in items {
                value.drop_with_heap(self.heap);
            }
            return Err(RunError::internal("expected list while restoring sorted items"));
        };
        list.as_vec_mut().extend(items);
        Ok(())
    }

    /// Calls a callable value with the given arguments.
    ///
    /// Dispatches based on the callable type:
    /// - `Value::Builtin`: calls builtin directly, returns `Push`
    /// - `Value::ModuleFunction`: calls module function directly, returns `Push`
    /// - `Value::ExtFunction`: returns `External` for caller to execute
    /// - `Value::DefFunction`: pushes a new frame, returns `FramePushed`
    /// - `Value::Ref`: checks for closure/function on heap
    #[inline]
    pub(super) fn call_function(&mut self, callable: Value, args: ArgValues) -> Result<CallResult, RunError> {
        match callable {
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Super)) => {
                // super() needs VM context - handle it specially
                let result = self.call_super(args)?;
                Ok(CallResult::Push(result))
            }
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Any)) => self.call_any_builtin(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::All)) => self.call_all_builtin(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Sum)) => self.call_sum_builtin(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Enumerate)) => self.call_enumerate_builtin(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Zip)) => self.call_zip_builtin(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Isinstance)) => self.call_isinstance(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Issubclass)) => self.call_issubclass(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Map)) => self.call_map_builtin(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Filter)) => self.call_filter_builtin(args),
            Value::Builtin(Builtins::Function(BuiltinsFunctions::Sorted)) => self.call_sorted_builtin(args),
            Value::Builtin(Builtins::Type(Type::List)) => self.call_list_type_builtin(args),
            Value::Builtin(Builtins::Type(Type::Tuple)) => self.call_tuple_type_builtin(args),
            Value::Builtin(builtin) => {
                let result = builtin.call(self.heap, args, self.interns, self.print_writer)?;
                Ok(CallResult::Push(result))
            }
            Value::ModuleFunction(mf) => {
                let result = mf.call(self.heap, self.interns, args)?;
                self.handle_attr_call_result(result)
            }
            Value::ExtFunction(ext_id) => {
                // External function - return to caller to execute
                Ok(CallResult::External(ext_id, args))
            }
            Value::DefFunction(func_id) => {
                // Defined function without defaults or captured variables
                self.call_def_function(func_id, &[], Vec::new(), args)
            }
            Value::Ref(heap_id) => {
                // Could be a closure or function with defaults - check heap
                self.call_heap_callable(heap_id, callable, args)
            }
            _ => {
                args.drop_with_heap(self.heap);
                Err(ExcType::type_error("object is not callable"))
            }
        }
    }

    /// Calls the builtin `list` type in the generic call path.
    ///
    /// This mirrors the optimized call path for generator arguments so
    /// `list(gen())` can iterate via VM-driven generator suspension/resume.
    fn call_list_type_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let value = args.get_zero_one_arg("list", self.heap)?;
        match value {
            None => {
                let result = Type::List.call(self.heap, ArgValues::Empty, self.interns)?;
                Ok(CallResult::Push(result))
            }
            Some(iterable) => {
                if let Value::Ref(iter_id) = &iterable
                    && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
                {
                    self.list_build_from_iterator(iterable)
                } else {
                    let result = Type::List.call(self.heap, ArgValues::One(iterable), self.interns)?;
                    Ok(CallResult::Push(result))
                }
            }
        }
    }

    /// Calls `sum()` with generator-aware handling.
    ///
    /// For generator inputs, this first materializes values using
    /// `list_build_from_iterator` so iteration can suspend/resume in the VM.
    /// Once list construction finishes, `sum()` is finalized from
    /// `maybe_finish_sum_from_list_value`.
    fn call_sum_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let (iterable, start) = args.get_one_two_args("sum", self.heap)?;

        if let Value::Ref(iter_id) = &iterable
            && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
        {
            match self.list_build_from_iterator(iterable)? {
                CallResult::Push(list_value) => {
                    let sum_args = match start {
                        Some(start_value) => ArgValues::Two(list_value, start_value),
                        None => ArgValues::One(list_value),
                    };
                    let value = BuiltinsFunctions::Sum.call(self.heap, sum_args, self.interns, self.print_writer)?;
                    Ok(CallResult::Push(value))
                }
                CallResult::FramePushed => {
                    self.pending_sum_from_list = Some(PendingSumFromList { start });
                    Ok(CallResult::FramePushed)
                }
                other => {
                    if let Some(start_value) = start {
                        start_value.drop_with_heap(self.heap);
                    }
                    Ok(other)
                }
            }
        } else {
            let sum_args = match start {
                Some(start_value) => ArgValues::Two(iterable, start_value),
                None => ArgValues::One(iterable),
            };
            let value = BuiltinsFunctions::Sum.call(self.heap, sum_args, self.interns, self.print_writer)?;
            Ok(CallResult::Push(value))
        }
    }

    /// Calls `any()` with generator-aware handling.
    ///
    /// For generator inputs, this first materializes values through
    /// `list_build_from_iterator` and then applies `any()` to the list.
    fn call_any_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let iterable = args.get_one_arg("any", self.heap)?;
        if let Value::Ref(iter_id) = &iterable
            && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
        {
            match self.list_build_from_iterator(iterable)? {
                CallResult::Push(list_value) => {
                    let value = BuiltinsFunctions::Any.call(
                        self.heap,
                        ArgValues::One(list_value),
                        self.interns,
                        self.print_writer,
                    )?;
                    Ok(CallResult::Push(value))
                }
                CallResult::FramePushed => {
                    self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                        kind: PendingBuiltinFromListKind::Any,
                    });
                    Ok(CallResult::FramePushed)
                }
                other => Ok(other),
            }
        } else {
            let value =
                BuiltinsFunctions::Any.call(self.heap, ArgValues::One(iterable), self.interns, self.print_writer)?;
            Ok(CallResult::Push(value))
        }
    }

    /// Calls `all()` with generator-aware handling.
    ///
    /// For generator inputs, this first materializes values through
    /// `list_build_from_iterator` and then applies `all()` to the list.
    fn call_all_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let iterable = args.get_one_arg("all", self.heap)?;
        if let Value::Ref(iter_id) = &iterable
            && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
        {
            match self.list_build_from_iterator(iterable)? {
                CallResult::Push(list_value) => {
                    let value = BuiltinsFunctions::All.call(
                        self.heap,
                        ArgValues::One(list_value),
                        self.interns,
                        self.print_writer,
                    )?;
                    Ok(CallResult::Push(value))
                }
                CallResult::FramePushed => {
                    self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                        kind: PendingBuiltinFromListKind::All,
                    });
                    Ok(CallResult::FramePushed)
                }
                other => Ok(other),
            }
        } else {
            let value =
                BuiltinsFunctions::All.call(self.heap, ArgValues::One(iterable), self.interns, self.print_writer)?;
            Ok(CallResult::Push(value))
        }
    }

    /// Calls `min()` with generator-aware handling.
    ///
    /// For generator inputs, this first materializes values through
    /// `list_build_from_iterator` and then applies `min()` to the list.
    fn call_min_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let iterable = args.get_one_arg("min", self.heap)?;
        if let Value::Ref(iter_id) = &iterable
            && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
        {
            match self.list_build_from_iterator(iterable)? {
                CallResult::Push(list_value) => {
                    let value = BuiltinsFunctions::Min.call(
                        self.heap,
                        ArgValues::One(list_value),
                        self.interns,
                        self.print_writer,
                    )?;
                    Ok(CallResult::Push(value))
                }
                CallResult::FramePushed => {
                    self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                        kind: PendingBuiltinFromListKind::Min,
                    });
                    Ok(CallResult::FramePushed)
                }
                other => Ok(other),
            }
        } else {
            let value =
                BuiltinsFunctions::Min.call(self.heap, ArgValues::One(iterable), self.interns, self.print_writer)?;
            Ok(CallResult::Push(value))
        }
    }

    /// Calls `max()` with generator-aware handling.
    ///
    /// For generator inputs, this first materializes values through
    /// `list_build_from_iterator` and then applies `max()` to the list.
    fn call_max_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let iterable = args.get_one_arg("max", self.heap)?;
        if let Value::Ref(iter_id) = &iterable
            && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
        {
            match self.list_build_from_iterator(iterable)? {
                CallResult::Push(list_value) => {
                    let value = BuiltinsFunctions::Max.call(
                        self.heap,
                        ArgValues::One(list_value),
                        self.interns,
                        self.print_writer,
                    )?;
                    Ok(CallResult::Push(value))
                }
                CallResult::FramePushed => {
                    self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                        kind: PendingBuiltinFromListKind::Max,
                    });
                    Ok(CallResult::FramePushed)
                }
                other => Ok(other),
            }
        } else {
            let value =
                BuiltinsFunctions::Max.call(self.heap, ArgValues::One(iterable), self.interns, self.print_writer)?;
            Ok(CallResult::Push(value))
        }
    }
    /// Calls `enumerate()` with generator-aware handling.
    ///
    /// Generator input needs VM-driven iteration so suspension/resume works across
    /// generator frames and external calls. Non-generator inputs are delegated to
    /// the builtin implementation directly.
    fn call_enumerate_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let (iterable, start) = args.get_one_two_args("enumerate", self.heap)?;

        if let Value::Ref(iter_id) = &iterable
            && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
        {
            match self.list_build_from_iterator(iterable)? {
                CallResult::Push(list_value) => {
                    let enumerate_args = match start {
                        Some(start_value) => ArgValues::Two(list_value, start_value),
                        None => ArgValues::One(list_value),
                    };
                    let value = BuiltinsFunctions::Enumerate.call(
                        self.heap,
                        enumerate_args,
                        self.interns,
                        self.print_writer,
                    )?;
                    Ok(CallResult::Push(value))
                }
                CallResult::FramePushed => {
                    self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                        kind: PendingBuiltinFromListKind::Enumerate { start },
                    });
                    Ok(CallResult::FramePushed)
                }
                other => {
                    if let Some(start_value) = start {
                        start_value.drop_with_heap(self.heap);
                    }
                    Ok(other)
                }
            }
        } else {
            let enumerate_args = match start {
                Some(start_value) => ArgValues::Two(iterable, start_value),
                None => ArgValues::One(iterable),
            };
            let value =
                BuiltinsFunctions::Enumerate.call(self.heap, enumerate_args, self.interns, self.print_writer)?;
            Ok(CallResult::Push(value))
        }
    }

    /// Calls `zip()` with generator-aware handling.
    ///
    /// `zip()` is normally implemented via `OuroIter`, which cannot drive
    /// VM-managed generator frames. This normalizes each positional argument by
    /// materializing generator inputs into lists before invoking builtin `zip()`.
    fn call_zip_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let (positional, kwargs) = args.into_parts();
        let positional: Vec<Value> = positional.collect();

        if !kwargs.is_empty() {
            // Preserve builtin keyword-argument behavior (currently unsupported).
            let zip_args = build_arg_values(positional, kwargs);
            let value = BuiltinsFunctions::Zip.call(self.heap, zip_args, self.interns, self.print_writer)?;
            return Ok(CallResult::Push(value));
        }

        // Use a reverse-order worklist so `pop()` keeps original positional order.
        let remaining = positional.into_iter().rev().collect();
        self.call_zip_builtin_normalized(Vec::new(), remaining)
    }

    /// Continues `zip()` argument normalization after each generator materialization.
    ///
    /// `materialized` and `remaining` hold positional args in original order:
    /// - `materialized`: already normalized values
    /// - `remaining`: reverse-order worklist of values still to normalize
    fn call_zip_builtin_normalized(
        &mut self,
        mut materialized: Vec<Value>,
        mut remaining: Vec<Value>,
    ) -> Result<CallResult, RunError> {
        while let Some(next_arg) = remaining.pop() {
            let needs_materialize = matches!(
                next_arg,
                Value::Ref(iter_id) if matches!(self.heap.get(iter_id), HeapData::Generator(_))
            );

            if !needs_materialize {
                materialized.push(next_arg);
                continue;
            }

            match self.list_build_from_iterator(next_arg) {
                Ok(CallResult::Push(list_value)) => materialized.push(list_value),
                Ok(CallResult::FramePushed) => {
                    self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                        kind: PendingBuiltinFromListKind::Zip {
                            materialized,
                            remaining,
                        },
                    });
                    return Ok(CallResult::FramePushed);
                }
                Ok(other) => {
                    for value in materialized {
                        value.drop_with_heap(self.heap);
                    }
                    for value in remaining {
                        value.drop_with_heap(self.heap);
                    }
                    return Ok(other);
                }
                Err(error) => {
                    for value in materialized {
                        value.drop_with_heap(self.heap);
                    }
                    for value in remaining {
                        value.drop_with_heap(self.heap);
                    }
                    return Err(error);
                }
            }
        }

        let zip_args = build_arg_values(materialized, KwargsValues::Empty);
        let value = BuiltinsFunctions::Zip.call(self.heap, zip_args, self.interns, self.print_writer)?;
        Ok(CallResult::Push(value))
    }

    /// Calls `map()` with support for user-defined functions.
    ///
    /// For user-defined functions (DefFunction, Closure), this collects items from
    /// all iterables and returns `AttrCallResult::MapCall` for the VM to handle.
    /// For builtin functions, it delegates to the standard builtin implementation.
    fn call_map_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        use crate::builtins::BuiltinsFunctions;

        let (mut positional, kwargs) = args.into_parts();

        // Check for unsupported kwargs
        if !kwargs.is_empty() {
            kwargs.drop_with_heap(self.heap);
            positional.drop_with_heap(self.heap);
            return Err(ExcType::type_error("map() does not support keyword arguments"));
        }

        // Check for at least one argument (the function)
        let pos_len = positional.len();
        if pos_len == 0 {
            positional.drop_with_heap(self.heap);
            return Err(ExcType::type_error("map() must have at least one argument (the function)"));
        }

        // Get the function (first argument)
        let func = positional.next().expect("len check ensures at least one value");

        // If only function provided (no iterables), return empty list
        if pos_len == 1 {
            func.drop_with_heap(self.heap);
            let list_id = self.heap.allocate(HeapData::List(List::new(Vec::new())))?;
            return Ok(CallResult::Push(Value::Ref(list_id)));
        }

        // Check if function is user-defined (needs VM frame management)
        let is_user_defined = matches!(&func, Value::DefFunction(_))
            || matches!(&func, Value::Ref(id) if matches!(self.heap.get(*id), HeapData::Closure(_, _, _)));

        if !is_user_defined {
            // For builtin functions, use the standard implementation
            let iterables: Vec<Value> = positional.collect();
            let map_args = build_arg_values(std::iter::once(func).chain(iterables), KwargsValues::Empty);
            let result = BuiltinsFunctions::Map.call(self.heap, map_args, self.interns, self.print_writer)?;
            return Ok(CallResult::Push(result));
        }

        // User-defined function: collect items from all iterators
        let mut iterators: Vec<OuroIter> = Vec::with_capacity(pos_len - 1);
        for iterable in positional {
            match OuroIter::new(iterable, self.heap, self.interns) {
                Ok(iter) => iterators.push(iter),
                Err(e) => {
                    // Clean up already-created iterators
                    for iter in iterators {
                        iter.drop_with_heap(self.heap);
                    }
                    func.drop_with_heap(self.heap);
                    return Err(e);
                }
            }
        }

        // Collect all items from iterators
        let mut collected_iters: Vec<Vec<Value>> = Vec::with_capacity(iterators.len());
        for _ in 0..iterators.len() {
            collected_iters.push(Vec::new());
        }

        'outer: loop {
            for (i, iter) in iterators.iter_mut().enumerate() {
                match iter.for_next(self.heap, self.interns)? {
                    Some(item) => collected_iters[i].push(item),
                    None => {
                        // This iterator is exhausted - stop all iteration
                        break 'outer;
                    }
                }
            }
        }

        // Clean up iterators
        for iter in iterators {
            iter.drop_with_heap(self.heap);
        }

        // Check if all iterators are empty
        if collected_iters.is_empty() || collected_iters[0].is_empty() {
            func.drop_with_heap(self.heap);
            for iter_items in collected_iters {
                for item in iter_items {
                    item.drop_with_heap(self.heap);
                }
            }
            let list_id = self.heap.allocate(HeapData::List(List::new(Vec::new())))?;
            return Ok(CallResult::Push(Value::Ref(list_id)));
        }

        // Return MapCall for the VM to handle
        self.handle_attr_call_result(AttrCallResult::MapCall(func, collected_iters))
    }

    /// Calls `filter()` with support for user-defined functions.
    ///
    /// For user-defined functions (DefFunction, Closure), this collects items from
    /// the iterable and returns `AttrCallResult::FilterCall` for the VM to handle.
    /// For builtin functions or None, it delegates to the standard builtin implementation.
    fn call_filter_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        use crate::builtins::BuiltinsFunctions;

        let (mut positional, kwargs) = args.into_parts();

        // Check for unsupported kwargs
        if !kwargs.is_empty() {
            kwargs.drop_with_heap(self.heap);
            positional.drop_with_heap(self.heap);
            return Err(ExcType::type_error("filter() does not support keyword arguments"));
        }

        // Check for correct number of arguments
        let pos_len = positional.len();
        if pos_len != 2 {
            positional.drop_with_heap(self.heap);
            return Err(ExcType::type_error(format!(
                "filter() expected 2 arguments, got {pos_len}"
            )));
        }

        // Get the function (first argument) and iterable (second argument)
        let func = positional.next().expect("len check ensures at least one value");
        let iterable = positional.next().expect("len check ensures two values");

        // Check if function is None (identity filter) - use standard builtin
        let is_none = matches!(&func, Value::None);

        // Check if function is user-defined (needs VM frame management)
        let is_user_defined = !is_none
            && (matches!(&func, Value::DefFunction(_))
                || matches!(&func, Value::Ref(id) if matches!(self.heap.get(*id), HeapData::Closure(_, _, _))));

        if !is_user_defined {
            // For builtin functions or None, use the standard implementation
            let filter_args = ArgValues::Two(func, iterable);
            let result = BuiltinsFunctions::Filter.call(self.heap, filter_args, self.interns, self.print_writer)?;
            return Ok(CallResult::Push(result));
        }

        // User-defined function: collect items from iterator
        let mut iterator = match OuroIter::new(iterable, self.heap, self.interns) {
            Ok(iter) => iter,
            Err(e) => {
                func.drop_with_heap(self.heap);
                return Err(e);
            }
        };

        // Collect all items
        let mut items: Vec<Value> = Vec::new();
        loop {
            match iterator.for_next(self.heap, self.interns)? {
                Some(item) => items.push(item),
                None => break,
            }
        }
        iterator.drop_with_heap(self.heap);

        // Check if empty
        if items.is_empty() {
            func.drop_with_heap(self.heap);
            let list_id = self.heap.allocate(HeapData::List(List::new(Vec::new())))?;
            return Ok(CallResult::Push(Value::Ref(list_id)));
        }

        // Return FilterCall for the VM to handle
        self.handle_attr_call_result(AttrCallResult::FilterCall(func, items))
    }

    /// Calls `sorted()` with support for user-defined key functions.
    ///
    /// Collects items from the iterable and calls `list.sort()` on the resulting list.
    /// The `call_list_sort` path handles user-defined key functions via the VM.
    fn call_sorted_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let (mut positional, kwargs) = args.into_parts();

        let positional_len = positional.len();
        if positional_len != 1 {
            kwargs.drop_with_heap(self.heap);
            for v in positional {
                v.drop_with_heap(self.heap);
            }
            return Err(ExcType::type_error(format!(
                "sorted expected 1 argument, got {positional_len}"
            )));
        }

        let iterable = positional.next().unwrap();

        // Collect items from iterable
        let mut iter = match OuroIter::new(iterable, self.heap, self.interns) {
            Ok(iter) => iter,
            Err(err) => {
                kwargs.drop_with_heap(self.heap);
                return Err(err);
            }
        };

        let items: Vec<_> = match iter.collect(self.heap, self.interns) {
            Ok(items) => items,
            Err(err) => {
                iter.drop_with_heap(self.heap);
                kwargs.drop_with_heap(self.heap);
                return Err(err);
            }
        };
        iter.drop_with_heap(self.heap);

        let list_id = self.heap.allocate(HeapData::List(List::new(items)))?;

        // Call list.sort through the VM path which handles user-defined key functions
        let result = self.call_list_sort(list_id, kwargs);

        // call_list_sort consumes the kwargs and handles user-defined key functions
        // We need to return the list, not the None that list.sort() returns
        match result {
            Ok(CallResult::Push(_)) => {
                // list.sort() returns None, but we need to return the sorted list
                Ok(CallResult::Push(Value::Ref(list_id)))
            }
            Ok(CallResult::FramePushed) => {
                // Key function pushed a frame - the pending_list_sort stores list_id
                // We need to ensure the list is returned when sort completes
                // The pending_list_sort_return handler will return None from list.sort()
                // We need to intercept that and return the list instead
                // Set a flag to indicate we want the list returned, not None
                self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                    kind: PendingBuiltinFromListKind::Sorted(list_id),
                });
                Ok(CallResult::FramePushed)
            }
            Ok(other) => {
                // Other results (External, OsCall) - need to handle list cleanup
                Value::Ref(list_id).drop_with_heap(self.heap);
                Ok(other)
            }
            Err(err) => {
                Value::Ref(list_id).drop_with_heap(self.heap);
                Err(err)
            }
        }
    }

    /// Calls the builtin `tuple` type in the generic call path.
    ///
    /// Generator inputs are materialized through VM-driven iteration before
    /// building the tuple so generator frames can suspend/resume correctly.
    fn call_tuple_type_builtin(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let value = args.get_zero_one_arg("tuple", self.heap)?;
        match value {
            None => {
                let result = Type::Tuple.call(self.heap, ArgValues::Empty, self.interns)?;
                Ok(CallResult::Push(result))
            }
            Some(iterable) => {
                if let Value::Ref(iter_id) = &iterable
                    && matches!(self.heap.get(*iter_id), HeapData::Generator(_))
                {
                    match self.list_build_from_iterator(iterable)? {
                        CallResult::Push(list_value) => {
                            let tuple_value = Type::Tuple.call(self.heap, ArgValues::One(list_value), self.interns)?;
                            Ok(CallResult::Push(tuple_value))
                        }
                        CallResult::FramePushed => {
                            self.pending_builtin_from_list = Some(PendingBuiltinFromList {
                                kind: PendingBuiltinFromListKind::Tuple,
                            });
                            Ok(CallResult::FramePushed)
                        }
                        other => Ok(other),
                    }
                } else {
                    let result = Type::Tuple.call(self.heap, ArgValues::One(iterable), self.interns)?;
                    Ok(CallResult::Push(result))
                }
            }
        }
    }

    /// Clears pending `sum(generator[, start])` state and drops held values.
    fn clear_pending_sum_from_list(&mut self) {
        if let Some(pending) = self.pending_sum_from_list.take()
            && let Some(start) = pending.start
        {
            start.drop_with_heap(self.heap);
        }
    }

    /// Finalizes a completed list materialization for pending `sum(generator)` calls.
    ///
    /// If no sum is pending, the list value is returned unchanged.
    pub(super) fn maybe_finish_sum_from_list_value(&mut self, list_value: Value) -> Result<CallResult, RunError> {
        let Some(pending) = self.pending_sum_from_list.take() else {
            return Ok(CallResult::Push(list_value));
        };

        let sum_args = match pending.start {
            Some(start_value) => ArgValues::Two(list_value, start_value),
            None => ArgValues::One(list_value),
        };
        let value = BuiltinsFunctions::Sum.call(self.heap, sum_args, self.interns, self.print_writer)?;
        Ok(CallResult::Push(value))
    }

    /// Applies pending sum-finalization to a list-build continuation result.
    ///
    /// This keeps `pending_sum_from_list` consistent across success and error paths.
    pub(super) fn maybe_finish_sum_from_list_result(
        &mut self,
        result: Result<CallResult, RunError>,
    ) -> Result<CallResult, RunError> {
        match result {
            Ok(CallResult::Push(value)) => self.maybe_finish_sum_from_list_value(value),
            Ok(other) => Ok(other),
            Err(e) => {
                self.clear_pending_sum_from_list();
                Err(e)
            }
        }
    }

    /// Clears pending builtin-after-materialization state.
    pub(super) fn clear_pending_builtin_from_list(&mut self) {
        let Some(pending) = self.pending_builtin_from_list.take() else {
            return;
        };

        match pending.kind {
            PendingBuiltinFromListKind::Any
            | PendingBuiltinFromListKind::All
            | PendingBuiltinFromListKind::Tuple
            | PendingBuiltinFromListKind::Min
            | PendingBuiltinFromListKind::Max
            | PendingBuiltinFromListKind::Join(_) => {}
            PendingBuiltinFromListKind::Enumerate { start } => {
                if let Some(start_value) = start {
                    start_value.drop_with_heap(self.heap);
                }
            }
            PendingBuiltinFromListKind::Zip {
                materialized,
                remaining,
            } => {
                for value in materialized {
                    value.drop_with_heap(self.heap);
                }
                for value in remaining {
                    value.drop_with_heap(self.heap);
                }
            }
        }
    }

    /// Finalizes a completed list materialization for pending builtin calls.
    ///
    /// If no builtin is pending, the list value is returned unchanged.
    pub(super) fn maybe_finish_builtin_from_list_value(&mut self, list_value: Value) -> Result<CallResult, RunError> {
        let Some(pending) = self.pending_builtin_from_list.take() else {
            return Ok(CallResult::Push(list_value));
        };

        match pending.kind {
            PendingBuiltinFromListKind::Any => {
                let value = BuiltinsFunctions::Any.call(
                    self.heap,
                    ArgValues::One(list_value),
                    self.interns,
                    self.print_writer,
                )?;
                Ok(CallResult::Push(value))
            }
            PendingBuiltinFromListKind::All => {
                let value = BuiltinsFunctions::All.call(
                    self.heap,
                    ArgValues::One(list_value),
                    self.interns,
                    self.print_writer,
                )?;
                Ok(CallResult::Push(value))
            }
            PendingBuiltinFromListKind::Min => {
                let value = BuiltinsFunctions::Min.call(
                    self.heap,
                    ArgValues::One(list_value),
                    self.interns,
                    self.print_writer,
                )?;
                Ok(CallResult::Push(value))
            }
            PendingBuiltinFromListKind::Max => {
                let value = BuiltinsFunctions::Max.call(
                    self.heap,
                    ArgValues::One(list_value),
                    self.interns,
                    self.print_writer,
                )?;
                Ok(CallResult::Push(value))
            }
            PendingBuiltinFromListKind::Tuple => {
                let value = Type::Tuple.call(self.heap, ArgValues::One(list_value), self.interns)?;
                Ok(CallResult::Push(value))
            }
            PendingBuiltinFromListKind::Join(separator) => {
                let value = call_str_method(
                    self.interns.get_str(separator),
                    StaticStrings::Join.into(),
                    ArgValues::One(list_value),
                    self.heap,
                    self.interns,
                )?;
                Ok(CallResult::Push(value))
            }
            PendingBuiltinFromListKind::Enumerate { start } => {
                let enumerate_args = match start {
                    Some(start_value) => ArgValues::Two(list_value, start_value),
                    None => ArgValues::One(list_value),
                };
                let value =
                    BuiltinsFunctions::Enumerate.call(self.heap, enumerate_args, self.interns, self.print_writer)?;
                Ok(CallResult::Push(value))
            }
            PendingBuiltinFromListKind::Zip {
                mut materialized,
                remaining,
            } => {
                materialized.push(list_value);
                self.call_zip_builtin_normalized(materialized, remaining)
            }
        }
    }

    /// Applies pending builtin-finalization to a list-build continuation result.
    ///
    /// This keeps `pending_builtin_from_list` consistent across success and error paths.
    pub(super) fn maybe_finish_builtin_from_list_result(
        &mut self,
        result: Result<CallResult, RunError>,
    ) -> Result<CallResult, RunError> {
        match result {
            Ok(CallResult::Push(value)) => self.maybe_finish_builtin_from_list_value(value),
            Ok(other) => Ok(other),
            Err(e) => {
                self.clear_pending_builtin_from_list();
                Err(e)
            }
        }
    }

    /// Calls the `isinstance()` builtin with metaclass `__instancecheck__` support.
    fn call_isinstance(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let (obj, classinfo) = args.get_two_args("isinstance", self.heap)?;

        if let Value::Ref(class_id) = &classinfo
            && matches!(self.heap.get(*class_id), HeapData::ClassObject(_))
        {
            // Protocol classes require typing's custom semantics (including the
            // runtime_checkable guard). Handle these before generic metaclass
            // dispatch so default `type.__instancecheck__` does not swallow it.
            if self.class_has_protocol_marker(*class_id) {
                let method = Value::ModuleFunction(ModuleFunctions::Typing(TypingFunctions::ProtocolInstancecheck));
                let result = self.call_class_dunder(*class_id, method, ArgValues::One(obj));
                classinfo.drop_with_heap(self.heap);
                return match result {
                    Ok(CallResult::Push(value)) => {
                        let b = value.py_bool(self.heap, self.interns);
                        value.drop_with_heap(self.heap);
                        Ok(CallResult::Push(Value::Bool(b)))
                    }
                    Ok(CallResult::FramePushed) => {
                        self.pending_instancecheck_return = true;
                        Ok(CallResult::FramePushed)
                    }
                    Ok(other) => Ok(other),
                    Err(e) => Err(e),
                };
            }

            let dunder_id: StringId = StaticStrings::DunderInstancecheck.into();
            if let Some(method) = self.lookup_metaclass_dunder(*class_id, dunder_id) {
                let result = self.call_class_dunder(*class_id, method, ArgValues::One(obj));
                classinfo.drop_with_heap(self.heap);
                return match result {
                    Ok(CallResult::Push(value)) => {
                        let b = value.py_bool(self.heap, self.interns);
                        value.drop_with_heap(self.heap);
                        Ok(CallResult::Push(Value::Bool(b)))
                    }
                    Ok(CallResult::FramePushed) => {
                        self.pending_instancecheck_return = true;
                        Ok(CallResult::FramePushed)
                    }
                    Ok(other) => Ok(other),
                    Err(e) => Err(e),
                };
            }
        }

        // Fallback to builtin implementation
        let result = crate::builtins::isinstance::builtin_isinstance(self.heap, ArgValues::Two(obj, classinfo))?;
        Ok(CallResult::Push(result))
    }

    /// Calls the `issubclass()` builtin with metaclass `__subclasscheck__` support.
    fn call_issubclass(&mut self, args: ArgValues) -> Result<CallResult, RunError> {
        let (cls_val, classinfo) = args.get_two_args("issubclass", self.heap)?;

        if let Value::Ref(class_id) = &classinfo
            && matches!(self.heap.get(*class_id), HeapData::ClassObject(_))
        {
            let dunder_id: StringId = StaticStrings::DunderSubclasscheck.into();
            if let Some(method) = self.lookup_metaclass_dunder(*class_id, dunder_id) {
                let result = self.call_class_dunder(*class_id, method, ArgValues::One(cls_val));
                classinfo.drop_with_heap(self.heap);
                return match result {
                    Ok(CallResult::Push(value)) => {
                        let b = value.py_bool(self.heap, self.interns);
                        value.drop_with_heap(self.heap);
                        Ok(CallResult::Push(Value::Bool(b)))
                    }
                    Ok(CallResult::FramePushed) => {
                        self.pending_subclasscheck_return = true;
                        Ok(CallResult::FramePushed)
                    }
                    Ok(other) => Ok(other),
                    Err(e) => Err(e),
                };
            }
        }

        let result = crate::builtins::isinstance::builtin_issubclass(self.heap, ArgValues::Two(cls_val, classinfo))?;
        Ok(CallResult::Push(result))
    }

    /// Handles calling a heap-allocated callable (closure, function with defaults, or class).
    ///
    /// Uses a two-phase approach to avoid borrow conflicts:
    /// 1. Copy data without incrementing refcounts
    /// 2. Increment refcounts after the borrow ends
    fn call_heap_callable(
        &mut self,
        heap_id: HeapId,
        callable: Value,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        // Built-in callable wrappers for class and function introspection.
        if matches!(self.heap.get(heap_id), HeapData::ClassSubclasses(_)) {
            let class_id = match self.heap.get(heap_id) {
                HeapData::ClassSubclasses(cs) => cs.class_id(),
                _ => unreachable!(),
            };
            args.check_zero_args("type.__subclasses__", self.heap)?;
            callable.drop_with_heap(self.heap);
            let subclasses = self.collect_class_subclasses(class_id)?;
            let list_id = self.heap.allocate(HeapData::List(List::new(subclasses)))?;
            return Ok(CallResult::Push(Value::Ref(list_id)));
        }

        if matches!(self.heap.get(heap_id), HeapData::ClassGetItem(_)) {
            let class_id = match self.heap.get(heap_id) {
                HeapData::ClassGetItem(cg) => cg.class_id(),
                _ => unreachable!(),
            };
            let (first, second) = args.get_one_two_args("type.__class_getitem__", self.heap)?;
            let item = if let Some(second) = second {
                first.drop_with_heap(self.heap);
                second
            } else {
                first
            };
            self.heap.inc_ref(class_id);
            let origin = Value::Ref(class_id);
            callable.drop_with_heap(self.heap);
            let alias = make_generic_alias(origin, item, self.heap, self.interns)?;
            return Ok(CallResult::Push(alias));
        }

        if matches!(self.heap.get(heap_id), HeapData::FunctionGet(_)) {
            let func_value = match self.heap.get(heap_id) {
                HeapData::FunctionGet(getter) => getter.func().clone_with_heap(self.heap),
                _ => unreachable!(),
            };
            let (obj, owner) = args.get_one_two_args("function.__get__", self.heap)?;
            if let Some(owner) = owner {
                owner.drop_with_heap(self.heap);
            }
            callable.drop_with_heap(self.heap);
            if matches!(obj, Value::None) {
                obj.drop_with_heap(self.heap);
                return Ok(CallResult::Push(func_value));
            }
            let bound_id = self
                .heap
                .allocate(HeapData::BoundMethod(crate::types::BoundMethod::new(func_value, obj)))?;
            return Ok(CallResult::Push(Value::Ref(bound_id)));
        }

        if matches!(self.heap.get(heap_id), HeapData::WeakRef(_)) {
            args.check_zero_args("weakref", self.heap)?;
            let target_id = match self.heap.get(heap_id) {
                HeapData::WeakRef(wr) => wr.target(),
                _ => unreachable!(),
            };
            callable.drop_with_heap(self.heap);
            if let Some(target_id) = target_id {
                if self.heap.get_if_live(target_id).is_some() {
                    self.heap.inc_ref(target_id);
                    return Ok(CallResult::Push(Value::Ref(target_id)));
                }
                self.heap.with_entry_mut(heap_id, |_, data| {
                    let HeapData::WeakRef(wr) = data else {
                        return Err(RunError::internal("weakref target mutated during call"));
                    };
                    wr.clear();
                    Ok(())
                })?;
            }
            return Ok(CallResult::Push(Value::None));
        }

        // Check if this is a ClassObject (class instantiation)
        if matches!(self.heap.get(heap_id), HeapData::ClassObject(_)) {
            let call_id: StringId = StaticStrings::DunderCall.into();
            if let Some(method) = self.lookup_metaclass_dunder(heap_id, call_id) {
                let result = self.call_class_dunder(heap_id, method, args)?;
                callable.drop_with_heap(self.heap);
                return Ok(result);
            }
            return self.call_class_instantiate(heap_id, callable, args);
        }

        // Check if this is an Instance with __call__
        if matches!(self.heap.get(heap_id), HeapData::Instance(_)) {
            let dunder_id: StringId = StaticStrings::DunderCall.into();
            if let Some(method) = self.lookup_type_dunder(heap_id, dunder_id) {
                callable.drop_with_heap(self.heap);
                return self.call_dunder(heap_id, method, args);
            }
            callable.drop_with_heap(self.heap);
            args.drop_with_heap(self.heap);
            return Err(ExcType::type_error("object is not callable"));
        }

        // Check if this is a bound method (prepend bound self/cls).
        if matches!(self.heap.get(heap_id), HeapData::BoundMethod(_)) {
            let (func, self_arg) = match self.heap.get(heap_id) {
                HeapData::BoundMethod(bm) => (
                    bm.func().clone_with_heap(self.heap),
                    bm.self_arg().clone_with_heap(self.heap),
                ),
                _ => unreachable!("call_heap_callable: not a BoundMethod"),
            };
            callable.drop_with_heap(self.heap);

            let new_args = match args {
                ArgValues::Empty => ArgValues::One(self_arg),
                ArgValues::One(a) => ArgValues::Two(self_arg, a),
                ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                    args: vec![self_arg, a, b],
                    kwargs: KwargsValues::Empty,
                },
                ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                    args: vec![self_arg],
                    kwargs: kw,
                },
                ArgValues::ArgsKargs { mut args, kwargs } => {
                    args.insert(0, self_arg);
                    ArgValues::ArgsKargs { args, kwargs }
                }
            };

            return self.call_function(func, new_args);
        }

        // Check if this is a functools.partial (prepend stored args)
        if matches!(self.heap.get(heap_id), HeapData::Partial(_)) {
            let (func, partial_args, partial_kwargs) = match self.heap.get(heap_id) {
                HeapData::Partial(p) => (
                    p.func().clone_with_heap(self.heap),
                    p.args()
                        .iter()
                        .map(|v| v.clone_with_heap(self.heap))
                        .collect::<Vec<_>>(),
                    p.kwargs()
                        .iter()
                        .map(|(k, v)| (k.clone_with_heap(self.heap), v.clone_with_heap(self.heap)))
                        .collect::<Vec<_>>(),
                ),
                _ => unreachable!("call_heap_callable: not a Partial"),
            };
            callable.drop_with_heap(self.heap);

            // Prepend partial's stored positional args before call-site args
            let new_args = build_partial_call_args(partial_args, partial_kwargs, args, self.heap, self.interns)?;
            return self.call_function(func, new_args);
        }

        if matches!(self.heap.get(heap_id), HeapData::SingleDispatch(_)) {
            return self.call_singledispatch_callable(heap_id, callable, args);
        }

        if matches!(self.heap.get(heap_id), HeapData::SingleDispatchRegister(_)) {
            let (dispatcher, cls) = match self.heap.get(heap_id) {
                HeapData::SingleDispatchRegister(register) => (
                    register.dispatcher.clone_with_heap(self.heap),
                    register.cls.clone_with_heap(self.heap),
                ),
                _ => unreachable!("call_heap_callable: not a SingleDispatchRegister"),
            };
            callable.drop_with_heap(self.heap);
            let func = match args.get_one_arg("singledispatch.register", self.heap) {
                Ok(func) => func,
                Err(err) => {
                    dispatcher.drop_with_heap(self.heap);
                    cls.drop_with_heap(self.heap);
                    return Err(err);
                }
            };
            let func_for_registry = func.clone_with_heap(self.heap);
            self.singledispatch_register(dispatcher, cls, func_for_registry)?;
            return Ok(CallResult::Push(func));
        }

        if matches!(self.heap.get(heap_id), HeapData::SingleDispatchMethod(_)) {
            let dispatcher = match self.heap.get(heap_id) {
                HeapData::SingleDispatchMethod(method) => method.dispatcher.clone_with_heap(self.heap),
                _ => unreachable!("call_heap_callable: not a SingleDispatchMethod"),
            };
            callable.drop_with_heap(self.heap);
            return self.call_function(dispatcher, args);
        }

        // Check if this is a functools.cmp_to_key wrapper (it's callable - creates a key value)
        if matches!(self.heap.get(heap_id), HeapData::CmpToKey(_)) {
            let cmp_func = match self.heap.get(heap_id) {
                HeapData::CmpToKey(c) => c.func().clone_with_heap(self.heap),
                _ => unreachable!("call_heap_callable: not a CmpToKey"),
            };
            // cmp_to_key(mycmp)(x)  for now, just return the value itself
            // since our sort implementation doesn't use key functions via cmp_to_key yet
            let obj = args.get_one_arg("cmp_to_key", self.heap)?;
            callable.drop_with_heap(self.heap);
            cmp_func.drop_with_heap(self.heap);
            return Ok(CallResult::Push(obj));
        }

        // Check if this is an operator.itemgetter callable
        if matches!(self.heap.get(heap_id), HeapData::ItemGetter(_)) {
            let (mut positional, kwargs) = args.into_parts();
            if !kwargs.is_empty() {
                positional.drop_with_heap(self.heap);
                kwargs.drop_with_heap(self.heap);
                callable.drop_with_heap(self.heap);
                return Err(ExcType::type_error("itemgetter() takes no keyword arguments"));
            }
            let arg_count = positional.len();
            if arg_count != 1 {
                positional.drop_with_heap(self.heap);
                callable.drop_with_heap(self.heap);
                return Err(ExcType::type_error(format!(
                    "itemgetter expected 1 argument, got {arg_count}"
                )));
            }
            let mut obj = positional.next().expect("length checked");
            let items = match self.heap.get(heap_id) {
                HeapData::ItemGetter(getter) => getter
                    .items()
                    .iter()
                    .map(|v| v.clone_with_heap(self.heap))
                    .collect::<Vec<_>>(),
                _ => unreachable!("call_heap_callable: not an ItemGetter"),
            };
            let item_count = items.len();
            callable.drop_with_heap(self.heap);

            let mut item_iter = items.into_iter();
            if item_count == 1 {
                let key = item_iter.next().expect("length checked");
                let result = obj.py_getitem(&key, self.heap, self.interns);
                key.drop_with_heap(self.heap);
                item_iter.drop_with_heap(self.heap);
                obj.drop_with_heap(self.heap);
                return result.map(CallResult::Push);
            }

            let mut values: Vec<Value> = Vec::with_capacity(item_count);
            while let Some(key) = item_iter.next() {
                match obj.py_getitem(&key, self.heap, self.interns) {
                    Ok(value) => {
                        key.drop_with_heap(self.heap);
                        values.push(value);
                    }
                    Err(err) => {
                        key.drop_with_heap(self.heap);
                        item_iter.drop_with_heap(self.heap);
                        for value in values {
                            value.drop_with_heap(self.heap);
                        }
                        obj.drop_with_heap(self.heap);
                        return Err(err);
                    }
                }
            }
            obj.drop_with_heap(self.heap);
            let tuple = allocate_tuple(SmallVec::from_vec(values), self.heap)?;
            return Ok(CallResult::Push(tuple));
        }

        // Check if this is an operator.attrgetter callable
        if matches!(self.heap.get(heap_id), HeapData::AttrGetter(_)) {
            let (mut positional, kwargs) = args.into_parts();
            if !kwargs.is_empty() {
                positional.drop_with_heap(self.heap);
                kwargs.drop_with_heap(self.heap);
                callable.drop_with_heap(self.heap);
                return Err(ExcType::type_error("attrgetter() takes no keyword arguments"));
            }
            let arg_count = positional.len();
            if arg_count != 1 {
                positional.drop_with_heap(self.heap);
                callable.drop_with_heap(self.heap);
                return Err(ExcType::type_error(format!(
                    "attrgetter expected 1 argument, got {arg_count}"
                )));
            }
            let obj = positional.next().expect("length checked");
            let attrs = match self.heap.get(heap_id) {
                HeapData::AttrGetter(getter) => getter
                    .attrs()
                    .iter()
                    .map(|v| v.clone_with_heap(self.heap))
                    .collect::<Vec<_>>(),
                _ => unreachable!("call_heap_callable: not an AttrGetter"),
            };
            let attr_count = attrs.len();
            callable.drop_with_heap(self.heap);

            let mut attr_iter = attrs.into_iter();
            let mut values: Vec<Value> = Vec::with_capacity(attr_count);
            while let Some(attr) = attr_iter.next() {
                let Some(attr_name) = attr.as_either_str(self.heap) else {
                    attr.drop_with_heap(self.heap);
                    attr_iter.drop_with_heap(self.heap);
                    for value in values {
                        value.drop_with_heap(self.heap);
                    }
                    obj.drop_with_heap(self.heap);
                    return Err(ExcType::type_error("attribute name must be a string"));
                };
                let mut current = obj.clone_with_heap(self.heap);
                for segment in attr_name.as_str(self.interns).split('.') {
                    match self.getattr_dynamic_str(&current, segment) {
                        Ok(AttrCallResult::Value(next)) => {
                            current.drop_with_heap(self.heap);
                            current = next;
                        }
                        Ok(_) => {
                            current.drop_with_heap(self.heap);
                            attr.drop_with_heap(self.heap);
                            attr_iter.drop_with_heap(self.heap);
                            for value in values {
                                value.drop_with_heap(self.heap);
                            }
                            obj.drop_with_heap(self.heap);
                            return Err(RunError::internal("attrgetter returned non-value result"));
                        }
                        Err(err) => {
                            current.drop_with_heap(self.heap);
                            attr.drop_with_heap(self.heap);
                            attr_iter.drop_with_heap(self.heap);
                            for value in values {
                                value.drop_with_heap(self.heap);
                            }
                            obj.drop_with_heap(self.heap);
                            return Err(err);
                        }
                    }
                }
                attr.drop_with_heap(self.heap);
                values.push(current);
            }
            obj.drop_with_heap(self.heap);
            if values.len() == 1 {
                return Ok(CallResult::Push(values.pop().expect("length checked")));
            }
            let tuple = allocate_tuple(SmallVec::from_vec(values), self.heap)?;
            return Ok(CallResult::Push(tuple));
        }

        // Check if this is an operator.methodcaller callable
        if matches!(self.heap.get(heap_id), HeapData::MethodCaller(_)) {
            let (mut positional, kwargs) = args.into_parts();
            let arg_count = positional.len();
            if !kwargs.is_empty() {
                positional.drop_with_heap(self.heap);
                kwargs.drop_with_heap(self.heap);
                callable.drop_with_heap(self.heap);
                if arg_count == 0 {
                    return Err(ExcType::type_error(format!(
                        "methodcaller expected 1 argument, got {arg_count}"
                    )));
                }
                return Err(ExcType::type_error("methodcaller() takes no keyword arguments"));
            }
            if arg_count != 1 {
                positional.drop_with_heap(self.heap);
                callable.drop_with_heap(self.heap);
                return Err(ExcType::type_error(format!(
                    "methodcaller expected 1 argument, got {arg_count}"
                )));
            }
            let obj = positional.next().expect("length checked");

            let (name_value, stored_args, stored_kwargs) = match self.heap.get(heap_id) {
                HeapData::MethodCaller(caller) => {
                    let Some(name_str) = caller.name().as_either_str(self.heap) else {
                        callable.drop_with_heap(self.heap);
                        obj.drop_with_heap(self.heap);
                        return Err(ExcType::type_error("method name must be a string"));
                    };
                    let args = caller
                        .args()
                        .iter()
                        .map(|v| v.clone_with_heap(self.heap))
                        .collect::<Vec<_>>();
                    let kwargs = caller
                        .kwargs()
                        .iter()
                        .map(|(k, v)| (k.clone_with_heap(self.heap), v.clone_with_heap(self.heap)))
                        .collect::<Vec<_>>();
                    (name_str, args, kwargs)
                }
                _ => unreachable!("call_heap_callable: not a MethodCaller"),
            };
            callable.drop_with_heap(self.heap);

            let kwargs_values = if stored_kwargs.is_empty() {
                KwargsValues::Empty
            } else {
                match Dict::from_pairs(stored_kwargs, self.heap, self.interns) {
                    Ok(dict) => KwargsValues::Dict(dict),
                    Err(err) => {
                        for arg in stored_args {
                            arg.drop_with_heap(self.heap);
                        }
                        obj.drop_with_heap(self.heap);
                        return Err(err);
                    }
                }
            };

            let call_args = if stored_args.is_empty() && matches!(kwargs_values, KwargsValues::Empty) {
                ArgValues::Empty
            } else if stored_args.is_empty() {
                ArgValues::Kwargs(kwargs_values)
            } else if matches!(kwargs_values, KwargsValues::Empty) {
                match stored_args.len() {
                    1 => ArgValues::One(stored_args.into_iter().next().expect("length checked")),
                    2 => {
                        let mut iter = stored_args.into_iter();
                        ArgValues::Two(
                            iter.next().expect("length checked"),
                            iter.next().expect("length checked"),
                        )
                    }
                    _ => ArgValues::ArgsKargs {
                        args: stored_args,
                        kwargs: kwargs_values,
                    },
                }
            } else {
                ArgValues::ArgsKargs {
                    args: stored_args,
                    kwargs: kwargs_values,
                }
            };

            if let Some(name_id) = name_value.string_id() {
                return self.call_attr(obj, name_id, call_args);
            }

            let attr_result = self.getattr_dynamic_str(&obj, name_value.as_str(self.interns));
            obj.drop_with_heap(self.heap);
            match attr_result {
                Ok(AttrCallResult::Value(method)) => return self.call_function(method, call_args),
                Ok(_) => {
                    call_args.drop_with_heap(self.heap);
                    return Err(RunError::internal("methodcaller returned non-value result"));
                }
                Err(err) => {
                    call_args.drop_with_heap(self.heap);
                    return Err(err);
                }
            }
        }

        // Check if this is a PropertyAccessor (@prop.setter / @prop.deleter / @prop.getter)
        if matches!(self.heap.get(heap_id), HeapData::PropertyAccessor(_)) {
            return self.call_property_accessor(heap_id, callable, args);
        }

        // Phase 1: Copy data (func_id, cells, defaults) without refcount changes
        let (func_id, cells, defaults) = match self.heap.get(heap_id) {
            HeapData::Closure(fid, cells, defaults) => {
                let cloned_cells = cells.clone();
                let cloned_defaults: Vec<Value> = defaults.iter().map(Value::copy_for_extend).collect();
                (*fid, cloned_cells, cloned_defaults)
            }
            HeapData::FunctionDefaults(fid, defaults) => {
                let cloned_defaults: Vec<Value> = defaults.iter().map(Value::copy_for_extend).collect();
                (*fid, Vec::new(), cloned_defaults)
            }
            _ => {
                callable.drop_with_heap(self.heap);
                args.drop_with_heap(self.heap);
                return Err(ExcType::type_error("object is not callable"));
            }
        };

        // Phase 2: Increment refcounts now that the heap borrow has ended
        for &cell_id in &cells {
            self.heap.inc_ref(cell_id);
        }
        for default in &defaults {
            if let Value::Ref(id) = default {
                self.heap.inc_ref(*id);
            }
        }

        // Drop the callable ref (cloned data has its own refcounts)
        callable.drop_with_heap(self.heap);

        // Call the defined function
        self.call_def_function(func_id, &cells, defaults, args)
    }

    /// Collects live direct subclasses for `type.__subclasses__()`.
    ///
    /// Prunes stale registry entries (freed or reused heap slots) to keep the
    /// subclass list accurate without holding strong references.
    fn collect_class_subclasses(&mut self, class_id: HeapId) -> RunResult<Vec<Value>> {
        let mut results = Vec::new();
        self.heap.with_entry_mut(class_id, |heap, data| {
            let HeapData::ClassObject(cls) = data else {
                return Err(ExcType::type_error(
                    "type.__subclasses__ called on non-class".to_string(),
                ));
            };

            let mut fresh: Vec<crate::types::SubclassEntry> = Vec::new();
            for entry in cls.subclasses() {
                let subclass_id = entry.class_id();
                let Some(HeapData::ClassObject(sub_cls)) = heap.get_if_live(subclass_id) else {
                    continue;
                };
                if sub_cls.class_uid() != entry.class_uid() {
                    continue;
                }
                heap.inc_ref(subclass_id);
                results.push(Value::Ref(subclass_id));
                fresh.push(*entry);
            }

            cls.set_subclasses(fresh);
            Ok(())
        })?;
        Ok(results)
    }

    /// Instantiates a class by creating an Instance and calling `__init__`.
    ///
    /// 1. Creates a new Instance on the heap referencing the ClassObject
    /// 2. Looks up `__init__` in the class namespace
    /// 3. If found, calls it with (instance, *args) and marks the frame
    ///    so that the instance is returned instead of `__init__`'s None return
    /// 4. If not found and args are provided, raises TypeError
    /// 5. If not found and no args, returns the instance directly
    fn call_class_instantiate(
        &mut self,
        class_heap_id: HeapId,
        callable: Value,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        // Look up __new__ and __init__ via MRO.
        let new_name_id: StringId = StaticStrings::DunderNew.into();
        let init_name_id: StringId = StaticStrings::DunderInit.into();
        let new_name = self.interns.get_str(new_name_id);
        let init_name = self.interns.get_str(init_name_id);

        let (new_info, init_info, class_name, is_abstract) = match self.heap.get(class_heap_id) {
            HeapData::ClassObject(cls) => {
                let new_val = cls
                    .mro_lookup_attr(new_name, class_heap_id, self.heap, self.interns)
                    .map(|(v, _)| v);
                let init_val = cls
                    .mro_lookup_attr(init_name, class_heap_id, self.heap, self.interns)
                    .map(|(v, _)| v);
                let is_abstract = matches!(
                    cls.namespace()
                        .get_by_str(crate::modules::abc::ABC_IS_ABSTRACT_ATTR, self.heap, self.interns),
                    Some(Value::Bool(true))
                );
                (new_val, init_val, cls.name(self.interns).to_string(), is_abstract)
            }
            _ => unreachable!("call_class_instantiate: not a ClassObject"),
        };

        // Drop the callable ref (we've copied what we need)
        callable.drop_with_heap(self.heap);

        if is_abstract {
            args.drop_with_heap(self.heap);
            return Err(ExcType::type_error(format!(
                "Can't instantiate abstract class {class_name}"
            )));
        }

        // If the class defines __new__, call it first.
        // __new__ receives (cls, *args) and returns the new instance (or any value).
        if let Some(new_func) = new_info {
            // Collect original positional args into a Vec for reuse.
            // Clone each value for the __new__ call, keeping originals for __init__.
            let (orig_pos_args, orig_kwargs) = args.into_parts();
            let orig_pos: Vec<Value> = orig_pos_args.collect();
            let new_kwargs = match self.clone_kwargs_values(&orig_kwargs) {
                Ok(kwargs) => kwargs,
                Err(e) => {
                    for value in orig_pos {
                        value.drop_with_heap(self.heap);
                    }
                    orig_kwargs.drop_with_heap(self.heap);
                    return Err(e);
                }
            };

            // Build __new__ args: (cls, *cloned_args)
            self.heap.inc_ref(class_heap_id);
            let mut new_arg_list = vec![Value::Ref(class_heap_id)];
            for v in &orig_pos {
                new_arg_list.push(v.clone_with_heap(self.heap));
            }
            let new_args = ArgValues::ArgsKargs {
                args: new_arg_list,
                kwargs: new_kwargs,
            };

            // Rebuild original args from the collected positional values
            let init_args = if orig_pos.is_empty() && orig_kwargs.is_empty() {
                ArgValues::Empty
            } else {
                ArgValues::ArgsKargs {
                    args: orig_pos,
                    kwargs: orig_kwargs,
                }
            };

            let result = self.call_function(new_func, new_args)?;

            match result {
                CallResult::Push(new_result) => {
                    // __new__ completed synchronously -- check result and maybe call __init__
                    return self.handle_new_result(new_result, class_heap_id, init_info, init_args);
                }
                CallResult::FramePushed => {
                    // __new__ pushed a frame -- stash state so we can call __init__ on return
                    self.pending_new_call = Some(PendingNewCall {
                        class_heap_id,
                        init_func: init_info,
                        args: init_args,
                    });
                    return Ok(CallResult::FramePushed);
                }
                other => {
                    if let Some(init_func) = init_info {
                        init_func.drop_with_heap(self.heap);
                    }
                    return Ok(other);
                }
            }
        }

        // No __new__ -- use the standard path: create instance, call __init__.
        let instance_value = self.allocate_instance_for_class(class_heap_id)?;
        let Value::Ref(instance_heap_id) = instance_value else {
            unreachable!("allocate_instance_for_class must return heap ref");
        };

        if let Some(init_func) = init_info {
            // __init__ exists - call it with (instance, *args).
            self.heap.inc_ref(instance_heap_id);
            let init_self_arg = Value::Ref(instance_heap_id);

            // Prepend self to args
            let new_args = match args {
                ArgValues::Empty => ArgValues::One(init_self_arg),
                ArgValues::One(a) => ArgValues::Two(init_self_arg, a),
                ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                    args: vec![init_self_arg, a, b],
                    kwargs: KwargsValues::Empty,
                },
                ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                    args: vec![init_self_arg],
                    kwargs: kw,
                },
                ArgValues::ArgsKargs { mut args, kwargs } => {
                    args.insert(0, init_self_arg);
                    ArgValues::ArgsKargs { args, kwargs }
                }
            };

            let mut instance_guard = HeapGuard::new(instance_value, self);
            // Call __init__ with a guard so the instance is dropped on error paths.
            let result = {
                let this = instance_guard.heap();
                this.call_function(init_func, new_args)?
            };

            let instance_value = instance_guard.into_inner();
            match result {
                CallResult::Push(value) => {
                    // __init__ returned synchronously
                    value.drop_with_heap(self.heap);
                    Ok(CallResult::Push(instance_value))
                }
                CallResult::FramePushed => {
                    // __init__ pushed a frame - mark it so we return the instance
                    self.current_frame_mut().init_instance = Some(instance_value);
                    Ok(CallResult::FramePushed)
                }
                CallResult::External(ext_id, ext_args) => {
                    instance_value.drop_with_heap(self.heap);
                    Ok(CallResult::External(ext_id, ext_args))
                }
                CallResult::OsCall(os_func, os_args) => {
                    instance_value.drop_with_heap(self.heap);
                    Ok(CallResult::OsCall(os_func, os_args))
                }
            }
        } else {
            // No __init__ - check that no arguments were passed
            if !matches!(args, ArgValues::Empty) {
                args.drop_with_heap(self.heap);
                instance_value.drop_with_heap(self.heap);
                let class_name = match self.heap.get(class_heap_id) {
                    HeapData::ClassObject(cls) => cls.name(self.interns).to_string(),
                    _ => "object".to_string(),
                };
                return Err(ExcType::type_error(format!("{class_name}() takes no arguments")));
            }
            Ok(CallResult::Push(instance_value))
        }
    }

    /// Clones keyword arguments with proper refcount handling.
    ///
    /// This is used when a call needs to reuse kwargs across multiple invocations
    /// (e.g., `__new__` and `__init__`).
    fn clone_kwargs_values(&mut self, kwargs: &KwargsValues) -> RunResult<KwargsValues> {
        match kwargs {
            KwargsValues::Empty => Ok(KwargsValues::Empty),
            KwargsValues::Inline(pairs) => {
                let mut out = Vec::with_capacity(pairs.len());
                for (key, value) in pairs {
                    out.push((*key, value.clone_with_heap(self.heap)));
                }
                Ok(KwargsValues::Inline(out))
            }
            KwargsValues::Dict(dict) => Ok(KwargsValues::Dict(dict.clone_with_heap(self.heap, self.interns)?)),
        }
    }

    /// Allocates a new instance for a class, honoring `__slots__` layout.
    fn allocate_instance_for_class(&mut self, class_heap_id: HeapId) -> RunResult<Value> {
        let (slot_len, has_dict, _has_weakref) = match self.heap.get(class_heap_id) {
            HeapData::ClassObject(cls) => (
                cls.slot_layout().len(),
                cls.instance_has_dict(),
                cls.instance_has_weakref(),
            ),
            _ => return Err(ExcType::type_error("object is not a class".to_string())),
        };

        self.heap.inc_ref(class_heap_id);
        let attrs_id = if has_dict {
            Some(self.heap.allocate(HeapData::Dict(Dict::new()))?)
        } else {
            None
        };
        let mut slot_values = Vec::with_capacity(slot_len);
        slot_values.resize_with(slot_len, || Value::Undefined);
        let weakref_ids = Vec::new();
        let instance = Instance::new(class_heap_id, attrs_id, slot_values, weakref_ids);
        let instance_heap_id = self.heap.allocate(HeapData::Instance(instance))?;
        Ok(Value::Ref(instance_heap_id))
    }

    /// Handles the result of a `__new__` call.
    ///
    /// If the result is an instance of the target class and `__init__` exists,
    /// calls `__init__` on the result. Otherwise, returns the result directly.
    pub(super) fn handle_new_result(
        &mut self,
        new_result: Value,
        class_heap_id: HeapId,
        init_info: Option<Value>,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        // Check if the result is an instance of the class.
        // If __new__ returned a non-instance or an instance of a different class,
        // we skip __init__.
        let is_instance_of_class = if let Value::Ref(result_id) = &new_result {
            match self.heap.get(*result_id) {
                HeapData::Instance(inst) => inst.class_id() == class_heap_id,
                _ => false,
            }
        } else {
            false
        };

        if is_instance_of_class {
            if let Some(init_func) = init_info {
                // Call __init__ on the instance returned by __new__
                let instance_id = match &new_result {
                    Value::Ref(id) => *id,
                    _ => unreachable!(),
                };
                self.heap.inc_ref(instance_id);
                let init_self_arg = Value::Ref(instance_id);

                let new_args = match args {
                    ArgValues::Empty => ArgValues::One(init_self_arg),
                    ArgValues::One(a) => ArgValues::Two(init_self_arg, a),
                    ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                        args: vec![init_self_arg, a, b],
                        kwargs: KwargsValues::Empty,
                    },
                    ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                        args: vec![init_self_arg],
                        kwargs: kw,
                    },
                    ArgValues::ArgsKargs { mut args, kwargs } => {
                        args.insert(0, init_self_arg);
                        ArgValues::ArgsKargs { args, kwargs }
                    }
                };

                let mut new_result_guard = HeapGuard::new(new_result, self);
                let result = {
                    let this = new_result_guard.heap();
                    this.call_function(init_func, new_args)?
                };
                let new_result = new_result_guard.into_inner();

                match result {
                    CallResult::Push(value) => {
                        value.drop_with_heap(self.heap);
                        Ok(CallResult::Push(new_result))
                    }
                    CallResult::FramePushed => {
                        self.current_frame_mut().init_instance = Some(new_result);
                        Ok(CallResult::FramePushed)
                    }
                    CallResult::External(ext_id, ext_args) => {
                        new_result.drop_with_heap(self.heap);
                        Ok(CallResult::External(ext_id, ext_args))
                    }
                    CallResult::OsCall(os_func, os_args) => {
                        new_result.drop_with_heap(self.heap);
                        Ok(CallResult::OsCall(os_func, os_args))
                    }
                }
            } else {
                // No __init__ -- return the instance from __new__
                args.drop_with_heap(self.heap);
                Ok(CallResult::Push(new_result))
            }
        } else {
            // __new__ returned a non-instance or different class -- skip __init__
            if let Some(init_func) = init_info {
                init_func.drop_with_heap(self.heap);
            }
            args.drop_with_heap(self.heap);
            Ok(CallResult::Push(new_result))
        }
    }

    /// Calls a PropertyAccessor, creating a new UserProperty with the appropriate
    /// function slot replaced.
    ///
    /// For `@prop.setter`, calling the accessor with a function creates a new property
    /// that inherits the original getter/deleter but uses the new function as setter.
    fn call_property_accessor(
        &mut self,
        accessor_heap_id: HeapId,
        callable: Value,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        // Get the function argument (the decorated function)
        let ArgValues::One(new_func) = args else {
            args.drop_with_heap(self.heap);
            callable.drop_with_heap(self.heap);
            return Err(ExcType::type_error("property accessor takes exactly 1 argument"));
        };

        // Phase 1: Extract data from the accessor without heap mutation
        let (kind, fget, fset, fdel) = match self.heap.get(accessor_heap_id) {
            HeapData::PropertyAccessor(acc) => {
                let (fg, fs, fd) = acc.parts();
                (
                    acc.kind(),
                    fg.map(Value::copy_for_extend),
                    fs.map(Value::copy_for_extend),
                    fd.map(Value::copy_for_extend),
                )
            }
            _ => unreachable!("call_property_accessor: not a PropertyAccessor"),
        };

        // Phase 2: Increment refcounts for the copied values
        if let Some(Value::Ref(id)) = &fget {
            self.heap.inc_ref(*id);
        }
        if let Some(Value::Ref(id)) = &fset {
            self.heap.inc_ref(*id);
        }
        if let Some(Value::Ref(id)) = &fdel {
            self.heap.inc_ref(*id);
        }

        // Drop the accessor callable (we've copied what we need)
        callable.drop_with_heap(self.heap);

        // Create a new UserProperty with the appropriate slot replaced
        let new_property = match kind {
            PropertyAccessorKind::Getter => {
                // Replace fget with new_func, drop old fget
                if let Some(old) = fget {
                    old.drop_with_heap(self.heap);
                }
                UserProperty::new(Some(new_func))
            }
            PropertyAccessorKind::Setter => {
                // Replace fset with new_func, drop old fset
                if let Some(old) = fset {
                    old.drop_with_heap(self.heap);
                }
                UserProperty::with_setter(fget, new_func)
            }
            PropertyAccessorKind::Deleter => {
                // Replace fdel with new_func, drop old fdel
                if let Some(old) = fdel {
                    old.drop_with_heap(self.heap);
                }
                UserProperty::with_deleter(fget, fset, new_func)
            }
        };

        let prop_id = self.heap.allocate(HeapData::UserProperty(new_property))?;
        Ok(CallResult::Push(Value::Ref(prop_id)))
    }

    /// Implements `super()` with no arguments (PEP 3135).
    ///
    /// Uses the `__class__` cell from the current frame to build a `SuperProxy`
    /// that delegates attribute lookup to the next class in the MRO.
    fn call_super(&mut self, args: ArgValues) -> Result<Value, RunError> {
        // super() takes no arguments in the zero-argument form
        if !matches!(args, ArgValues::Empty) {
            args.drop_with_heap(self.heap);
            return Err(ExcType::type_error(
                "super() with arguments is not supported; use super() with no arguments".to_string(),
            ));
        }

        if let Some((instance_id, defining_class_id)) = self.super_context_from_classcell()? {
            self.heap.inc_ref(instance_id);
            self.heap.inc_ref(defining_class_id);

            let proxy = crate::types::SuperProxy::new(instance_id, defining_class_id);
            let heap_id = self.heap.allocate(HeapData::SuperProxy(proxy))?;
            return Ok(Value::Ref(heap_id));
        }
        Err(ExcType::type_error("super(): __class__ cell not found".to_string()))
    }

    /// Attempts to resolve zero-argument super() context from the `__class__` cell.
    ///
    /// Returns `(instance_id, defining_class_id)` when the current frame has a
    /// `__class__` cell and a valid first local (`self`/`cls`).
    fn super_context_from_classcell(&mut self) -> Result<Option<(HeapId, HeapId)>, RunError> {
        let (class_cell_id, namespace_idx) = {
            let frame = self.current_frame();
            if frame.class_body_info.is_some() || frame.function_id.is_none() {
                return Ok(None);
            }

            let class_name_id: StringId = StaticStrings::DunderClass.into();
            let mut class_cell_id = None;
            for (idx, cell_id) in frame.cells.iter().enumerate() {
                let slot = u16::try_from(idx).expect("cell index exceeds u16");
                if frame.code.local_name(slot) == Some(class_name_id) {
                    class_cell_id = Some(*cell_id);
                    break;
                }
            }

            let Some(class_cell_id) = class_cell_id else {
                return Ok(None);
            };

            (class_cell_id, frame.namespace_idx)
        };

        let class_val = self.heap.get_cell_value(class_cell_id);
        let class_id = match class_val {
            Value::Ref(id) => {
                class_val.drop_with_heap(self.heap);
                id
            }
            other => {
                other.drop_with_heap(self.heap);
                return Err(ExcType::type_error(
                    "super(): __class__ cell is not a class".to_string(),
                ));
            }
        };

        if !matches!(self.heap.get(class_id), HeapData::ClassObject(_)) {
            return Err(ExcType::type_error(
                "super(): __class__ cell is not a class".to_string(),
            ));
        }

        let namespace = self.namespaces.get(namespace_idx);
        let first_local = namespace.get(crate::namespace::NamespaceId::new(0));
        let instance_id = match first_local {
            Value::Ref(id) if matches!(self.heap.get(*id), HeapData::Instance(_) | HeapData::ClassObject(_)) => *id,
            _ => return Err(ExcType::type_error("super(): __self__ is not an instance".to_string())),
        };

        Ok(Some((instance_id, class_id)))
    }

    /// Extracts a string from a Value (for getattr/setattr/hasattr builtin name argument).
    ///
    /// Returns the string content. Works with InternString values and heap Str values.
    fn extract_attr_name_str(&self, name_val: &Value) -> Result<String, RunError> {
        match name_val {
            Value::InternString(sid) => Ok(self.interns.get_str(*sid).to_owned()),
            Value::Ref(id) => match self.heap.get(*id) {
                HeapData::Str(s) => Ok(s.as_str().to_owned()),
                _ => Err(ExcType::type_error("attribute name must be string".to_string())),
            },
            _ => Err(ExcType::type_error("attribute name must be string".to_string())),
        }
    }

    /// Tries to convert a string to a StringId via StaticStrings lookup.
    ///
    /// Returns Some(StringId) if the name matches a known static string, None otherwise.
    fn try_static_string_id(name: &str) -> Option<StringId> {
        StaticStrings::from_str(name).ok().map(std::convert::Into::into)
    }

    /// Implementation of `getattr(obj, name[, default])` builtin.
    ///
    /// Gets an attribute by dynamic string name. Handles both static (interned)
    /// and dynamic (heap) attribute names.
    fn builtin_getattr(&mut self, args: ArgValues) -> Result<Value, RunError> {
        let (obj, name_val, default) = match args {
            ArgValues::Two(a, b) => (a, b, None),
            ArgValues::ArgsKargs { mut args, kwargs } => {
                kwargs.drop_with_heap(self.heap);
                if args.len() == 3 {
                    let c = args.remove(2);
                    let b = args.remove(1);
                    let a = args.remove(0);
                    (a, b, Some(c))
                } else if args.len() == 2 {
                    let b = args.remove(1);
                    let a = args.remove(0);
                    (a, b, None)
                } else {
                    for arg in args {
                        arg.drop_with_heap(self.heap);
                    }
                    return Err(ExcType::type_error("getattr expected 2 or 3 arguments".to_string()));
                }
            }
            other => {
                other.drop_with_heap(self.heap);
                return Err(ExcType::type_error("getattr expected 2 or 3 arguments".to_string()));
            }
        };

        let attr_name = match self.extract_attr_name_str(&name_val) {
            Ok(s) => s,
            Err(e) => {
                obj.drop_with_heap(self.heap);
                name_val.drop_with_heap(self.heap);
                if let Some(d) = default {
                    d.drop_with_heap(self.heap);
                }
                return Err(e);
            }
        };

        // Try static string path first
        let result = if let Some(sid) = Self::try_static_string_id(&attr_name) {
            obj.py_getattr(sid, self.heap, self.interns)
        } else {
            // Dynamic string: do Instance/ClassObject string-based lookup
            self.getattr_dynamic_str(&obj, &attr_name)
        };

        name_val.drop_with_heap(self.heap);
        obj.drop_with_heap(self.heap);

        match result {
            Ok(AttrCallResult::Value(val)) => {
                if let Some(d) = default {
                    d.drop_with_heap(self.heap);
                }
                Ok(val)
            }
            Ok(AttrCallResult::DescriptorGet(descriptor)) => {
                if let Some(d) = default {
                    d.drop_with_heap(self.heap);
                }
                // For getattr with a descriptor, call descriptor.__get__(None, None)
                // since obj has already been dropped.
                let get_id: StringId = StaticStrings::DunderDescGet.into();
                if let Value::Ref(desc_id) = &descriptor {
                    let desc_id = *desc_id;
                    if let Some(method) = self.lookup_type_dunder(desc_id, get_id) {
                        self.heap.inc_ref(desc_id);
                        let args = ArgValues::ArgsKargs {
                            args: vec![Value::Ref(desc_id), Value::None, Value::None],
                            kwargs: KwargsValues::Empty,
                        };
                        descriptor.drop_with_heap(self.heap);
                        let result = self.call_function(method, args)?;
                        return match result {
                            CallResult::Push(val) => Ok(val),
                            _ => Ok(Value::None),
                        };
                    }
                }
                // No __get__ found, return descriptor itself
                Ok(descriptor)
            }
            Ok(
                AttrCallResult::ExternalCall(_, _)
                | AttrCallResult::OsCall(_, _)
                | AttrCallResult::PropertyCall(_, _)
                | AttrCallResult::ReduceCall(_, _, _)
                | AttrCallResult::CallFunction(_, _),
            ) => {
                if let Some(d) = default {
                    d.drop_with_heap(self.heap);
                }
                // External/OS/Property/Reduce calls are not expected from getattr - treat as found
                Ok(Value::None)
            }
            Err(_) if default.is_some() => Ok(default.expect("checked above")),
            Err(e) => {
                if let Some(d) = default {
                    d.drop_with_heap(self.heap);
                }
                Err(e)
            }
        }
    }

    /// Gets an attribute by dynamic (non-interned) string name.
    ///
    /// Performs string-based lookup in Instance attrs and class MRO.
    fn getattr_dynamic_str(&mut self, obj: &Value, name: &str) -> Result<AttrCallResult, RunError> {
        if let Value::Ref(heap_id) = obj {
            let heap_id = *heap_id;
            let interns = self.interns;
            match self.heap.get(heap_id) {
                HeapData::Instance(_) => {
                    // Use with_entry_mut to safely borrow instance + heap
                    let result: Result<Option<Value>, RunError> = self.heap.with_entry_mut(heap_id, |heap, data| {
                        if let HeapData::Instance(inst) = data {
                            if name == "__dict__" {
                                let has_dict = match heap.get(inst.class_id()) {
                                    HeapData::ClassObject(cls) => cls.instance_has_dict(),
                                    _ => false,
                                };
                                if !has_dict {
                                    let class_name = match heap.get(inst.class_id()) {
                                        HeapData::ClassObject(cls) => cls.name(interns).to_string(),
                                        _ => "<unknown>".to_string(),
                                    };
                                    return Err(ExcType::attribute_error(format!("'{class_name}' object"), "__dict__"));
                                }
                                let Some(attrs_id) = inst.attrs_id() else {
                                    return Err(ExcType::attribute_error("instance", "__dict__"));
                                };
                                heap.inc_ref(attrs_id);
                                return Ok(Some(Value::Ref(attrs_id)));
                            }
                            // 1. Instance attrs
                            if let Some(dict) = inst.attrs(heap)
                                && let Some(value) = dict.get_by_str(name, heap, interns)
                            {
                                return Ok(Some(value.clone_with_heap(heap)));
                            }
                            // 2. Instance slots
                            if let Some(value) = inst.slot_value(name, heap) {
                                return Ok(Some(value.clone_with_heap(heap)));
                            }
                            // 3. Class MRO lookup
                            let class_id = inst.class_id();
                            if let HeapData::ClassObject(cls) = heap.get(class_id)
                                && let Some((value, _)) = cls.mro_lookup_attr(name, class_id, heap, interns)
                            {
                                return Ok(Some(value));
                            }
                            Ok(None)
                        } else {
                            Ok(None)
                        }
                    });
                    match result? {
                        Some(value) => Ok(AttrCallResult::Value(value)),
                        None => Err(ExcType::attribute_error(Type::Instance, name)),
                    }
                }
                HeapData::ClassObject(_) => {
                    let result: Result<Option<Value>, RunError> = self.heap.with_entry_mut(heap_id, |heap, data| {
                        if let HeapData::ClassObject(cls) = data {
                            if name == "__dict__" {
                                heap.inc_ref(heap_id);
                                let proxy_id =
                                    heap.allocate(HeapData::MappingProxy(crate::types::MappingProxy::new(heap_id)))?;
                                return Ok(Some(Value::Ref(proxy_id)));
                            }
                            if let Some(value) = cls.namespace().get_by_str(name, heap, interns) {
                                Ok(Some(value.clone_with_heap(heap)))
                            } else {
                                Ok(None)
                            }
                        } else {
                            Ok(None)
                        }
                    });
                    match result? {
                        Some(value) => Ok(AttrCallResult::Value(value)),
                        None => Err(ExcType::attribute_error(Type::Type, name)),
                    }
                }
                _ => {
                    let type_name = self.heap.get(heap_id).py_type(self.heap);
                    Err(ExcType::attribute_error(type_name, name))
                }
            }
        } else {
            let type_name = obj.py_type(self.heap);
            Err(ExcType::attribute_error(type_name, name))
        }
    }

    /// Implementation of `setattr(obj, name, value)` builtin.
    ///
    /// Sets an attribute by dynamic string name.
    fn builtin_setattr(&mut self, args: ArgValues) -> Result<Value, RunError> {
        // Extract 3 arguments (3+ args become ArgsKargs)
        let (obj, name_val, value) = match args {
            ArgValues::ArgsKargs { mut args, kwargs } => {
                kwargs.drop_with_heap(self.heap);
                if args.len() == 3 {
                    let c = args.remove(2);
                    let b = args.remove(1);
                    let a = args.remove(0);
                    (a, b, c)
                } else {
                    for arg in args {
                        arg.drop_with_heap(self.heap);
                    }
                    return Err(ExcType::type_error("setattr expected 3 arguments".to_string()));
                }
            }
            other => {
                other.drop_with_heap(self.heap);
                return Err(ExcType::type_error("setattr expected 3 arguments".to_string()));
            }
        };

        let attr_name = match self.extract_attr_name_str(&name_val) {
            Ok(s) => s,
            Err(e) => {
                obj.drop_with_heap(self.heap);
                name_val.drop_with_heap(self.heap);
                value.drop_with_heap(self.heap);
                return Err(e);
            }
        };
        name_val.drop_with_heap(self.heap);

        // Try static string path first
        if let Some(sid) = Self::try_static_string_id(&attr_name) {
            obj.py_set_attr(sid, value, self.heap, self.interns)?;
        } else {
            // Dynamic string: create heap Str key
            self.setattr_dynamic_str(&obj, &attr_name, value)?;
        }
        obj.drop_with_heap(self.heap);
        Ok(Value::None)
    }

    /// Sets an attribute by dynamic (non-interned) string name.
    fn setattr_dynamic_str(&mut self, obj: &Value, name: &str, value: Value) -> Result<(), RunError> {
        if let Value::Ref(heap_id) = obj {
            let heap_id = *heap_id;
            let is_instance = matches!(self.heap.get(heap_id), HeapData::Instance(_));
            let is_class = matches!(self.heap.get(heap_id), HeapData::ClassObject(_));
            let interns = self.interns;

            if is_instance || is_class {
                let key_id = self
                    .heap
                    .allocate(HeapData::Str(crate::types::Str::from(name.to_owned())))?;
                let name_value = Value::Ref(key_id);
                self.heap.with_entry_mut(heap_id, |heap, data| {
                    if let HeapData::Instance(inst) = data {
                        match inst.set_attr(name_value, value, heap, interns) {
                            Ok(old) => {
                                if let Some(old) = old {
                                    old.drop_with_heap(heap);
                                }
                                Ok(())
                            }
                            Err(e) => Err(e),
                        }
                    } else if let HeapData::ClassObject(cls) = data {
                        match cls.set_attr(name_value, value, heap, interns) {
                            Ok(old) => {
                                if let Some(old) = old {
                                    old.drop_with_heap(heap);
                                }
                                Ok(())
                            }
                            Err(e) => Err(e),
                        }
                    } else {
                        unreachable!("type changed during borrow")
                    }
                })
            } else {
                let type_name = self.heap.get(heap_id).py_type(self.heap);
                value.drop_with_heap(self.heap);
                Err(ExcType::attribute_error_no_setattr(type_name, name))
            }
        } else {
            let type_name = obj.py_type(self.heap);
            value.drop_with_heap(self.heap);
            Err(ExcType::attribute_error_no_setattr(type_name, name))
        }
    }

    /// Implementation of `hasattr(obj, name)` builtin.
    ///
    /// Returns True if the object has the named attribute, False otherwise.
    fn builtin_hasattr(&mut self, args: ArgValues) -> Result<Value, RunError> {
        let (obj, name_val) = args.get_two_args("hasattr", self.heap)?;

        let attr_name = match self.extract_attr_name_str(&name_val) {
            Ok(s) => s,
            Err(e) => {
                obj.drop_with_heap(self.heap);
                name_val.drop_with_heap(self.heap);
                return Err(e);
            }
        };
        name_val.drop_with_heap(self.heap);

        let result = if let Some(sid) = Self::try_static_string_id(&attr_name) {
            obj.py_getattr(sid, self.heap, self.interns)
        } else {
            self.getattr_dynamic_str(&obj, &attr_name)
        };

        obj.drop_with_heap(self.heap);

        match result {
            Ok(AttrCallResult::Value(val)) => {
                val.drop_with_heap(self.heap);
                Ok(Value::Bool(true))
            }
            Ok(AttrCallResult::DescriptorGet(desc)) => {
                desc.drop_with_heap(self.heap);
                Ok(Value::Bool(true))
            }
            Ok(_) => Ok(Value::Bool(true)),
            Err(_) => Ok(Value::Bool(false)),
        }
    }

    /// Calls a function with unpacked args tuple and optional kwargs dict.
    ///
    /// Used for `f(*args)` and `f(**kwargs)` style calls.
    fn call_function_extended(
        &mut self,
        callable: Value,
        args_tuple: Value,
        kwargs: Option<Value>,
    ) -> Result<CallResult, RunError> {
        // Extract positional args from tuple
        let copied_args = self.extract_args_tuple(&args_tuple);

        // Increment refcounts for positional args
        for arg in &copied_args {
            if let Value::Ref(id) = arg {
                self.heap.inc_ref(*id);
            }
        }

        // Build ArgValues from positional args and optional kwargs
        let args = if let Some(kwargs_ref) = kwargs {
            self.build_args_with_kwargs(copied_args, kwargs_ref)?
        } else {
            Self::build_args_positional_only(copied_args)
        };

        // Clean up the args tuple ref (we cloned the contents)
        args_tuple.drop_with_heap(self.heap);

        // Call the function
        self.call_function(callable, args)
    }

    /// Calls a method with unpacked args tuple and optional kwargs dict.
    ///
    /// Used for `obj.method(*args)` and `obj.method(**kwargs)` style calls.
    fn call_attr_extended(
        &mut self,
        obj: Value,
        name_id: StringId,
        args_tuple: Value,
        kwargs: Option<Value>,
    ) -> Result<CallResult, RunError> {
        // Extract positional args from tuple
        let copied_args = self.extract_args_tuple_for_attr(&args_tuple);

        // Increment refcounts for positional args
        for arg in &copied_args {
            if let Value::Ref(id) = arg {
                self.heap.inc_ref(*id);
            }
        }

        // Build ArgValues from positional args and optional kwargs
        let args = if let Some(kwargs_ref) = kwargs {
            self.build_args_with_kwargs_for_attr(copied_args, kwargs_ref)?
        } else {
            Self::build_args_positional_only(copied_args)
        };

        // Clean up the args tuple ref (we cloned the contents)
        args_tuple.drop_with_heap(self.heap);

        // Call the method
        self.call_attr(obj, name_id, args)
    }

    /// Extracts arguments from a tuple for `CallFunctionExtended`.
    ///
    /// # Panics
    /// Panics if `args_tuple` is not a tuple. This indicates a compiler bug since
    /// the compiler always emits `ListToTuple` before `CallFunctionExtended`.
    fn extract_args_tuple(&mut self, args_tuple: &Value) -> Vec<Value> {
        let Value::Ref(id) = args_tuple else {
            unreachable!("CallFunctionExtended: args_tuple must be a Ref")
        };
        let HeapData::Tuple(tuple) = self.heap.get(*id) else {
            unreachable!("CallFunctionExtended: args_tuple must be a Tuple")
        };
        tuple.as_vec().iter().map(Value::copy_for_extend).collect()
    }

    /// Builds `ArgValues` with kwargs for `CallFunctionExtended`.
    ///
    /// # Panics
    /// Panics if `kwargs_ref` is not a dict. This indicates a compiler bug since
    /// the compiler always emits `BuildDict` before `CallFunctionExtended` with kwargs.
    fn build_args_with_kwargs(&mut self, copied_args: Vec<Value>, kwargs_ref: Value) -> Result<ArgValues, RunError> {
        // Extract kwargs dict items
        let Value::Ref(id) = &kwargs_ref else {
            unreachable!("CallFunctionExtended: kwargs must be a Ref")
        };
        let HeapData::Dict(dict) = self.heap.get(*id) else {
            unreachable!("CallFunctionExtended: kwargs must be a Dict")
        };
        let copied_kwargs: Vec<(Value, Value)> = dict
            .iter()
            .map(|(k, v)| (Value::copy_for_extend(k), Value::copy_for_extend(v)))
            .collect();

        // Increment refcounts for kwargs
        for (k, v) in &copied_kwargs {
            if let Value::Ref(id) = k {
                self.heap.inc_ref(*id);
            }
            if let Value::Ref(id) = v {
                self.heap.inc_ref(*id);
            }
        }

        // Clean up the kwargs dict ref
        kwargs_ref.drop_with_heap(self.heap);

        let kwargs_values = if copied_kwargs.is_empty() {
            KwargsValues::Empty
        } else {
            let kwargs_dict = Dict::from_pairs(copied_kwargs, self.heap, self.interns)?;
            KwargsValues::Dict(kwargs_dict)
        };

        Ok(
            if copied_args.is_empty() && matches!(kwargs_values, KwargsValues::Empty) {
                ArgValues::Empty
            } else if copied_args.is_empty() {
                ArgValues::Kwargs(kwargs_values)
            } else {
                ArgValues::ArgsKargs {
                    args: copied_args,
                    kwargs: kwargs_values,
                }
            },
        )
    }

    /// Builds `ArgValues` from positional args only.
    fn build_args_positional_only(copied_args: Vec<Value>) -> ArgValues {
        match copied_args.len() {
            0 => ArgValues::Empty,
            1 => ArgValues::One(copied_args.into_iter().next().unwrap()),
            2 => {
                let mut iter = copied_args.into_iter();
                ArgValues::Two(iter.next().unwrap(), iter.next().unwrap())
            }
            _ => ArgValues::ArgsKargs {
                args: copied_args,
                kwargs: KwargsValues::Empty,
            },
        }
    }

    /// Extracts arguments from a tuple for `CallAttrExtended`.
    ///
    /// # Panics
    /// Panics if `args_tuple` is not a tuple. This indicates a compiler bug since
    /// the compiler always emits `ListToTuple` before `CallAttrExtended`.
    fn extract_args_tuple_for_attr(&mut self, args_tuple: &Value) -> Vec<Value> {
        let Value::Ref(id) = args_tuple else {
            unreachable!("CallAttrExtended: args_tuple must be a Ref")
        };
        let HeapData::Tuple(tuple) = self.heap.get(*id) else {
            unreachable!("CallAttrExtended: args_tuple must be a Tuple")
        };
        tuple.as_vec().iter().map(Value::copy_for_extend).collect()
    }

    /// Builds `ArgValues` with kwargs for `CallAttrExtended`.
    ///
    /// # Panics
    /// Panics if `kwargs_ref` is not a dict. This indicates a compiler bug since
    /// the compiler always emits `BuildDict` before `CallAttrExtended` with kwargs.
    fn build_args_with_kwargs_for_attr(
        &mut self,
        copied_args: Vec<Value>,
        kwargs_ref: Value,
    ) -> Result<ArgValues, RunError> {
        // Extract kwargs dict items
        let Value::Ref(id) = &kwargs_ref else {
            unreachable!("CallAttrExtended: kwargs must be a Ref")
        };
        let HeapData::Dict(dict) = self.heap.get(*id) else {
            unreachable!("CallAttrExtended: kwargs must be a Dict")
        };
        let copied_kwargs: Vec<(Value, Value)> = dict
            .iter()
            .map(|(k, v)| (Value::copy_for_extend(k), Value::copy_for_extend(v)))
            .collect();

        // Increment refcounts for kwargs
        for (k, v) in &copied_kwargs {
            if let Value::Ref(id) = k {
                self.heap.inc_ref(*id);
            }
            if let Value::Ref(id) = v {
                self.heap.inc_ref(*id);
            }
        }

        // Clean up the kwargs dict ref
        kwargs_ref.drop_with_heap(self.heap);

        let kwargs_values = if copied_kwargs.is_empty() {
            KwargsValues::Empty
        } else {
            let kwargs_dict = Dict::from_pairs(copied_kwargs, self.heap, self.interns)?;
            KwargsValues::Dict(kwargs_dict)
        };

        Ok(
            if copied_args.is_empty() && matches!(kwargs_values, KwargsValues::Empty) {
                ArgValues::Empty
            } else if copied_args.is_empty() {
                ArgValues::Kwargs(kwargs_values)
            } else {
                ArgValues::ArgsKargs {
                    args: copied_args,
                    kwargs: kwargs_values,
                }
            },
        )
    }

    // ========================================================================
    // Frame Setup
    // ========================================================================

    /// Calls a defined function by pushing a new frame or creating a coroutine/generator.
    ///
    /// For sync functions: sets up the function's namespace with bound arguments,
    /// cell variables, and free variables, then pushes a new frame.
    ///
    /// For async functions: binds arguments immediately but returns a Coroutine
    /// instead of pushing a frame. The coroutine stores the pre-bound namespace
    /// and will be executed when awaited.
    ///
    /// For generator functions: binds arguments immediately but returns a Generator
    /// instead of pushing a frame. The generator stores the pre-bound namespace
    /// and will be executed when `__next__()` is called.
    fn call_def_function(
        &mut self,
        func_id: FunctionId,
        cells: &[HeapId],
        defaults: Vec<Value>,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        // Get function info (interns is a shared reference so no conflict)
        let func = self.interns.get_function(func_id);

        if func.is_async {
            // Async function: create a Coroutine instead of pushing a frame
            self.create_coroutine(func_id, cells, defaults, args)
        } else if func.is_generator {
            // Generator function: create a Generator instead of pushing a frame
            self.create_generator(func_id, cells, defaults, args)
        } else {
            // Sync function: push a new frame
            self.call_sync_function(func_id, cells, defaults, args)
        }
    }

    /// Creates a Coroutine for an async function call.
    ///
    /// Binds arguments immediately (errors are raised at call time, not await time)
    /// but stores the namespace in the Coroutine instead of registering it.
    /// The coroutine is executed when awaited via Await.
    fn create_coroutine(
        &mut self,
        func_id: FunctionId,
        cells: &[HeapId],
        defaults: Vec<Value>,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        let func = self.interns.get_function(func_id);

        // 1. Create namespace vector (not registered with Namespaces)
        let mut namespace = Vec::with_capacity(func.namespace_size);

        // 2. Bind arguments to parameters
        {
            let bind_result = func
                .signature
                .bind(args, &defaults, self.heap, self.interns, func.name, &mut namespace);

            if let Err(e) = bind_result {
                // Clean up namespace values on error
                for value in namespace {
                    value.drop_with_heap(self.heap);
                }
                for default in defaults {
                    default.drop_with_heap(self.heap);
                }
                return Err(e);
            }
        }

        // Clean up defaults - they were copied into the namespace by bind()
        for default in defaults {
            default.drop_with_heap(self.heap);
        }

        // Track created cell HeapIds for the coroutine
        let mut frame_cells: Vec<HeapId> = Vec::with_capacity(func.cell_var_count + cells.len());

        // 3. Create cells for variables captured by nested functions
        {
            let param_count = func.signature.total_slots();
            for (i, maybe_param_idx) in func.cell_param_indices.iter().enumerate() {
                let cell_slot = param_count + i;
                let cell_value = if let Some(param_idx) = maybe_param_idx {
                    namespace[*param_idx].clone_with_heap(self.heap)
                } else {
                    Value::Undefined
                };
                let cell_id = self.heap.allocate(HeapData::Cell(cell_value))?;
                frame_cells.push(cell_id);
                namespace.resize_with(cell_slot, || Value::Undefined);
                namespace.push(Value::Ref(cell_id));
            }

            // 4. Copy captured cells (free vars) into namespace
            let free_var_start = param_count + func.cell_var_count;
            for (i, &cell_id) in cells.iter().enumerate() {
                self.heap.inc_ref(cell_id);
                frame_cells.push(cell_id);
                let slot = free_var_start + i;
                namespace.resize_with(slot, || Value::Undefined);
                namespace.push(Value::Ref(cell_id));
            }

            // 5. Fill remaining slots with Undefined
            namespace.resize_with(func.namespace_size, || Value::Undefined);
        }

        // 6. Create Coroutine on heap
        let coroutine = Coroutine::new(func_id, namespace, frame_cells);
        let coroutine_id = self.heap.allocate(HeapData::Coroutine(coroutine))?;

        Ok(CallResult::Push(Value::Ref(coroutine_id)))
    }

    /// Creates a Generator for a generator function call.
    ///
    /// Binds arguments immediately (errors are raised at call time, not iteration time)
    /// but stores the namespace in the Generator instead of registering it.
    /// The generator is executed when `__next__()` is called.
    ///
    /// Follows the same pattern as `create_coroutine`:
    /// 1. Create namespace vector (not registered with Namespaces)
    /// 2. Bind arguments via `signature.bind()`
    /// 3. Create cells for captured variables
    /// 4. Copy captured cells into namespace
    /// 5. Fill remaining slots with `Undefined`
    /// 6. Create `Generator::new(func_id, namespace, frame_cells)` on heap
    fn create_generator(
        &mut self,
        func_id: FunctionId,
        cells: &[HeapId],
        defaults: Vec<Value>,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        use crate::types::Generator;

        let func = self.interns.get_function(func_id);

        // 1. Create namespace vector (not registered with Namespaces)
        let mut namespace = Vec::with_capacity(func.namespace_size);

        // 2. Bind arguments to parameters
        {
            let bind_result = func
                .signature
                .bind(args, &defaults, self.heap, self.interns, func.name, &mut namespace);

            if let Err(e) = bind_result {
                // Clean up namespace values on error
                for value in namespace {
                    value.drop_with_heap(self.heap);
                }
                for default in defaults {
                    default.drop_with_heap(self.heap);
                }
                return Err(e);
            }
        }

        // Clean up defaults - they were copied into the namespace by bind()
        for default in defaults {
            default.drop_with_heap(self.heap);
        }

        // Track created cell HeapIds for the generator
        let mut frame_cells: Vec<HeapId> = Vec::with_capacity(func.cell_var_count + cells.len());

        // 3. Create cells for variables captured by nested functions
        {
            let param_count = func.signature.total_slots();
            for (i, maybe_param_idx) in func.cell_param_indices.iter().enumerate() {
                let cell_slot = param_count + i;
                let cell_value = if let Some(param_idx) = maybe_param_idx {
                    namespace[*param_idx].clone_with_heap(self.heap)
                } else {
                    Value::Undefined
                };
                let cell_id = self.heap.allocate(HeapData::Cell(cell_value))?;
                frame_cells.push(cell_id);
                namespace.resize_with(cell_slot, || Value::Undefined);
                namespace.push(Value::Ref(cell_id));
            }

            // 4. Copy captured cells (free vars) into namespace
            let free_var_start = param_count + func.cell_var_count;
            for (i, &cell_id) in cells.iter().enumerate() {
                self.heap.inc_ref(cell_id);
                frame_cells.push(cell_id);
                let slot = free_var_start + i;
                namespace.resize_with(slot, || Value::Undefined);
                namespace.push(Value::Ref(cell_id));
            }

            // 5. Fill remaining slots with Undefined
            namespace.resize_with(func.namespace_size, || Value::Undefined);
        }

        // 6. Create Generator on heap
        let generator = Generator::new(func_id, namespace, frame_cells);
        let generator_id = self.heap.allocate(HeapData::Generator(generator))?;

        Ok(CallResult::Push(Value::Ref(generator_id)))
    }

    /// Calls a sync function by pushing a new frame.
    ///
    /// Sets up the function's namespace with bound arguments, cell variables,
    /// and free variables (captured from enclosing scope for closures).
    fn call_sync_function(
        &mut self,
        func_id: FunctionId,
        cells: &[HeapId],
        defaults: Vec<Value>,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        // Get call position BEFORE borrowing namespaces mutably
        let call_position = self.current_position();

        // Get function info (interns is a shared reference so no conflict)
        let func = self.interns.get_function(func_id);

        // 1. Create new namespace for function
        let namespace_idx = match self.namespaces.new_namespace(func.namespace_size, self.heap) {
            Ok(idx) => idx,
            Err(e) => {
                // Ensure args/defaults are cleaned up on early recursion/memory errors.
                args.drop_with_heap(self.heap);
                for default in defaults {
                    default.drop_with_heap(self.heap);
                }
                return Err(e.into());
            }
        };

        let namespace = self.namespaces.get_mut(namespace_idx).mut_vec();
        // 2. Bind arguments to parameters
        {
            let bind_result = func
                .signature
                .bind(args, &defaults, self.heap, self.interns, func.name, namespace);

            if let Err(e) = bind_result {
                self.namespaces.drop_with_heap(namespace_idx, self.heap);
                for default in defaults {
                    default.drop_with_heap(self.heap);
                }
                return Err(e);
            }
        }

        // Clean up defaults - they were copied into the namespace by bind()
        for default in defaults {
            default.drop_with_heap(self.heap);
        }

        // Track created cell HeapIds for the frame
        let mut frame_cells: Vec<HeapId> = Vec::with_capacity(func.cell_var_count + cells.len());

        // 3. Create cells for variables captured by nested functions
        {
            let param_count = func.signature.total_slots();
            for (i, maybe_param_idx) in func.cell_param_indices.iter().enumerate() {
                let cell_slot = param_count + i;
                let cell_value = if let Some(param_idx) = maybe_param_idx {
                    namespace[*param_idx].clone_with_heap(self.heap)
                } else {
                    Value::Undefined
                };
                let cell_id = self.heap.allocate(HeapData::Cell(cell_value))?;
                frame_cells.push(cell_id);
                namespace.resize_with(cell_slot, || Value::Undefined);
                namespace.push(Value::Ref(cell_id));
            }

            // 4. Copy captured cells (free vars) into namespace
            let free_var_start = param_count + func.cell_var_count;
            for (i, &cell_id) in cells.iter().enumerate() {
                self.heap.inc_ref(cell_id);
                frame_cells.push(cell_id);
                let slot = free_var_start + i;
                namespace.resize_with(slot, || Value::Undefined);
                namespace.push(Value::Ref(cell_id));
            }

            // 5. Fill remaining slots with Undefined
            namespace.resize_with(func.namespace_size, || Value::Undefined);
        }

        let code = &func.code;
        // 6. Push new frame
        self.frames.push(CallFrame::new_function(
            code,
            self.stack.len(),
            namespace_idx,
            func_id,
            frame_cells,
            Some(call_position),
        ));
        self.tracer
            .on_call(Some(self.interns.get_str(func.name.name_id)), self.frames.len());

        Ok(CallResult::FramePushed)
    }

    /// Calls a method on an Instance.
    ///
    /// Looks up the method in the instance's class namespace (instance attrs first,
    /// then class attrs). If the found attribute is a callable (function/closure),
    /// calls it with `self` (the instance) prepended to the arguments.
    fn call_instance_method(
        &mut self,
        instance_heap_id: HeapId,
        method_name_id: StringId,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        let method_name = self.interns.get_str(method_name_id);

        // Phase 1: Look up the method value with proper refcount handling.
        // Check instance attrs first, then class attrs.
        // We track where the value was found: instance attrs don't get auto-bound (no self
        // prepended), while class attrs do (they are unbound methods that need self).
        // This matches Python semantics: functions in instance.__dict__ are plain callables,
        // only functions found on the class are auto-bound as methods.
        let method_lookup: Result<Option<(Value, bool)>, _> =
            self.heap.with_entry_mut(instance_heap_id, |heap, data| {
                let HeapData::Instance(inst) = data else {
                    unreachable!("call_instance_method: not an Instance");
                };

                // 1. Check instance attributes (found_on_instance = true)
                if let Some(dict) = inst.attrs(heap)
                    && let Some(value) = dict.get_by_str(method_name, heap, self.interns)
                {
                    return Ok(Some((value.clone_with_heap(heap), true)));
                }
                if let Some(value) = inst.slot_value(method_name, heap) {
                    return Ok(Some((value.clone_with_heap(heap), true)));
                }

                // 2. Check class attributes via MRO (found_on_instance = false)
                match heap.get(inst.class_id()) {
                    HeapData::ClassObject(cls) => {
                        if let Some((value, _found_in)) =
                            cls.mro_lookup_attr(method_name, inst.class_id(), heap, self.interns)
                        {
                            Ok(Some((value, false)))
                        } else {
                            let class_name = cls.name(self.interns).to_string();
                            Err(ExcType::attribute_error(format!("'{class_name}' object"), method_name))
                        }
                    }
                    _ => Err(ExcType::attribute_error(Type::Instance, method_name)),
                }
            });

        let (method_value, found_on_instance) = match method_lookup {
            Ok(Some(v)) => v,
            Ok(None) => unreachable!("should not happen"),
            Err(e) => {
                // Note: the caller (call_attr) already dropped obj before calling us,
                // so we don't need to dec_ref the instance here.
                args.drop_with_heap(self.heap);
                return Err(e);
            }
        };

        // If found on instance dict, call directly without binding (no self prepend).
        // In Python, functions stored in instance.__dict__ are plain callables.
        if found_on_instance {
            return self.call_function(method_value, args);
        }

        // Phase 2: Found on class -- check for descriptor wrappers and unwrap if needed.
        // StaticMethod -> call inner func directly (no self/cls)
        // ClassMethod -> call inner func with cls as first arg
        // Other -> normal method call (prepend self)
        #[expect(clippy::items_after_statements)]
        /// Describes how a resolved instance attribute should be invoked.
        ///
        /// This captures the unwrapped callable and the binding strategy that
        /// matches Python's descriptor rules for instance lookups.
        enum InstanceCallKind {
            StaticMethod(Value), // Inner func, no self/cls
            ClassMethod(Value),  // Inner func, prepend cls
            Normal(Value),       // Regular method, prepend self
        }

        let call_kind = if let Value::Ref(ref_id) = &method_value {
            let ref_id = *ref_id;
            match self.heap.get(ref_id) {
                HeapData::StaticMethod(sm) => {
                    let func = sm.func().clone_with_heap(self.heap);
                    method_value.drop_with_heap(self.heap);
                    InstanceCallKind::StaticMethod(func)
                }
                HeapData::ClassMethod(cm) => {
                    let func = cm.func().clone_with_heap(self.heap);
                    method_value.drop_with_heap(self.heap);
                    InstanceCallKind::ClassMethod(func)
                }
                _ => InstanceCallKind::Normal(method_value),
            }
        } else {
            InstanceCallKind::Normal(method_value)
        };

        match call_kind {
            InstanceCallKind::StaticMethod(func) => {
                // StaticMethod: call the inner function directly, no self/cls
                self.call_function(func, args)
            }
            InstanceCallKind::ClassMethod(func) => {
                // ClassMethod: prepend the class as first arg (cls)
                // Get the class_id from the instance
                let class_id = match self.heap.get(instance_heap_id) {
                    HeapData::Instance(inst) => inst.class_id(),
                    _ => unreachable!(),
                };
                self.heap.inc_ref(class_id);
                let cls_arg = Value::Ref(class_id);
                let new_args = match args {
                    ArgValues::Empty => ArgValues::One(cls_arg),
                    ArgValues::One(a) => ArgValues::Two(cls_arg, a),
                    ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                        args: vec![cls_arg, a, b],
                        kwargs: KwargsValues::Empty,
                    },
                    ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                        args: vec![cls_arg],
                        kwargs: kw,
                    },
                    ArgValues::ArgsKargs { mut args, kwargs } => {
                        args.insert(0, cls_arg);
                        ArgValues::ArgsKargs { args, kwargs }
                    }
                };
                self.call_function(func, new_args)
            }
            InstanceCallKind::Normal(method_value) => {
                // Regular method: prepend instance as self argument.
                let is_callable = matches!(
                    method_value,
                    Value::DefFunction(_)
                        | Value::Ref(_)
                        | Value::Builtin(_)
                        | Value::ModuleFunction(_)
                        | Value::ExtFunction(_)
                );

                if is_callable {
                    self.heap.inc_ref(instance_heap_id);
                    let self_arg = Value::Ref(instance_heap_id);

                    let new_args = match args {
                        ArgValues::Empty => ArgValues::One(self_arg),
                        ArgValues::One(a) => ArgValues::Two(self_arg, a),
                        ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                            args: vec![self_arg, a, b],
                            kwargs: KwargsValues::Empty,
                        },
                        ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                            args: vec![self_arg],
                            kwargs: kw,
                        },
                        ArgValues::ArgsKargs { mut args, kwargs } => {
                            args.insert(0, self_arg);
                            ArgValues::ArgsKargs { args, kwargs }
                        }
                    };

                    self.call_function(method_value, new_args)
                } else {
                    // Not callable - report error.
                    args.drop_with_heap(self.heap);
                    method_value.drop_with_heap(self.heap);
                    Err(ExcType::type_error("attribute is not callable"))
                }
            }
        }
    }

    /// Calls a method on a class object.
    ///
    /// Looks up the attribute in the class namespace (with MRO), then:
    /// - StaticMethod: calls the inner function directly (no self/cls)
    /// - ClassMethod: calls the inner function with the class as first arg
    /// - Regular function: calls directly (no self prepended)
    fn call_class_method(
        &mut self,
        class_heap_id: HeapId,
        method_name_id: StringId,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        let method_name = self.interns.get_str(method_name_id);
        let interns = self.interns;

        // Phase 1: Look up the attribute and determine its descriptor type.
        #[expect(clippy::items_after_statements)]
        /// Descriptor outcome for a class-level attribute lookup.
        ///
        /// Used to decide whether to bind a classmethod, bypass a staticmethod,
        /// or call the value directly.
        enum DescriptorKind {
            StaticMethod(Value), // Inner function (no self/cls binding)
            ClassMethod(Value),  // Inner function (prepend cls)
            Regular(Value),      // Regular value (call directly)
        }

        let lookup_result = self.heap.with_entry_mut(class_heap_id, |heap, data| {
            let HeapData::ClassObject(cls) = data else {
                unreachable!("call_class_method: not a ClassObject");
            };

            // Look up in own namespace + MRO
            if let Some((value, _found_in)) = cls.mro_lookup_attr(method_name, class_heap_id, heap, interns) {
                // Check descriptor type
                if let Value::Ref(id) = &value {
                    let id = *id;
                    match heap.get(id) {
                        HeapData::StaticMethod(sm) => {
                            let func = sm.func().clone_with_heap(heap);
                            value.drop_with_heap(heap);
                            return Ok(DescriptorKind::StaticMethod(func));
                        }
                        HeapData::ClassMethod(cm) => {
                            let func = cm.func().clone_with_heap(heap);
                            value.drop_with_heap(heap);
                            return Ok(DescriptorKind::ClassMethod(func));
                        }
                        _ => {}
                    }
                }
                Ok(DescriptorKind::Regular(value))
            } else {
                let class_name = cls.name(interns).to_string();
                Err(ExcType::attribute_error(
                    format!("type object '{class_name}'"),
                    method_name,
                ))
            }
        });

        let descriptor = match lookup_result {
            Ok(d) => d,
            Err(e) => {
                args.drop_with_heap(self.heap);
                return Err(e);
            }
        };

        // Phase 2: Call the resolved descriptor
        match descriptor {
            DescriptorKind::StaticMethod(func) => {
                // StaticMethod: call the inner function directly, no self/cls
                self.call_function(func, args)
            }
            DescriptorKind::ClassMethod(func) => {
                // ClassMethod: prepend the class as first arg (cls)
                self.heap.inc_ref(class_heap_id);
                let cls_arg = Value::Ref(class_heap_id);
                let new_args = match args {
                    ArgValues::Empty => ArgValues::One(cls_arg),
                    ArgValues::One(a) => ArgValues::Two(cls_arg, a),
                    ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                        args: vec![cls_arg, a, b],
                        kwargs: KwargsValues::Empty,
                    },
                    ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                        args: vec![cls_arg],
                        kwargs: kw,
                    },
                    ArgValues::ArgsKargs { mut args, kwargs } => {
                        args.insert(0, cls_arg);
                        ArgValues::ArgsKargs { args, kwargs }
                    }
                };
                self.call_function(func, new_args)
            }
            DescriptorKind::Regular(value) => {
                // Regular function: call directly
                self.call_function(value, args)
            }
        }
    }

    /// Calls a method via super() MRO lookup.
    ///
    /// Looks up the method starting from the next class after `current_class_id`
    /// in the instance's MRO, then calls it with the instance as `self`.
    fn call_super_method_with_ids(
        &mut self,
        instance_id: HeapId,
        current_class_id: HeapId,
        method_name_id: StringId,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        let method_name = self.interns.get_str(method_name_id);

        // Get the MRO to search. If instance_id is an Instance, use its class's MRO.
        // If instance_id is a ClassObject (super() inside __new__), use its own MRO.
        let instance_class_id = match self.heap.get(instance_id) {
            HeapData::Instance(inst) => inst.class_id(),
            HeapData::ClassObject(_) => instance_id, // super() in __new__: cls IS the class
            _ => {
                args.drop_with_heap(self.heap);
                return Err(ExcType::type_error("super(): __self__ is not an instance".to_string()));
            }
        };

        let mro = if let HeapData::ClassObject(cls) = self.heap.get(instance_class_id) {
            cls.mro().to_vec()
        } else {
            args.drop_with_heap(self.heap);
            return Err(ExcType::type_error("super(): class has no MRO".to_string()));
        };

        // Find current_class_id in MRO, start searching after it
        let start_idx = mro.iter().position(|&id| id == current_class_id).map_or(0, |i| i + 1);

        // Search for method in classes after current_class_id
        let mut method_value = None;
        for &class_id in &mro[start_idx..] {
            if let HeapData::ClassObject(cls) = self.heap.get(class_id)
                && let Some(value) = cls.namespace().get_by_str(method_name, self.heap, self.interns)
            {
                method_value = Some(value.clone_with_heap(self.heap));
                break;
            }
        }

        #[expect(clippy::manual_let_else)]
        let method_value = if let Some(v) = method_value {
            v
        } else {
            // Special case: super().__new__(cls) -- if __new__ is not found in the
            // remaining MRO, treat it as object.__new__(cls) which creates a bare instance.
            let new_id: StringId = StaticStrings::DunderNew.into();
            if method_name_id == new_id {
                // object.__new__(cls) semantics: create a bare instance of the given class.
                // The first arg is the class to instantiate.
                let target_class_id = match &args {
                    ArgValues::One(Value::Ref(id)) => Some(*id),
                    _ => None,
                };
                if let Some(cls_id) = target_class_id
                    && matches!(self.heap.get(cls_id), HeapData::ClassObject(_))
                {
                    args.drop_with_heap(self.heap);
                    let instance_value = self.allocate_instance_for_class(cls_id)?;
                    return Ok(CallResult::Push(instance_value));
                }
                args.drop_with_heap(self.heap);
                return Err(ExcType::type_error("object.__new__(X): X is not a type object"));
            }
            args.drop_with_heap(self.heap);
            return Err(ExcType::attribute_error("super", method_name));
        };

        // Prepend instance as self argument
        self.heap.inc_ref(instance_id);
        let self_arg = Value::Ref(instance_id);

        let new_args = match args {
            ArgValues::Empty => ArgValues::One(self_arg),
            ArgValues::One(a) => ArgValues::Two(self_arg, a),
            ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                args: vec![self_arg, a, b],
                kwargs: KwargsValues::Empty,
            },
            ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                args: vec![self_arg],
                kwargs: kw,
            },
            ArgValues::ArgsKargs { mut args, kwargs } => {
                args.insert(0, self_arg);
                ArgValues::ArgsKargs { args, kwargs }
            }
        };

        self.call_function(method_value, new_args)
    }

    // ========================================================================
    // Dunder Protocol Dispatch
    // ========================================================================

    /// Looks up a dunder method on an instance's TYPE (not the instance itself).
    ///
    /// This implements the Python semantic that dunder methods are looked up on the
    /// type, not the instance. For example, `type(x).__add__(x, y)` not `x.__add__(y)`.
    ///
    /// Returns `Some(method_value)` if found, `None` if not found.
    /// The returned value is cloned with proper refcount handling if it's a Ref.
    pub(super) fn lookup_type_dunder(&mut self, instance_heap_id: HeapId, dunder_name_id: StringId) -> Option<Value> {
        let dunder_name = self.interns.get_str(dunder_name_id);

        // Get the class_id from the instance
        let class_id = match self.heap.get(instance_heap_id) {
            HeapData::Instance(inst) => inst.class_id(),
            _ => return None,
        };

        // Look up in the class namespace via MRO (NOT instance attrs)
        match self.heap.get(class_id) {
            HeapData::ClassObject(cls) => cls
                .mro_lookup_attr(dunder_name, class_id, self.heap, self.interns)
                .map(|(v, _found_in)| v),
            _ => None,
        }
    }

    /// Looks up a dunder method on a class object's METACLASS.
    ///
    /// Used for metaclass hooks like `__getattribute__`, `__getattr__`,
    /// `__instancecheck__`, and `__subclasscheck__`.
    pub(super) fn lookup_metaclass_dunder(&mut self, class_heap_id: HeapId, dunder_name_id: StringId) -> Option<Value> {
        let dunder_name = self.interns.get_str(dunder_name_id);

        let HeapData::ClassObject(class_obj) = self.heap.get(class_heap_id) else {
            return None;
        };

        let metaclass_val = class_obj.metaclass();
        let meta_id = match metaclass_val {
            Value::Ref(id) => *id,
            _ => return None,
        };

        match self.heap.get(meta_id) {
            HeapData::ClassObject(meta_cls) => meta_cls
                .mro_lookup_attr(dunder_name, meta_id, self.heap, self.interns)
                .map(|(v, _)| v),
            _ => None,
        }
    }

    /// Returns whether a class has typing's private `_is_protocol` marker in its MRO.
    fn class_has_protocol_marker(&mut self, class_heap_id: HeapId) -> bool {
        self.class_has_typing_marker(class_heap_id, "_is_protocol")
            || self.class_has_typing_marker(class_heap_id, "_is_runtime_protocol")
    }

    /// Returns whether a class has a given typing marker set to True in its MRO.
    fn class_has_typing_marker(&mut self, class_heap_id: HeapId, marker_name: &str) -> bool {
        let Some(value) = (match self.heap.get(class_heap_id) {
            HeapData::ClassObject(cls) => {
                if let Some(v) = cls.namespace().get_by_str(marker_name, self.heap, self.interns) {
                    Some(v.clone_with_heap(self.heap))
                } else {
                    cls.mro_lookup_attr(marker_name, class_heap_id, self.heap, self.interns)
                        .map(|(v, _)| v)
                }
            }
            _ => None,
        }) else {
            return false;
        };

        let has_marker = matches!(value, Value::Bool(true));
        value.drop_with_heap(self.heap);
        has_marker
    }

    /// Calls a dunder method on an instance with given args.
    ///
    /// Prepends the instance as `self` argument, increments instance refcount.
    /// Returns `CallResult` which may be `FramePushed` for user-defined methods.
    pub(super) fn call_dunder(
        &mut self,
        instance_heap_id: HeapId,
        method_value: Value,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        // Increment instance refcount for the self argument
        self.heap.inc_ref(instance_heap_id);
        let self_arg = Value::Ref(instance_heap_id);

        let new_args = match args {
            ArgValues::Empty => ArgValues::One(self_arg),
            ArgValues::One(a) => ArgValues::Two(self_arg, a),
            ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                args: vec![self_arg, a, b],
                kwargs: KwargsValues::Empty,
            },
            ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                args: vec![self_arg],
                kwargs: kw,
            },
            ArgValues::ArgsKargs { mut args, kwargs } => {
                args.insert(0, self_arg);
                ArgValues::ArgsKargs { args, kwargs }
            }
        };

        self.call_function(method_value, new_args)
    }

    /// Calls a dunder method on a class object, prepending the class as `self`.
    ///
    /// This is used for metaclass hooks like `__prepare__`, `__mro_entries__`,
    /// `__instancecheck__`, and `__subclasscheck__`, where the class object itself
    /// is the receiver.
    pub(super) fn call_class_dunder(
        &mut self,
        class_heap_id: HeapId,
        method_value: Value,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        self.heap.inc_ref(class_heap_id);
        let cls_arg = Value::Ref(class_heap_id);
        let new_args = match args {
            ArgValues::Empty => ArgValues::One(cls_arg),
            ArgValues::One(a) => ArgValues::Two(cls_arg, a),
            ArgValues::Two(a, b) => ArgValues::ArgsKargs {
                args: vec![cls_arg, a, b],
                kwargs: KwargsValues::Empty,
            },
            ArgValues::Kwargs(kw) => ArgValues::ArgsKargs {
                args: vec![cls_arg],
                kwargs: kw,
            },
            ArgValues::ArgsKargs { mut args, kwargs } => {
                args.insert(0, cls_arg);
                ArgValues::ArgsKargs { args, kwargs }
            }
        };
        self.call_function(method_value, new_args)
    }

    /// Executes a binary dunder operation: tries `lhs.__op__(rhs)`, then `rhs.__rop__(lhs)`.
    ///
    /// Returns `Ok(Some(CallResult))` if a dunder was found and called,
    /// `Ok(None)` if neither operand has the dunder.
    ///
    /// Handles the NotImplemented protocol: if `__op__` returns NotImplemented,
    /// falls through to try `__rop__`.
    pub(super) fn try_binary_dunder(
        &mut self,
        lhs: &Value,
        rhs: &Value,
        dunder_id: StringId,
        reflected_dunder_id: Option<StringId>,
    ) -> Result<Option<CallResult>, RunError> {
        // Try lhs.__op__(rhs) - look up on TYPE, not instance
        if let Value::Ref(lhs_id) = lhs
            && matches!(self.heap.get(*lhs_id), HeapData::Instance(_))
            && let Some(method) = self.lookup_type_dunder(*lhs_id, dunder_id)
        {
            // Clone rhs for the call arg
            let rhs_clone = rhs.clone_with_heap(self.heap);
            let result = self.call_dunder(*lhs_id, method, ArgValues::One(rhs_clone))?;
            return Ok(Some(result));
        }

        // Try rhs.__rop__(lhs) if provided
        if let Some(ref_dunder_id) = reflected_dunder_id
            && let Value::Ref(rhs_id) = rhs
            && matches!(self.heap.get(*rhs_id), HeapData::Instance(_))
            && let Some(method) = self.lookup_type_dunder(*rhs_id, ref_dunder_id)
        {
            // Clone lhs for the call arg
            let lhs_clone = lhs.clone_with_heap(self.heap);
            let result = self.call_dunder(*rhs_id, method, ArgValues::One(lhs_clone))?;
            return Ok(Some(result));
        }

        Ok(None)
    }

    /// Executes an in-place dunder operation: tries `lhs.__iop__(rhs)`, falls back to `lhs.__op__(rhs)`.
    ///
    /// Returns `Ok(Some(CallResult))` if a dunder was found and called,
    /// `Ok(None)` if the instance has no relevant dunder.
    pub(super) fn try_inplace_dunder(
        &mut self,
        lhs: &Value,
        rhs: &Value,
        inplace_dunder_id: StringId,
        dunder_id: StringId,
        reflected_dunder_id: Option<StringId>,
    ) -> Result<Option<CallResult>, RunError> {
        // Try lhs.__iop__(rhs) first
        if let Value::Ref(lhs_id) = lhs
            && matches!(self.heap.get(*lhs_id), HeapData::Instance(_))
            && let Some(method) = self.lookup_type_dunder(*lhs_id, inplace_dunder_id)
        {
            let rhs_clone = rhs.clone_with_heap(self.heap);
            let result = self.call_dunder(*lhs_id, method, ArgValues::One(rhs_clone))?;
            return Ok(Some(result));
        }

        // Fall back to binary dunder
        self.try_binary_dunder(lhs, rhs, dunder_id, reflected_dunder_id)
    }

    /// Executes a unary dunder operation: tries `operand.__op__()`.
    ///
    /// Returns `Ok(Some(CallResult))` if the dunder was found and called,
    /// `Ok(None)` if the instance has no such dunder.
    pub(super) fn try_unary_dunder(
        &mut self,
        operand: &Value,
        dunder_id: StringId,
    ) -> Result<Option<CallResult>, RunError> {
        if let Value::Ref(id) = operand
            && matches!(self.heap.get(*id), HeapData::Instance(_))
            && let Some(method) = self.lookup_type_dunder(*id, dunder_id)
        {
            let result = self.call_dunder(*id, method, ArgValues::Empty)?;
            return Ok(Some(result));
        }
        Ok(None)
    }

    /// Handles attribute calls on singledispatch dispatchers (`register`, `dispatch`).
    fn call_singledispatch_attr(
        &mut self,
        target_id: HeapId,
        name_id: StringId,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        let dispatcher_id = match self.heap.get(target_id) {
            HeapData::SingleDispatch(_) => target_id,
            HeapData::SingleDispatchMethod(method) => {
                if let Value::Ref(id) = &method.dispatcher {
                    *id
                } else {
                    args.drop_with_heap(self.heap);
                    return Err(RunError::internal(
                        "singledispatchmethod dispatcher was not a heap reference",
                    ));
                }
            }
            _ => {
                args.drop_with_heap(self.heap);
                return Err(RunError::internal(
                    "call_singledispatch_attr called on non-singledispatch object",
                ));
            }
        };

        let method_name = self.interns.get_str(name_id);
        match method_name {
            "register" => {
                let (mut positional, kwargs) = args.into_parts();
                if !kwargs.is_empty() {
                    positional.drop_with_heap(self.heap);
                    kwargs.drop_with_heap(self.heap);
                    return Err(ExcType::type_error("register() takes no keyword arguments"));
                }

                let Some(cls) = positional.next() else {
                    positional.drop_with_heap(self.heap);
                    return Err(ExcType::type_error("register expected at least 1 argument, got 0"));
                };

                if let Some(func) = positional.next() {
                    if let Some(extra) = positional.next() {
                        extra.drop_with_heap(self.heap);
                        positional.drop_with_heap(self.heap);
                        cls.drop_with_heap(self.heap);
                        func.drop_with_heap(self.heap);
                        return Err(ExcType::type_error("register expected at most 2 arguments, got 3"));
                    }
                    let func_for_registry = func.clone_with_heap(self.heap);
                    self.heap.inc_ref(dispatcher_id);
                    self.singledispatch_register(Value::Ref(dispatcher_id), cls, func_for_registry)?;
                    return Ok(CallResult::Push(func));
                }

                self.heap.inc_ref(dispatcher_id);
                let wrapper = crate::types::SingleDispatchRegister::new(Value::Ref(dispatcher_id), cls);
                let wrapper_id = self.heap.allocate(HeapData::SingleDispatchRegister(wrapper))?;
                Ok(CallResult::Push(Value::Ref(wrapper_id)))
            }
            "dispatch" => {
                let cls = args.get_one_arg("dispatch", self.heap)?;
                let dispatched = self.singledispatch_lookup_impl_for_class(dispatcher_id, &cls)?;
                cls.drop_with_heap(self.heap);
                Ok(CallResult::Push(dispatched))
            }
            _ => {
                args.drop_with_heap(self.heap);
                Err(ExcType::attribute_error(Type::Function, method_name))
            }
        }
    }

    /// Dispatches and calls a singledispatch callable.
    fn call_singledispatch_callable(
        &mut self,
        dispatcher_id: HeapId,
        callable: Value,
        args: ArgValues,
    ) -> Result<CallResult, RunError> {
        let dispatch_index = if let HeapData::SingleDispatch(dispatcher) = self.heap.get(dispatcher_id) {
            dispatcher.dispatch_index
        } else {
            callable.drop_with_heap(self.heap);
            args.drop_with_heap(self.heap);
            return Err(RunError::internal("dispatcher id did not reference SingleDispatch"));
        };

        let Some(dispatch_arg) = get_arg_at(&args, dispatch_index) else {
            callable.drop_with_heap(self.heap);
            args.drop_with_heap(self.heap);
            return Err(ExcType::type_error(format!(
                "singledispatch function requires at least {} positional arguments",
                dispatch_index + 1
            )));
        };

        let impl_func = self.singledispatch_lookup_impl_for_value(dispatcher_id, dispatch_arg)?;
        callable.drop_with_heap(self.heap);
        self.call_function(impl_func, args)
    }

    /// Registers an implementation for a dispatcher/type-key pair.
    fn singledispatch_register(&mut self, dispatcher: Value, cls: Value, func: Value) -> Result<(), RunError> {
        let Value::Ref(dispatcher_id) = dispatcher else {
            cls.drop_with_heap(self.heap);
            func.drop_with_heap(self.heap);
            return Err(RunError::internal("dispatcher was not a heap object"));
        };

        let is_valid_key = matches!(cls, Value::Builtin(Builtins::Type(_) | Builtins::ExcType(_)))
            || matches!(&cls, Value::Ref(id) if matches!(self.heap.get(*id), HeapData::ClassObject(_)));
        if !is_valid_key {
            cls.drop_with_heap(self.heap);
            func.drop_with_heap(self.heap);
            dispatcher.drop_with_heap(self.heap);
            return Err(ExcType::type_error(
                "singledispatch register() expects a class/type key",
            ));
        }

        self.heap.with_entry_mut(dispatcher_id, |heap, data| {
            let HeapData::SingleDispatch(dispatcher) = data else {
                cls.drop_with_heap(heap);
                func.drop_with_heap(heap);
                return Err(RunError::internal(
                    "singledispatch register target mutated to non-dispatcher",
                ));
            };
            dispatcher.registry.push((cls, func));
            Ok(())
        })?;
        dispatcher.drop_with_heap(self.heap);
        Ok(())
    }

    /// Finds the implementation for a runtime dispatch value.
    fn singledispatch_lookup_impl_for_value(
        &mut self,
        dispatcher_id: HeapId,
        dispatch_value: &Value,
    ) -> Result<Value, RunError> {
        let (default_func, registry_entries) = match self.heap.get(dispatcher_id) {
            HeapData::SingleDispatch(dispatcher) => (
                dispatcher.func.clone_with_heap(self.heap),
                dispatcher
                    .registry
                    .iter()
                    .map(|(cls, func)| (cls.clone_with_heap(self.heap), func.clone_with_heap(self.heap)))
                    .collect::<Vec<_>>(),
            ),
            _ => return Err(RunError::internal("dispatcher id did not reference SingleDispatch")),
        };

        let mut entries = registry_entries.into_iter().rev();
        while let Some((cls, func)) = entries.next() {
            let is_match = self.singledispatch_key_matches_value(&cls, dispatch_value)?;
            cls.drop_with_heap(self.heap);
            if is_match {
                for (remaining_cls, remaining_func) in entries {
                    remaining_cls.drop_with_heap(self.heap);
                    remaining_func.drop_with_heap(self.heap);
                }
                default_func.drop_with_heap(self.heap);
                return Ok(func);
            }
            func.drop_with_heap(self.heap);
        }

        Ok(default_func)
    }

    /// Finds the implementation for `dispatcher.dispatch(cls)`.
    fn singledispatch_lookup_impl_for_class(
        &mut self,
        dispatcher_id: HeapId,
        cls_value: &Value,
    ) -> Result<Value, RunError> {
        let (default_func, registry_entries) = match self.heap.get(dispatcher_id) {
            HeapData::SingleDispatch(dispatcher) => (
                dispatcher.func.clone_with_heap(self.heap),
                dispatcher
                    .registry
                    .iter()
                    .map(|(cls, func)| (cls.clone_with_heap(self.heap), func.clone_with_heap(self.heap)))
                    .collect::<Vec<_>>(),
            ),
            _ => return Err(RunError::internal("dispatcher id did not reference SingleDispatch")),
        };

        let mut entries = registry_entries.into_iter().rev();
        while let Some((registered_cls, func)) = entries.next() {
            let is_match = self.singledispatch_class_matches(&registered_cls, cls_value);
            registered_cls.drop_with_heap(self.heap);
            if is_match {
                for (remaining_cls, remaining_func) in entries {
                    remaining_cls.drop_with_heap(self.heap);
                    remaining_func.drop_with_heap(self.heap);
                }
                default_func.drop_with_heap(self.heap);
                return Ok(func);
            }
            func.drop_with_heap(self.heap);
        }

        Ok(default_func)
    }

    /// Checks whether a registered dispatch key matches a runtime argument value.
    fn singledispatch_key_matches_value(&mut self, key: &Value, value: &Value) -> Result<bool, RunError> {
        match key {
            Value::Builtin(Builtins::Type(expected_type)) => {
                let builtin_id = self.heap.builtin_class_id(*expected_type)?;
                if let Value::Ref(value_id) = value {
                    match self.heap.get(*value_id) {
                        HeapData::Instance(inst) => {
                            let instance_class_id = inst.class_id();
                            if let HeapData::ClassObject(cls_obj) = self.heap.get(instance_class_id) {
                                return Ok(cls_obj.is_subclass_of(instance_class_id, builtin_id));
                            }
                        }
                        HeapData::ClassObject(cls_obj) => {
                            return Ok(cls_obj.is_subclass_of(*value_id, builtin_id));
                        }
                        _ => {}
                    }
                }
                Ok(value.py_type(self.heap).is_instance_of(*expected_type))
            }
            Value::Builtin(Builtins::ExcType(expected_exc)) => Ok(matches!(
                value.py_type(self.heap),
                Type::Exception(actual_exc) if actual_exc.is_subclass_of(*expected_exc)
            )),
            Value::Ref(expected_class_id) if matches!(self.heap.get(*expected_class_id), HeapData::ClassObject(_)) => {
                if let Value::Ref(value_id) = value {
                    match self.heap.get(*value_id) {
                        HeapData::Instance(inst) => {
                            let instance_class_id = inst.class_id();
                            if let HeapData::ClassObject(cls_obj) = self.heap.get(instance_class_id) {
                                return Ok(cls_obj.is_subclass_of(instance_class_id, *expected_class_id));
                            }
                        }
                        HeapData::ClassObject(cls_obj) => {
                            return Ok(cls_obj.is_subclass_of(*value_id, *expected_class_id));
                        }
                        _ => {}
                    }
                }
                Ok(false)
            }
            _ => Ok(false),
        }
    }

    /// Checks whether a registered key matches an explicit class key for `dispatch()`.
    fn singledispatch_class_matches(&mut self, registered: &Value, queried: &Value) -> bool {
        match (registered, queried) {
            (Value::Builtin(Builtins::Type(expected)), Value::Builtin(Builtins::Type(actual))) => {
                actual.is_instance_of(*expected)
            }
            (Value::Builtin(Builtins::ExcType(expected)), Value::Builtin(Builtins::ExcType(actual))) => {
                actual.is_subclass_of(*expected)
            }
            (Value::Ref(expected_id), Value::Ref(actual_id))
                if matches!(self.heap.get(*expected_id), HeapData::ClassObject(_))
                    && matches!(self.heap.get(*actual_id), HeapData::ClassObject(_)) =>
            {
                if let HeapData::ClassObject(actual_cls) = self.heap.get(*actual_id) {
                    actual_cls.is_subclass_of(*actual_id, *expected_id)
                } else {
                    false
                }
            }
            _ => false,
        }
    }
}

/// Builds the final argument list for a `functools.partial` invocation.
///
/// Applies Python 3.14 `Placeholder` substitution for positional arguments,
/// then appends remaining call-site positionals and merges keyword arguments
/// (call-site kwargs override pre-applied kwargs).
fn build_partial_call_args(
    partial_args: Vec<Value>,
    partial_kwargs: Vec<(Value, Value)>,
    args: ArgValues,
    heap: &mut Heap<impl ResourceTracker>,
    interns: &Interns,
) -> Result<ArgValues, RunError> {
    let (positional, kwargs) = args.into_parts();
    let mut call_positional: Vec<Value> = positional.collect();
    let call_positional_len = call_positional.len();
    let mut call_iter = call_positional.drain(..);
    let mut final_positional: Vec<Value> = Vec::with_capacity(partial_args.len() + call_positional_len);

    for template_arg in partial_args {
        if is_partial_placeholder(&template_arg, heap) {
            template_arg.drop_with_heap(heap);
            let Some(next_arg) = call_iter.next() else {
                for arg in call_iter {
                    arg.drop_with_heap(heap);
                }
                for (key, value) in partial_kwargs {
                    key.drop_with_heap(heap);
                    value.drop_with_heap(heap);
                }
                kwargs.drop_with_heap(heap);
                return Err(ExcType::type_error(
                    "functools.partial missing positional arguments for Placeholder",
                ));
            };
            final_positional.push(next_arg);
        } else {
            final_positional.push(template_arg);
        }
    }
    final_positional.extend(call_iter);

    let mut merged_kwargs = partial_kwargs;
    merged_kwargs.extend(kwargs);

    let kwargs_values = if merged_kwargs.is_empty() {
        KwargsValues::Empty
    } else {
        KwargsValues::Dict(Dict::from_pairs(merged_kwargs, heap, interns)?)
    };

    Ok(build_arg_values(final_positional, kwargs_values))
}

/// Converts positional and keyword vectors into the most compact `ArgValues` representation.
fn build_arg_values(positional: Vec<Value>, kwargs: KwargsValues) -> ArgValues {
    if positional.is_empty() {
        if kwargs.is_empty() {
            ArgValues::Empty
        } else {
            ArgValues::Kwargs(kwargs)
        }
    } else if kwargs.is_empty() {
        match positional.len() {
            1 => ArgValues::One(positional.into_iter().next().expect("length checked")),
            2 => {
                let mut iter = positional.into_iter();
                ArgValues::Two(
                    iter.next().expect("length checked"),
                    iter.next().expect("length checked"),
                )
            }
            _ => ArgValues::ArgsKargs {
                args: positional,
                kwargs: KwargsValues::Empty,
            },
        }
    } else {
        ArgValues::ArgsKargs {
            args: positional,
            kwargs,
        }
    }
}

/// Returns true when a value is the `functools.Placeholder` singleton.
fn is_partial_placeholder(value: &Value, heap: &Heap<impl ResourceTracker>) -> bool {
    matches!(value, Value::Ref(id) if matches!(heap.get(*id), HeapData::Placeholder(_)))
}

/// Returns a positional argument by index from an `ArgValues`.
fn get_arg_at(args: &ArgValues, index: usize) -> Option<&Value> {
    match args {
        ArgValues::Empty | ArgValues::Kwargs(_) => None,
        ArgValues::One(a) => {
            if index == 0 {
                Some(a)
            } else {
                None
            }
        }
        ArgValues::Two(a, b) => match index {
            0 => Some(a),
            1 => Some(b),
            _ => None,
        },
        ArgValues::ArgsKargs { args, .. } => args.get(index),
    }
}

/// Dispatches a classmethod call on a type object.
///
/// Handles classmethods like `dict.fromkeys()` and `bytes.fromhex()` that are
/// called on the type itself rather than on an instance.
fn call_type_method(
    t: Type,
    method_id: StringId,
    args: ArgValues,
    heap: &mut Heap<impl ResourceTracker>,
    interns: &Interns,
) -> Result<Value, RunError> {
    match (t, method_id) {
        (Type::Dict, m) if m == StaticStrings::Fromkeys => return dict_fromkeys(args, heap, interns),
        (Type::Bytes, m) if m == StaticStrings::Fromhex => return bytes_fromhex(args, heap, interns),
        (Type::Str, m) if interns.get_str(m) == "maketrans" => return str_maketrans(args, heap, interns),
        _ => {}
    }
    // Other types or unknown methods - report actual type name, not 'type'
    args.drop_with_heap(heap);
    Err(ExcType::attribute_error(t, interns.get_str(method_id)))
}
