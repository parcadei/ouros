from collections.abc import Awaitable, Generator
from typing import Any, Literal, TypeAlias, TypeVar, overload

_T = TypeVar('_T')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')
_T3 = TypeVar('_T3')
_T4 = TypeVar('_T4')
_T5 = TypeVar('_T5')
_T6 = TypeVar('_T6')

class _Future(Awaitable[_T]):
    """
    Minimal copy of Future from _typeshed/stdlib/_asyncio.pyi
    """
    def __iter__(self) -> Generator[Any, None, _T]: ...
    def __await__(self) -> Generator[Any, None, _T]: ...

_FutureLike: TypeAlias = _Future[_T] | Awaitable[_T]

@overload
def gather(
    coro_or_future1: _FutureLike[_T1], /, *, return_exceptions: Literal[False] = False
) -> _Future[tuple[_T1]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    /,
    *,
    return_exceptions: Literal[False] = False,
) -> _Future[tuple[_T1, _T2]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    coro_or_future3: _FutureLike[_T3],
    /,
    *,
    return_exceptions: Literal[False] = False,
) -> _Future[tuple[_T1, _T2, _T3]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    coro_or_future3: _FutureLike[_T3],
    coro_or_future4: _FutureLike[_T4],
    /,
    *,
    return_exceptions: Literal[False] = False,
) -> _Future[tuple[_T1, _T2, _T3, _T4]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    coro_or_future3: _FutureLike[_T3],
    coro_or_future4: _FutureLike[_T4],
    coro_or_future5: _FutureLike[_T5],
    /,
    *,
    return_exceptions: Literal[False] = False,
) -> _Future[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    coro_or_future3: _FutureLike[_T3],
    coro_or_future4: _FutureLike[_T4],
    coro_or_future5: _FutureLike[_T5],
    coro_or_future6: _FutureLike[_T6],
    /,
    *,
    return_exceptions: Literal[False] = False,
) -> _Future[tuple[_T1, _T2, _T3, _T4, _T5, _T6]]: ...
@overload
def gather(*coros_or_futures: _FutureLike[_T], return_exceptions: Literal[False] = False) -> _Future[list[_T]]: ...
@overload
def gather(coro_or_future1: _FutureLike[_T1], /, *, return_exceptions: bool) -> _Future[tuple[_T1 | BaseException]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1], coro_or_future2: _FutureLike[_T2], /, *, return_exceptions: bool
) -> _Future[tuple[_T1 | BaseException, _T2 | BaseException]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    coro_or_future3: _FutureLike[_T3],
    /,
    *,
    return_exceptions: bool,
) -> _Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    coro_or_future3: _FutureLike[_T3],
    coro_or_future4: _FutureLike[_T4],
    /,
    *,
    return_exceptions: bool,
) -> _Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException]]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    coro_or_future3: _FutureLike[_T3],
    coro_or_future4: _FutureLike[_T4],
    coro_or_future5: _FutureLike[_T5],
    /,
    *,
    return_exceptions: bool,
) -> _Future[
    tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException, _T5 | BaseException]
]: ...
@overload
def gather(
    coro_or_future1: _FutureLike[_T1],
    coro_or_future2: _FutureLike[_T2],
    coro_or_future3: _FutureLike[_T3],
    coro_or_future4: _FutureLike[_T4],
    coro_or_future5: _FutureLike[_T5],
    coro_or_future6: _FutureLike[_T6],
    /,
    *,
    return_exceptions: bool,
) -> _Future[
    tuple[
        _T1 | BaseException,
        _T2 | BaseException,
        _T3 | BaseException,
        _T4 | BaseException,
        _T5 | BaseException,
        _T6 | BaseException,
    ]
]: ...
@overload
def gather(*coros_or_futures: _FutureLike[_T], return_exceptions: bool) -> _Future[list[_T | BaseException]]: ...

class Future(_Future[_T]): ...
class Task(_Future[_T]): ...

class Queue: ...
class LifoQueue(Queue): ...
class PriorityQueue(Queue): ...
class QueueEmpty(Exception): ...
class QueueFull(Exception): ...
class QueueShutDown(Exception): ...

class Lock: ...
class Event: ...
class Semaphore: ...
class BoundedSemaphore(Semaphore): ...
class Condition: ...
class Barrier: ...

class CancelledError(Exception): ...
class TimeoutError(Exception): ...
class InvalidStateError(Exception): ...
class IncompleteReadError(EOFError): ...
class LimitOverrunError(Exception): ...
class BrokenBarrierError(RuntimeError): ...

class AbstractEventLoopPolicy: ...
class AbstractEventLoop: ...
class BaseEventLoop(AbstractEventLoop): ...
class Runner: ...
class TaskGroup: ...
class Timeout: ...

class StreamReader: ...
class StreamWriter: ...
class StreamReaderProtocol: ...

class BaseProtocol: ...
class Protocol(BaseProtocol): ...
class DatagramProtocol(BaseProtocol): ...
class SubprocessProtocol(BaseProtocol): ...
class BufferedProtocol(BaseProtocol): ...

class BaseTransport: ...
class Transport(BaseTransport): ...
class ReadTransport(BaseTransport): ...
class WriteTransport(BaseTransport): ...
class DatagramTransport(BaseTransport): ...
class SubprocessTransport(BaseTransport): ...

class Server: ...
class AbstractServer: ...
class Handle: ...
class TimerHandle(Handle): ...

ALL_COMPLETED: str
FIRST_COMPLETED: str
FIRST_EXCEPTION: str

def wait(fs: Any, *, timeout: float | None = None, return_when: Any = ...) -> _Future[Any]: ...
def wait_for(fut: _FutureLike[_T], timeout: float | None, /) -> _Future[_T]: ...
def sleep(delay: float, result: _T | None = None, /) -> _Future[_T | None]: ...
def shield(aw: _FutureLike[_T], /) -> _Future[_T]: ...
def iscoroutine(obj: object, /) -> bool: ...
def iscoroutinefunction(func: object, /) -> bool: ...
def isfuture(obj: object, /) -> bool: ...
def create_task(coro: _FutureLike[_T], /, *, name: str | None = None, context: Any = ...) -> Task[_T]: ...
def current_task(loop: AbstractEventLoop | None = None) -> Task[Any] | None: ...
def all_tasks(loop: AbstractEventLoop | None = None) -> set[Task[Any]]: ...
def ensure_future(coro_or_future: _FutureLike[_T], *, loop: AbstractEventLoop | None = None) -> Future[_T]: ...
def timeout(delay: float | None, /) -> Timeout: ...
def timeout_at(when: float | None, /) -> Timeout: ...
def run(main: _FutureLike[_T], *, debug: bool | None = None, loop_factory: Any = None) -> _T: ...
def as_completed(fs: Any, *, timeout: float | None = None) -> Any: ...
def new_event_loop() -> AbstractEventLoop: ...
def get_event_loop() -> AbstractEventLoop: ...
def set_event_loop(loop: AbstractEventLoop | None) -> None: ...
def get_event_loop_policy() -> AbstractEventLoopPolicy: ...
def set_event_loop_policy(policy: AbstractEventLoopPolicy | None) -> None: ...
def get_running_loop() -> AbstractEventLoop: ...
def to_thread(func: Any, /, *args: Any, **kwargs: Any) -> _Future[Any]: ...
def eager_task_factory(loop: AbstractEventLoop, coro: _FutureLike[_T], /, *, name: str | None = None, context: Any = ...) -> Task[_T]: ...
def create_eager_task_factory(custom_task_constructor: Any, /) -> Any: ...

futures: Any
locks: Any
queues: Any
events: Any
protocols: Any
transports: Any
streams: Any
subprocess: Any
tasks: Any
base_events: Any
base_futures: Any
base_tasks: Any
exceptions: Any
