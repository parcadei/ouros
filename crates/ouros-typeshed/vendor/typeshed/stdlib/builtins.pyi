import _sitebuiltins
import sys
import types
from _collections_abc import dict_items, dict_keys, dict_values
from collections.abc import Awaitable, Callable, Iterable, Iterator, MutableSet, Reversible, Set as AbstractSet, Sized
from types import GenericAlias, TracebackType
from typing import (
    Any,
    ClassVar,
    Final,
    Generic,
    MutableMapping,
    MutableSequence,
    Protocol,
    Sequence,
    SupportsAbs,
    SupportsBytes,
    SupportsFloat,
    SupportsIndex,
    TypeVar,
    final,
    overload,
    type_check_only,
)

import _typeshed
from _typeshed import (
    AnnotationForm,
    ConvertibleToFloat,
    ConvertibleToInt,
    ReadableBuffer,
    SupportsAdd,
    SupportsAnext,
    SupportsDivMod,
    SupportsFlush,
    SupportsKeysAndGetItem,
    SupportsLenAndGetItem,
    SupportsNext,
    SupportsRAdd,
    SupportsRDivMod,
    SupportsRichComparison,
    SupportsRichComparisonT,
    SupportsWrite,
)
from typing_extensions import (
    Concatenate,
    Literal,
    LiteralString,
    ParamSpec,
    Self,
    TypeAlias,
    TypeVarTuple,
    deprecated,
    disjoint_base,
)

if sys.version_info >= (3, 14):
    from _typeshed import AnnotateFunc
_T = TypeVar('_T')
_I = TypeVar('_I', default=int)
_T_co = TypeVar('_T_co', covariant=True)
_T_contra = TypeVar('_T_contra', contravariant=True)
_R_co = TypeVar('_R_co', covariant=True, default=Any)
_KT = TypeVar('_KT')
_VT = TypeVar('_VT')
_S = TypeVar('_S')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')
_T3 = TypeVar('_T3')
_T4 = TypeVar('_T4')
_T5 = TypeVar('_T5')
_SupportsNextT_co = TypeVar('_SupportsNextT_co', bound=SupportsNext[Any], covariant=True)
_SupportsAnextT_co = TypeVar('_SupportsAnextT_co', bound=SupportsAnext[Any], covariant=True)
_AwaitableT = TypeVar('_AwaitableT', bound=Awaitable[Any])
_AwaitableT_co = TypeVar('_AwaitableT_co', bound=Awaitable[Any], covariant=True)
_P = ParamSpec('_P')
_StartT_co = TypeVar('_StartT_co', covariant=True, default=Any)
_StopT_co = TypeVar('_StopT_co', covariant=True, default=_StartT_co)
_StepT_co = TypeVar('_StepT_co', covariant=True, default=_StartT_co | _StopT_co)

@disjoint_base
class object:
    __doc__: str | None
    __dict__: dict[str, Any]
    __module__: str
    __annotations__: dict[str, Any]

    @property
    def __class__(self) -> type[Self]: ...
    @__class__.setter
    def __class__(self, type: type[Self], /) -> None: ...
    def __init__(self) -> None: ...
    def __new__(cls) -> Self: ...
    def __setattr__(self, name: str, value: Any, /) -> None: ...
    def __delattr__(self, name: str, /) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __format__(self, format_spec: str, /) -> str: ...
    def __getattribute__(self, name: str, /) -> Any: ...
    def __sizeof__(self) -> int: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    def __reduce_ex__(self, protocol: SupportsIndex, /) -> str | tuple[Any, ...]: ...
    if sys.version_info >= (3, 11):
        def __getstate__(self) -> object: ...

    def __dir__(self) -> Iterable[str]: ...
    def __init_subclass__(cls) -> None: ...
    @classmethod
    def __subclasshook__(cls, subclass: type, /) -> bool: ...

@disjoint_base
class staticmethod(Generic[_P, _R_co]):
    @property
    def __func__(self) -> Callable[_P, _R_co]: ...
    @property
    def __isabstractmethod__(self) -> bool: ...
    def __init__(self, f: Callable[_P, _R_co], /) -> None: ...
    @overload
    def __get__(self, instance: None, owner: type, /) -> Callable[_P, _R_co]: ...
    @overload
    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...
    if sys.version_info >= (3, 10):
        __name__: str
        __qualname__: str
        @property
        def __wrapped__(self) -> Callable[_P, _R_co]: ...
        def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R_co: ...
    if sys.version_info >= (3, 14):
        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
        __annotate__: AnnotateFunc | None

@disjoint_base
class classmethod(Generic[_T, _P, _R_co]):
    @property
    def __func__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...
    @property
    def __isabstractmethod__(self) -> bool: ...
    def __init__(self, f: Callable[Concatenate[type[_T], _P], _R_co], /) -> None: ...
    @overload
    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...
    @overload
    def __get__(self, instance: None, owner: type[_T], /) -> Callable[_P, _R_co]: ...
    if sys.version_info >= (3, 10):
        __name__: str
        __qualname__: str
        @property
        def __wrapped__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...
    if sys.version_info >= (3, 14):
        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
        __annotate__: AnnotateFunc | None

@disjoint_base
class type:
    @property
    def __base__(self) -> type | None: ...
    __bases__: tuple[type, ...]

    @property
    def __basicsize__(self) -> int: ...
    __dict__: Final[types.MappingProxyType[str, Any]]

    @property
    def __dictoffset__(self) -> int: ...
    @property
    def __flags__(self) -> int: ...
    @property
    def __itemsize__(self) -> int: ...
    __module__: str

    @property
    def __mro__(self) -> tuple[type, ...]: ...
    __name__: str
    __qualname__: str

    @property
    def __text_signature__(self) -> str | None: ...
    @property
    def __weakrefoffset__(self) -> int: ...
    @overload
    def __init__(self, o: object, /) -> None: ...
    @overload
    def __init__(self, name: str, bases: tuple[type, ...], dict: dict[str, Any], /, **kwds: Any) -> None: ...
    @overload
    def __new__(cls, o: object, /) -> type: ...
    @overload
    def __new__(
        cls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwds: Any
    ) -> _typeshed.Self: ...
    def __call__(self, *args: Any, **kwds: Any) -> Any: ...
    def __subclasses__(self: _typeshed.Self) -> list[_typeshed.Self]: ...
    def mro(self) -> list[type]: ...
    def __instancecheck__(self, instance: Any, /) -> bool: ...
    def __subclasscheck__(self, subclass: type, /) -> bool: ...
    @classmethod
    def __prepare__(metacls, name: str, bases: tuple[type, ...], /, **kwds: Any) -> MutableMapping[str, object]: ...
    if sys.version_info >= (3, 10):
        def __or__(self: _typeshed.Self, value: Any, /) -> types.UnionType | _typeshed.Self: ...
        def __ror__(self: _typeshed.Self, value: Any, /) -> types.UnionType | _typeshed.Self: ...
    if sys.version_info >= (3, 12):
        __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]
    __annotations__: dict[str, AnnotationForm]
    if sys.version_info >= (3, 14):
        __annotate__: AnnotateFunc | None

@disjoint_base
class super:
    @overload
    def __init__(self, t: Any, obj: Any, /) -> None: ...
    @overload
    def __init__(self, t: Any, /) -> None: ...
    @overload
    def __init__(self) -> None: ...

_PositiveInteger: TypeAlias = Literal[
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
]
_NegativeInteger: TypeAlias = Literal[
    -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20
]
_LiteralInteger = _PositiveInteger | _NegativeInteger | Literal[0]

@disjoint_base
class int:
    @overload
    def __new__(cls, x: ConvertibleToInt = 0, /) -> Self: ...
    @overload
    def __new__(cls, x: str | bytes | bytearray, /, base: SupportsIndex) -> Self: ...
    def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...
    @property
    def real(self) -> int: ...
    @property
    def imag(self) -> Literal[0]: ...
    @property
    def numerator(self) -> int: ...
    @property
    def denominator(self) -> Literal[1]: ...
    def conjugate(self) -> int: ...
    def bit_length(self) -> int: ...
    if sys.version_info >= (3, 10):
        def bit_count(self) -> int: ...
    if sys.version_info >= (3, 11):
        def to_bytes(
            self, length: SupportsIndex = 1, byteorder: Literal['little', 'big'] = 'big', *, signed: bool = False
        ) -> bytes: ...
        @classmethod
        def from_bytes(
            cls,
            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,
            byteorder: Literal['little', 'big'] = 'big',
            *,
            signed: bool = False,
        ) -> Self: ...
    else:
        def to_bytes(
            self, length: SupportsIndex, byteorder: Literal['little', 'big'], *, signed: bool = False
        ) -> bytes: ...
        @classmethod
        def from_bytes(
            cls,
            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,
            byteorder: Literal['little', 'big'],
            *,
            signed: bool = False,
        ) -> Self: ...
    if sys.version_info >= (3, 12):
        def is_integer(self) -> Literal[True]: ...

    def __add__(self, value: int, /) -> int: ...
    def __sub__(self, value: int, /) -> int: ...
    def __mul__(self, value: int, /) -> int: ...
    def __floordiv__(self, value: int, /) -> int: ...
    def __truediv__(self, value: int, /) -> float: ...
    def __mod__(self, value: int, /) -> int: ...
    def __divmod__(self, value: int, /) -> tuple[int, int]: ...
    def __radd__(self, value: int, /) -> int: ...
    def __rsub__(self, value: int, /) -> int: ...
    def __rmul__(self, value: int, /) -> int: ...
    def __rfloordiv__(self, value: int, /) -> int: ...
    def __rtruediv__(self, value: int, /) -> float: ...
    def __rmod__(self, value: int, /) -> int: ...
    def __rdivmod__(self, value: int, /) -> tuple[int, int]: ...
    @overload
    def __pow__(self, x: Literal[0], /) -> Literal[1]: ...
    @overload
    def __pow__(self, value: Literal[0], mod: None, /) -> Literal[1]: ...
    @overload
    def __pow__(self, value: _PositiveInteger, mod: None = None, /) -> int: ...
    @overload
    def __pow__(self, value: _NegativeInteger, mod: None = None, /) -> float: ...
    @overload
    def __pow__(self, value: int, mod: None = None, /) -> Any: ...
    @overload
    def __pow__(self, value: int, mod: int, /) -> int: ...
    def __rpow__(self, value: int, mod: int | None = None, /) -> Any: ...
    def __and__(self, value: int, /) -> int: ...
    def __or__(self, value: int, /) -> int: ...
    def __xor__(self, value: int, /) -> int: ...
    def __lshift__(self, value: int, /) -> int: ...
    def __rshift__(self, value: int, /) -> int: ...
    def __rand__(self, value: int, /) -> int: ...
    def __ror__(self, value: int, /) -> int: ...
    def __rxor__(self, value: int, /) -> int: ...
    def __rlshift__(self, value: int, /) -> int: ...
    def __rrshift__(self, value: int, /) -> int: ...
    def __neg__(self) -> int: ...
    def __pos__(self) -> int: ...
    def __invert__(self) -> int: ...
    def __trunc__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def __floor__(self) -> int: ...
    if sys.version_info >= (3, 14):
        def __round__(self, ndigits: SupportsIndex | None = None, /) -> int: ...
    else:
        def __round__(self, ndigits: SupportsIndex = ..., /) -> int: ...

    def __getnewargs__(self) -> tuple[int]: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __lt__(self, value: int, /) -> bool: ...
    def __le__(self, value: int, /) -> bool: ...
    def __gt__(self, value: int, /) -> bool: ...
    def __ge__(self, value: int, /) -> bool: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __abs__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __index__(self) -> int: ...
    def __format__(self, format_spec: str, /) -> str: ...

@disjoint_base
class float:
    def __new__(cls, x: ConvertibleToFloat = 0, /) -> Self: ...
    def as_integer_ratio(self) -> tuple[int, int]: ...
    def hex(self) -> str: ...
    def is_integer(self) -> bool: ...
    @classmethod
    def fromhex(cls, string: str, /) -> Self: ...
    @property
    def real(self) -> float: ...
    @property
    def imag(self) -> float: ...
    def conjugate(self) -> float: ...
    def __add__(self, value: float, /) -> float: ...
    def __sub__(self, value: float, /) -> float: ...
    def __mul__(self, value: float, /) -> float: ...
    def __floordiv__(self, value: float, /) -> float: ...
    def __truediv__(self, value: float, /) -> float: ...
    def __mod__(self, value: float, /) -> float: ...
    def __divmod__(self, value: float, /) -> tuple[float, float]: ...
    @overload
    def __pow__(self, value: int, mod: None = None, /) -> float: ...
    @overload
    def __pow__(self, value: float, mod: None = None, /) -> Any: ...
    def __radd__(self, value: float, /) -> float: ...
    def __rsub__(self, value: float, /) -> float: ...
    def __rmul__(self, value: float, /) -> float: ...
    def __rfloordiv__(self, value: float, /) -> float: ...
    def __rtruediv__(self, value: float, /) -> float: ...
    def __rmod__(self, value: float, /) -> float: ...
    def __rdivmod__(self, value: float, /) -> tuple[float, float]: ...
    @overload
    def __rpow__(self, value: _PositiveInteger, mod: None = None, /) -> float: ...
    @overload
    def __rpow__(self, value: _NegativeInteger, mod: None = None, /) -> complex: ...
    @overload
    def __rpow__(self, value: float, mod: None = None, /) -> Any: ...
    def __getnewargs__(self) -> tuple[float]: ...
    def __trunc__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def __floor__(self) -> int: ...
    @overload
    def __round__(self, ndigits: None = None, /) -> int: ...
    @overload
    def __round__(self, ndigits: SupportsIndex, /) -> float: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __lt__(self, value: float, /) -> bool: ...
    def __le__(self, value: float, /) -> bool: ...
    def __gt__(self, value: float, /) -> bool: ...
    def __ge__(self, value: float, /) -> bool: ...
    def __neg__(self) -> float: ...
    def __pos__(self) -> float: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __abs__(self) -> float: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __format__(self, format_spec: str, /) -> str: ...
    if sys.version_info >= (3, 14):
        @classmethod
        def from_number(cls, number: float | SupportsIndex | SupportsFloat, /) -> Self: ...

@type_check_only
class _FormatMapMapping(Protocol):
    def __getitem__(self, key: str, /) -> Any: ...

@type_check_only
class _TranslateTable(Protocol):
    def __getitem__(self, key: int, /) -> str | int | None: ...

@disjoint_base
class str(Sequence[str]):
    @overload
    def __new__(cls, object: object = '') -> Self: ...
    @overload
    def __new__(cls, object: ReadableBuffer, encoding: str = 'utf-8', errors: str = 'strict') -> Self: ...
    @overload
    def capitalize(self: LiteralString) -> LiteralString: ...
    @overload
    def capitalize(self) -> str: ...
    @overload
    def casefold(self: LiteralString) -> LiteralString: ...
    @overload
    def casefold(self) -> str: ...
    @overload
    def center(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = ' ', /) -> LiteralString: ...
    @overload
    def center(self, width: SupportsIndex, fillchar: str = ' ', /) -> str: ...
    def count(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...
    def encode(self, encoding: str = 'utf-8', errors: str = 'strict') -> bytes: ...
    def endswith(
        self, suffix: str | tuple[str, ...], start: SupportsIndex | None = None, end: SupportsIndex | None = None, /
    ) -> bool: ...
    @overload
    def expandtabs(self: LiteralString, tabsize: SupportsIndex = 8) -> LiteralString: ...
    @overload
    def expandtabs(self, tabsize: SupportsIndex = 8) -> str: ...
    def find(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...
    @overload
    def format(self: LiteralString, *args: LiteralString, **kwargs: LiteralString) -> LiteralString: ...
    @overload
    def format(self, *args: object, **kwargs: object) -> str: ...
    def format_map(self, mapping: _FormatMapMapping, /) -> str: ...
    def index(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isascii(self) -> bool: ...
    def isdecimal(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def isidentifier(self) -> bool: ...
    def islower(self) -> bool: ...
    def isnumeric(self) -> bool: ...
    def isprintable(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    @overload
    def join(self: LiteralString, iterable: Iterable[LiteralString], /) -> LiteralString: ...
    @overload
    def join(self, iterable: Iterable[str], /) -> str: ...
    @overload
    def ljust(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = ' ', /) -> LiteralString: ...
    @overload
    def ljust(self, width: SupportsIndex, fillchar: str = ' ', /) -> str: ...
    @overload
    def lower(self: LiteralString) -> LiteralString: ...
    @overload
    def lower(self) -> str: ...
    @overload
    def lstrip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...
    @overload
    def lstrip(self, chars: str | None = None, /) -> str: ...
    @overload
    def partition(self: LiteralString, sep: LiteralString, /) -> tuple[LiteralString, LiteralString, LiteralString]: ...
    @overload
    def partition(self, sep: str, /) -> tuple[str, str, str]: ...
    if sys.version_info >= (3, 13):
        @overload
        def replace(
            self: LiteralString, old: LiteralString, new: LiteralString, /, count: SupportsIndex = -1
        ) -> LiteralString: ...
        @overload
        def replace(self, old: str, new: str, /, count: SupportsIndex = -1) -> str: ...
    else:
        @overload
        def replace(
            self: LiteralString, old: LiteralString, new: LiteralString, count: SupportsIndex = -1, /
        ) -> LiteralString: ...
        @overload
        def replace(self, old: str, new: str, count: SupportsIndex = -1, /) -> str: ...

    @overload
    def removeprefix(self: LiteralString, prefix: LiteralString, /) -> LiteralString: ...
    @overload
    def removeprefix(self, prefix: str, /) -> str: ...
    @overload
    def removesuffix(self: LiteralString, suffix: LiteralString, /) -> LiteralString: ...
    @overload
    def removesuffix(self, suffix: str, /) -> str: ...
    def rfind(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...
    def rindex(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...
    @overload
    def rjust(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = ' ', /) -> LiteralString: ...
    @overload
    def rjust(self, width: SupportsIndex, fillchar: str = ' ', /) -> str: ...
    @overload
    def rpartition(
        self: LiteralString, sep: LiteralString, /
    ) -> tuple[LiteralString, LiteralString, LiteralString]: ...
    @overload
    def rpartition(self, sep: str, /) -> tuple[str, str, str]: ...
    @overload
    def rsplit(
        self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1
    ) -> list[LiteralString]: ...
    @overload
    def rsplit(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...
    @overload
    def rstrip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...
    @overload
    def rstrip(self, chars: str | None = None, /) -> str: ...
    @overload
    def split(
        self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1
    ) -> list[LiteralString]: ...
    @overload
    def split(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...
    @overload
    def splitlines(self: LiteralString, keepends: bool = False) -> list[LiteralString]: ...
    @overload
    def splitlines(self, keepends: bool = False) -> list[str]: ...
    def startswith(
        self, prefix: str | tuple[str, ...], start: SupportsIndex | None = None, end: SupportsIndex | None = None, /
    ) -> bool: ...
    @overload
    def strip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...
    @overload
    def strip(self, chars: str | None = None, /) -> str: ...
    @overload
    def swapcase(self: LiteralString) -> LiteralString: ...
    @overload
    def swapcase(self) -> str: ...
    @overload
    def title(self: LiteralString) -> LiteralString: ...
    @overload
    def title(self) -> str: ...
    def translate(self, table: _TranslateTable, /) -> str: ...
    @overload
    def upper(self: LiteralString) -> LiteralString: ...
    @overload
    def upper(self) -> str: ...
    @overload
    def zfill(self: LiteralString, width: SupportsIndex, /) -> LiteralString: ...
    @overload
    def zfill(self, width: SupportsIndex, /) -> str: ...
    @staticmethod
    @overload
    def maketrans(x: dict[int, _T] | dict[str, _T] | dict[str | int, _T], /) -> dict[int, _T]: ...
    @staticmethod
    @overload
    def maketrans(x: str, y: str, /) -> dict[int, int]: ...
    @staticmethod
    @overload
    def maketrans(x: str, y: str, z: str, /) -> dict[int, int | None]: ...
    @overload
    def __add__(self: LiteralString, value: LiteralString, /) -> LiteralString: ...
    @overload
    def __add__(self, value: str, /) -> str: ...
    def __contains__(self, key: str, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ge__(self, value: str, /) -> bool: ...
    @overload
    def __getitem__(self: LiteralString, key: SupportsIndex | slice[SupportsIndex | None], /) -> LiteralString: ...
    @overload
    def __getitem__(self, key: SupportsIndex | slice[SupportsIndex | None], /) -> str: ...
    def __gt__(self, value: str, /) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __iter__(self: LiteralString) -> Iterator[LiteralString]: ...
    @overload
    def __iter__(self) -> Iterator[str]: ...
    def __le__(self, value: str, /) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, value: str, /) -> bool: ...
    @overload
    def __mod__(self: LiteralString, value: LiteralString | tuple[LiteralString, ...], /) -> LiteralString: ...
    @overload
    def __mod__(self, value: Any, /) -> str: ...
    @overload
    def __mul__(self: LiteralString, value: SupportsIndex, /) -> LiteralString: ...
    @overload
    def __mul__(self, value: SupportsIndex, /) -> str: ...
    def __ne__(self, value: object, /) -> bool: ...
    @overload
    def __rmul__(self: LiteralString, value: SupportsIndex, /) -> LiteralString: ...
    @overload
    def __rmul__(self, value: SupportsIndex, /) -> str: ...
    def __getnewargs__(self) -> tuple[str]: ...
    def __format__(self, format_spec: str, /) -> str: ...

@disjoint_base
class bytes(Sequence[int]):
    @overload
    def __new__(cls, o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer, /) -> Self: ...
    @overload
    def __new__(cls, string: str, /, encoding: str, errors: str = 'strict') -> Self: ...
    @overload
    def __new__(cls) -> Self: ...
    def capitalize(self) -> bytes: ...
    def center(self, width: SupportsIndex, fillchar: bytes = b' ', /) -> bytes: ...
    def count(
        self,
        sub: ReadableBuffer | SupportsIndex,
        start: SupportsIndex | None = None,
        end: SupportsIndex | None = None,
        /,
    ) -> int: ...
    def decode(self, encoding: str = 'utf-8', errors: str = 'strict') -> str: ...
    def endswith(
        self,
        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],
        start: SupportsIndex | None = None,
        end: SupportsIndex | None = None,
        /,
    ) -> bool: ...
    def expandtabs(self, tabsize: SupportsIndex = 8) -> bytes: ...
    def find(
        self,
        sub: ReadableBuffer | SupportsIndex,
        start: SupportsIndex | None = None,
        end: SupportsIndex | None = None,
        /,
    ) -> int: ...
    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = 1) -> str: ...
    def index(
        self,
        sub: ReadableBuffer | SupportsIndex,
        start: SupportsIndex | None = None,
        end: SupportsIndex | None = None,
        /,
    ) -> int: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isascii(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def islower(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytes: ...
    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b' ', /) -> bytes: ...
    def lower(self) -> bytes: ...
    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
    def partition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...
    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytes: ...
    def removeprefix(self, prefix: ReadableBuffer, /) -> bytes: ...
    def removesuffix(self, suffix: ReadableBuffer, /) -> bytes: ...
    def rfind(
        self,
        sub: ReadableBuffer | SupportsIndex,
        start: SupportsIndex | None = None,
        end: SupportsIndex | None = None,
        /,
    ) -> int: ...
    def rindex(
        self,
        sub: ReadableBuffer | SupportsIndex,
        start: SupportsIndex | None = None,
        end: SupportsIndex | None = None,
        /,
    ) -> int: ...
    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b' ', /) -> bytes: ...
    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...
    def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...
    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
    def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...
    def splitlines(self, keepends: bool = False) -> list[bytes]: ...
    def startswith(
        self,
        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],
        start: SupportsIndex | None = None,
        end: SupportsIndex | None = None,
        /,
    ) -> bool: ...
    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...
    def swapcase(self) -> bytes: ...
    def title(self) -> bytes: ...
    def translate(self, table: ReadableBuffer | None, /, delete: ReadableBuffer = b'') -> bytes: ...
    def upper(self) -> bytes: ...
    def zfill(self, width: SupportsIndex, /) -> bytes: ...
    if sys.version_info >= (3, 14):
        @classmethod
        def fromhex(cls, string: str | ReadableBuffer, /) -> Self: ...
    else:
        @classmethod
        def fromhex(cls, string: str, /) -> Self: ...

    @staticmethod
    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __hash__(self) -> int: ...
    @overload
    def __getitem__(self, key: SupportsIndex, /) -> int: ...
    @overload
    def __getitem__(self, key: slice[SupportsIndex | None], /) -> bytes: ...
    def __add__(self, value: ReadableBuffer, /) -> bytes: ...
    def __mul__(self, value: SupportsIndex, /) -> bytes: ...
    def __rmul__(self, value: SupportsIndex, /) -> bytes: ...
    def __mod__(self, value: Any, /) -> bytes: ...
    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __lt__(self, value: bytes, /) -> bool: ...
    def __le__(self, value: bytes, /) -> bool: ...
    def __gt__(self, value: bytes, /) -> bool: ...
    def __ge__(self, value: bytes, /) -> bool: ...
    def __getnewargs__(self) -> tuple[bytes]: ...
    if sys.version_info >= (3, 11):
        def __bytes__(self) -> bytes: ...

    def __buffer__(self, flags: int, /) -> memoryview: ...

_IntegerFormats: TypeAlias = Literal[
    'b',
    'B',
    '@b',
    '@B',
    'h',
    'H',
    '@h',
    '@H',
    'i',
    'I',
    '@i',
    '@I',
    'l',
    'L',
    '@l',
    '@L',
    'q',
    'Q',
    '@q',
    '@Q',
    'P',
    '@P',
]

@final
class bool(int):
    def __new__(cls, o: object = False, /) -> Self: ...
    @overload
    def __and__(self, value: bool, /) -> bool: ...
    @overload
    def __and__(self, value: int, /) -> int: ...
    @overload
    def __or__(self, value: bool, /) -> bool: ...
    @overload
    def __or__(self, value: int, /) -> int: ...
    @overload
    def __xor__(self, value: bool, /) -> bool: ...
    @overload
    def __xor__(self, value: int, /) -> int: ...
    @overload
    def __rand__(self, value: bool, /) -> bool: ...
    @overload
    def __rand__(self, value: int, /) -> int: ...
    @overload
    def __ror__(self, value: bool, /) -> bool: ...
    @overload
    def __ror__(self, value: int, /) -> int: ...
    @overload
    def __rxor__(self, value: bool, /) -> bool: ...
    @overload
    def __rxor__(self, value: int, /) -> int: ...
    def __getnewargs__(self) -> tuple[int]: ...
    @deprecated('Will throw an error in Python 3.16. Use `not` for logical negation of bools instead.')
    def __invert__(self) -> int: ...

@final
class slice(Generic[_StartT_co, _StopT_co, _StepT_co]):
    @property
    def start(self) -> _StartT_co: ...
    @property
    def step(self) -> _StepT_co: ...
    @property
    def stop(self) -> _StopT_co: ...
    @overload
    def __new__(cls, start: None, stop: None = None, step: None = None, /) -> slice[Any, Any, Any]: ...
    @overload
    def __new__(cls, stop: _T2, /) -> slice[Any, _T2, Any]: ...
    @overload
    def __new__(cls, start: _T1, stop: None, step: None = None, /) -> slice[_T1, Any, Any]: ...
    @overload
    def __new__(cls, start: None, stop: _T2, step: None = None, /) -> slice[Any, _T2, Any]: ...
    @overload
    def __new__(cls, start: _T1, stop: _T2, step: None = None, /) -> slice[_T1, _T2, Any]: ...
    @overload
    def __new__(cls, start: None, stop: None, step: _T3, /) -> slice[Any, Any, _T3]: ...
    @overload
    def __new__(cls, start: _T1, stop: None, step: _T3, /) -> slice[_T1, Any, _T3]: ...
    @overload
    def __new__(cls, start: None, stop: _T2, step: _T3, /) -> slice[Any, _T2, _T3]: ...
    @overload
    def __new__(cls, start: _T1, stop: _T2, step: _T3, /) -> slice[_T1, _T2, _T3]: ...
    def __eq__(self, value: object, /) -> bool: ...
    if sys.version_info >= (3, 12):
        def __hash__(self) -> int: ...
    else:
        __hash__: ClassVar[None]

    def indices(self, len: SupportsIndex, /) -> tuple[int, int, int]: ...

@disjoint_base
class tuple(Sequence[_T_co]):
    def __new__(cls, iterable: Iterable[_T_co] = (), /) -> Self: ...
    def __len__(self) -> int: ...
    def __contains__(self, key: object, /) -> bool: ...
    @overload
    def __getitem__(self, key: SupportsIndex, /) -> _T_co: ...
    @overload
    def __getitem__(self, key: slice[SupportsIndex | None], /) -> tuple[_T_co, ...]: ...
    def __iter__(self) -> Iterator[_T_co]: ...
    def __lt__(self, value: tuple[_T_co, ...], /) -> bool: ...
    def __le__(self, value: tuple[_T_co, ...], /) -> bool: ...
    def __gt__(self, value: tuple[_T_co, ...], /) -> bool: ...
    def __ge__(self, value: tuple[_T_co, ...], /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __add__(self, value: tuple[_T_co, ...], /) -> tuple[_T_co, ...]: ...
    @overload
    def __add__(self, value: tuple[_T, ...], /) -> tuple[_T_co | _T, ...]: ...
    def __mul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...
    def __rmul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...
    def count(self, value: Any, /) -> int: ...
    def index(self, value: Any, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...

@disjoint_base
class list(MutableSequence[_T]):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[_T], /) -> None: ...
    def copy(self) -> list[_T]: ...
    def append(self, object: _T, /) -> None: ...
    def extend(self, iterable: Iterable[_T], /) -> None: ...
    def pop(self, index: SupportsIndex = -1, /) -> _T: ...
    def index(self, value: _T, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...
    def count(self, value: _T, /) -> int: ...
    def insert(self, index: SupportsIndex, object: _T, /) -> None: ...
    def remove(self, value: _T, /) -> None: ...
    @overload
    def sort(self: list[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...
    @overload
    def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T]: ...
    __hash__: ClassVar[None]

    @overload
    def __getitem__(self, i: SupportsIndex, /) -> _T: ...
    @overload
    def __getitem__(self, s: slice[SupportsIndex | None], /) -> list[_T]: ...
    @overload
    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None: ...
    @overload
    def __setitem__(self, key: slice[SupportsIndex | None], value: Iterable[_T], /) -> None: ...
    def __delitem__(self, key: SupportsIndex | slice[SupportsIndex | None], /) -> None: ...
    @overload
    def __add__(self, value: list[_T], /) -> list[_T]: ...
    @overload
    def __add__(self, value: list[_S], /) -> list[_S | _T]: ...
    def __iadd__(self, value: Iterable[_T], /) -> Self: ...
    def __mul__(self, value: SupportsIndex, /) -> list[_T]: ...
    def __rmul__(self, value: SupportsIndex, /) -> list[_T]: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __contains__(self, key: object, /) -> bool: ...
    def __reversed__(self) -> Iterator[_T]: ...
    def __gt__(self, value: list[_T], /) -> bool: ...
    def __ge__(self, value: list[_T], /) -> bool: ...
    def __lt__(self, value: list[_T], /) -> bool: ...
    def __le__(self, value: list[_T], /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...

@disjoint_base
class dict(MutableMapping[_KT, _VT]):
    @overload
    def __init__(self, /) -> None: ...
    @overload
    def __init__(self: dict[str, _VT], /, **kwargs: _VT) -> None: ...
    @overload
    def __init__(self, map: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...
    @overload
    def __init__(self: dict[str, _VT], map: SupportsKeysAndGetItem[str, _VT], /, **kwargs: _VT) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...
    @overload
    def __init__(self: dict[str, _VT], iterable: Iterable[tuple[str, _VT]], /, **kwargs: _VT) -> None: ...
    @overload
    def __init__(self: dict[str, str], iterable: Iterable[list[str]], /) -> None: ...
    @overload
    def __init__(self: dict[bytes, bytes], iterable: Iterable[list[bytes]], /) -> None: ...
    def __new__(cls, /, *args: Any, **kwargs: Any) -> Self: ...
    def copy(self) -> dict[_KT, _VT]: ...
    def keys(self) -> dict_keys[_KT, _VT]: ...
    def values(self) -> dict_values[_KT, _VT]: ...
    def items(self) -> dict_items[_KT, _VT]: ...
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T], value: None = None, /) -> dict[_T, Any | None]: ...
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T], value: _S, /) -> dict[_T, _S]: ...
    @overload
    def get(self, key: _KT, default: None = None, /) -> _VT | None: ...
    @overload
    def get(self, key: _KT, default: _VT, /) -> _VT: ...
    @overload
    def get(self, key: _KT, default: _T, /) -> _VT | _T: ...
    @overload
    def pop(self, key: _KT, /) -> _VT: ...
    @overload
    def pop(self, key: _KT, default: _VT, /) -> _VT: ...
    @overload
    def pop(self, key: _KT, default: _T, /) -> _VT | _T: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: _KT, /) -> _VT: ...
    def __setitem__(self, key: _KT, value: _VT, /) -> None: ...
    def __delitem__(self, key: _KT, /) -> None: ...
    def __iter__(self) -> Iterator[_KT]: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __reversed__(self) -> Iterator[_KT]: ...
    __hash__: ClassVar[None]

    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...
    @overload
    def __or__(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...
    @overload
    def __or__(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...
    @overload
    def __ror__(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...
    @overload
    def __ror__(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...
    @overload
    def __ior__(self, value: SupportsKeysAndGetItem[_KT, _VT], /) -> Self: ...
    @overload
    def __ior__(self, value: Iterable[tuple[_KT, _VT]], /) -> Self: ...

@disjoint_base
class set(MutableSet[_T]):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[_T], /) -> None: ...
    def add(self, element: _T, /) -> None: ...
    def copy(self) -> set[_T]: ...
    def difference(self, *s: Iterable[Any]) -> set[_T]: ...
    def difference_update(self, *s: Iterable[Any]) -> None: ...
    def discard(self, element: _T, /) -> None: ...
    def intersection(self, *s: Iterable[Any]) -> set[_T]: ...
    def intersection_update(self, *s: Iterable[Any]) -> None: ...
    def isdisjoint(self, s: Iterable[Any], /) -> bool: ...
    def issubset(self, s: Iterable[Any], /) -> bool: ...
    def issuperset(self, s: Iterable[Any], /) -> bool: ...
    def remove(self, element: _T, /) -> None: ...
    def symmetric_difference(self, s: Iterable[_T], /) -> set[_T]: ...
    def symmetric_difference_update(self, s: Iterable[_T], /) -> None: ...
    def union(self, *s: Iterable[_S]) -> set[_T | _S]: ...
    def update(self, *s: Iterable[_T]) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, o: object, /) -> bool: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __and__(self, value: AbstractSet[object], /) -> set[_T]: ...
    def __iand__(self, value: AbstractSet[object], /) -> Self: ...
    def __or__(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...
    def __ior__(self, value: AbstractSet[_T], /) -> Self: ...
    def __sub__(self, value: AbstractSet[object], /) -> set[_T]: ...
    def __isub__(self, value: AbstractSet[object], /) -> Self: ...
    def __xor__(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...
    def __ixor__(self, value: AbstractSet[_T], /) -> Self: ...
    def __le__(self, value: AbstractSet[object], /) -> bool: ...
    def __lt__(self, value: AbstractSet[object], /) -> bool: ...
    def __ge__(self, value: AbstractSet[object], /) -> bool: ...
    def __gt__(self, value: AbstractSet[object], /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    __hash__: ClassVar[None]

    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...

@disjoint_base
class frozenset(AbstractSet[_T_co]):
    @overload
    def __new__(cls) -> Self: ...
    @overload
    def __new__(cls, iterable: Iterable[_T_co], /) -> Self: ...
    def copy(self) -> frozenset[_T_co]: ...
    def difference(self, *s: Iterable[object]) -> frozenset[_T_co]: ...
    def intersection(self, *s: Iterable[object]) -> frozenset[_T_co]: ...
    def isdisjoint(self, s: Iterable[_T_co], /) -> bool: ...
    def issubset(self, s: Iterable[object], /) -> bool: ...
    def issuperset(self, s: Iterable[object], /) -> bool: ...
    def symmetric_difference(self, s: Iterable[_T_co], /) -> frozenset[_T_co]: ...
    def union(self, *s: Iterable[_S]) -> frozenset[_T_co | _S]: ...
    def __len__(self) -> int: ...
    def __contains__(self, o: object, /) -> bool: ...
    def __iter__(self) -> Iterator[_T_co]: ...
    def __and__(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...
    def __or__(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...
    def __sub__(self, value: AbstractSet[object], /) -> frozenset[_T_co]: ...
    def __xor__(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...
    def __le__(self, value: AbstractSet[object], /) -> bool: ...
    def __lt__(self, value: AbstractSet[object], /) -> bool: ...
    def __ge__(self, value: AbstractSet[object], /) -> bool: ...
    def __gt__(self, value: AbstractSet[object], /) -> bool: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...

@disjoint_base
class enumerate(Generic[_T]):
    def __new__(cls, iterable: Iterable[_T], start: int = 0) -> Self: ...
    def __iter__(self) -> Self: ...
    def __next__(self) -> tuple[int, _T]: ...
    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...

@final
class range(Sequence[int]):
    @property
    def start(self) -> int: ...
    @property
    def stop(self) -> int: ...
    @property
    def step(self) -> int: ...
    @overload
    def __new__(cls, stop: SupportsIndex, /) -> Self: ...
    @overload
    def __new__(cls, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = 1, /) -> Self: ...
    def count(self, value: int, /) -> int: ...
    def index(self, value: int, /) -> int: ...
    def __len__(self) -> int: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __contains__(self, key: object, /) -> bool: ...
    def __iter__(self) -> Iterator[int]: ...
    @overload
    def __getitem__(self, key: SupportsIndex, /) -> int: ...
    @overload
    def __getitem__(self, key: slice[SupportsIndex | None], /) -> range: ...
    def __reversed__(self) -> Iterator[int]: ...

@disjoint_base
class property:
    fget: Callable[[Any], Any] | None
    fset: Callable[[Any, Any], None] | None
    fdel: Callable[[Any], None] | None
    __isabstractmethod__: bool
    if sys.version_info >= (3, 13):
        __name__: str

    def __init__(
        self,
        fget: Callable[[Any], Any] | None = None,
        fset: Callable[[Any, Any], None] | None = None,
        fdel: Callable[[Any], None] | None = None,
        doc: str | None = None,
    ) -> None: ...
    def getter(self, fget: Callable[[Any], Any], /) -> property: ...
    def setter(self, fset: Callable[[Any, Any], None], /) -> property: ...
    def deleter(self, fdel: Callable[[Any], None], /) -> property: ...
    @overload
    def __get__(self, instance: None, owner: type, /) -> Self: ...
    @overload
    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...
    def __set__(self, instance: Any, value: Any, /) -> None: ...
    def __delete__(self, instance: Any, /) -> None: ...

def abs(x: SupportsAbs[_T], /) -> _T: ...
def all(iterable: Iterable[object], /) -> bool: ...
def any(iterable: Iterable[object], /) -> bool: ...
def bin(number: int | SupportsIndex, /) -> str: ...
def chr(i: int | SupportsIndex, /) -> str: ...

if sys.version_info >= (3, 10):
    @type_check_only
    class _SupportsSynchronousAnext(Protocol[_AwaitableT_co]):
        def __anext__(self) -> _AwaitableT_co: ...

copyright: _sitebuiltins._Printer
credits: _sitebuiltins._Printer

@overload
def divmod(x: SupportsDivMod[_T_contra, _T_co], y: _T_contra, /) -> _T_co: ...
@overload
def divmod(x: _T_contra, y: SupportsRDivMod[_T_contra, _T_co], /) -> _T_co: ...

exit: _sitebuiltins.Quitter

def hash(obj: object, /) -> int: ...

help: _sitebuiltins._Helper

def hex(number: int | SupportsIndex, /) -> str: ...
def id(obj: object, /) -> int: ...
@type_check_only
class _GetItemIterable(Protocol[_T_co]):
    def __getitem__(self, i: int, /) -> _T_co: ...

if sys.version_info >= (3, 10):
    _ClassInfo: TypeAlias = type | types.UnionType | tuple[_ClassInfo, ...]
else:
    _ClassInfo: TypeAlias = type | tuple[_ClassInfo, ...]

def isinstance(obj: object, class_or_tuple: _ClassInfo, /) -> bool: ...
def issubclass(cls: _ClassInfo, class_or_tuple: _ClassInfo, /) -> bool: ...
def hasattr(obj: object, name: str, /) -> bool: ...
def len(obj: Sized, /) -> int: ...

license: _sitebuiltins._Printer

@overload
def max(
    arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None
) -> SupportsRichComparisonT: ...
@overload
def max(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
@overload
def max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...
@overload
def max(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
@overload
def max(
    iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T
) -> SupportsRichComparisonT | _T: ...
@overload
def max(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
@overload
def min(
    arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None
) -> SupportsRichComparisonT: ...
@overload
def min(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
@overload
def min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...
@overload
def min(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...
@overload
def min(
    iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T
) -> SupportsRichComparisonT | _T: ...
@overload
def min(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...
def oct(number: int | SupportsIndex, /) -> str: ...

_Opener: TypeAlias = Callable[[str, int], int]

def ord(c: str | bytes | bytearray, /) -> int: ...
@type_check_only
class _SupportsWriteAndFlush(SupportsWrite[_T_contra], SupportsFlush, Protocol[_T_contra]): ...

@overload
def print(
    *values: object,
    sep: str | None = ' ',
    end: str | None = '\n',
    file: SupportsWrite[str] | None = None,
    flush: Literal[False] = False,
) -> None: ...
@overload
def print(
    *values: object,
    sep: str | None = ' ',
    end: str | None = '\n',
    file: _SupportsWriteAndFlush[str] | None = None,
    flush: bool,
) -> None: ...

_E_contra = TypeVar('_E_contra', contravariant=True)
_M_contra = TypeVar('_M_contra', contravariant=True)

@type_check_only
class _SupportsPow2(Protocol[_E_contra, _T_co]):
    def __pow__(self, other: _E_contra, /) -> _T_co: ...

@type_check_only
class _SupportsPow3NoneOnly(Protocol[_E_contra, _T_co]):
    def __pow__(self, other: _E_contra, modulo: None = None, /) -> _T_co: ...

@type_check_only
class _SupportsPow3(Protocol[_E_contra, _M_contra, _T_co]):
    def __pow__(self, other: _E_contra, modulo: _M_contra, /) -> _T_co: ...

_SupportsSomeKindOfPow = _SupportsPow2[Any, Any] | _SupportsPow3NoneOnly[Any, Any] | _SupportsPow3[Any, Any, Any]

@overload
def pow(base: int, exp: int, mod: int) -> int: ...
@overload
def pow(base: int, exp: Literal[0], mod: None = None) -> Literal[1]: ...
@overload
def pow(base: int, exp: _PositiveInteger, mod: None = None) -> int: ...
@overload
def pow(base: int, exp: _NegativeInteger, mod: None = None) -> float: ...
@overload
def pow(base: int, exp: int, mod: None = None) -> Any: ...
@overload
def pow(base: _PositiveInteger, exp: float, mod: None = None) -> float: ...
@overload
def pow(base: _NegativeInteger, exp: float, mod: None = None) -> complex: ...
@overload
def pow(base: float, exp: int, mod: None = None) -> float: ...
@overload
def pow(base: float, exp: complex | _SupportsSomeKindOfPow, mod: None = None) -> Any: ...
@overload
def pow(base: complex, exp: complex | _SupportsSomeKindOfPow, mod: None = None) -> complex: ...
@overload
def pow(base: _SupportsPow2[_E_contra, _T_co], exp: _E_contra, mod: None = None) -> _T_co: ...
@overload
def pow(base: _SupportsPow3NoneOnly[_E_contra, _T_co], exp: _E_contra, mod: None = None) -> _T_co: ...
@overload
def pow(base: _SupportsPow3[_E_contra, _M_contra, _T_co], exp: _E_contra, mod: _M_contra) -> _T_co: ...
@overload
def pow(base: _SupportsSomeKindOfPow, exp: float, mod: None = None) -> Any: ...
@overload
def pow(base: _SupportsSomeKindOfPow, exp: complex, mod: None = None) -> complex: ...

quit: _sitebuiltins.Quitter

@disjoint_base
class reversed(Generic[_T]):
    @overload
    def __new__(cls, sequence: Reversible[_T], /) -> Iterator[_T]: ...
    @overload
    def __new__(cls, sequence: SupportsLenAndGetItem[_T], /) -> Iterator[_T]: ...
    def __iter__(self) -> Self: ...
    def __next__(self) -> _T: ...
    def __length_hint__(self) -> int: ...

def repr(obj: object, /) -> str: ...
@type_check_only
class _SupportsRound1(Protocol[_T_co]):
    def __round__(self) -> _T_co: ...

@type_check_only
class _SupportsRound2(Protocol[_T_co]):
    def __round__(self, ndigits: int, /) -> _T_co: ...

@overload
def round(number: _SupportsRound1[_T], ndigits: None = None) -> _T: ...
@overload
def round(number: _SupportsRound2[_T], ndigits: SupportsIndex) -> _T: ...
class map(Iterator[_R_co], Generic[_R_co]):
    @overload
    def __new__(cls, func: Callable[[_T1], _R_co], iter1: Iterable[_T1], /) -> map[_R_co]: ...
    @overload
    def __new__(
        cls, func: Callable[[_T1, _T2], _R_co], iter1: Iterable[_T1], iter2: Iterable[_T2], /
    ) -> map[_R_co]: ...
    @overload
    def __new__(
        cls,
        func: Callable[[_T1, _T2, _T3], _R_co],
        iter1: Iterable[_T1],
        iter2: Iterable[_T2],
        iter3: Iterable[_T3],
        /,
    ) -> map[_R_co]: ...
    @overload
    def __new__(
        cls,
        func: Callable[[_T1, _T2, _T3, _T4], _R_co],
        iter1: Iterable[_T1],
        iter2: Iterable[_T2],
        iter3: Iterable[_T3],
        iter4: Iterable[_T4],
        /,
    ) -> map[_R_co]: ...
    @overload
    def __new__(
        cls,
        func: Callable[[_T1, _T2, _T3, _T4, _T5], _R_co],
        iter1: Iterable[_T1],
        iter2: Iterable[_T2],
        iter3: Iterable[_T3],
        iter4: Iterable[_T4],
        iter5: Iterable[_T5],
        /,
    ) -> map[_R_co]: ...
    @overload
    def __new__(
        cls,
        func: Callable[..., _R_co],
        iter1: Iterable[Any],
        iter2: Iterable[Any],
        iter3: Iterable[Any],
        iter4: Iterable[Any],
        iter5: Iterable[Any],
        iter6: Iterable[Any],
        /,
        *iterables: Iterable[Any],
    ) -> map[_R_co]: ...
    def __iter__(self) -> Self: ...
    def __next__(self) -> _R_co: ...

class filter(Iterator[_T], Generic[_T]):
    @overload
    def __new__(cls, function: None, iterable: Iterable[_T | None], /) -> filter[_T]: ...
    @overload
    def __new__(cls, function: Callable[[_T], Any], iterable: Iterable[_T], /) -> filter[_T]: ...
    def __iter__(self) -> Self: ...
    def __next__(self) -> _T: ...

@overload
def sorted(
    iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, reverse: bool = False
) -> list[SupportsRichComparisonT]: ...
@overload
def sorted(
    iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False
) -> list[_T]: ...

_AddableT1 = TypeVar('_AddableT1', bound=SupportsAdd[Any, Any])
_AddableT2 = TypeVar('_AddableT2', bound=SupportsAdd[Any, Any])

@type_check_only
class _SupportsSumWithNoDefaultGiven(SupportsAdd[Any, Any], SupportsRAdd[int, Any], Protocol): ...

_SupportsSumNoDefaultT = TypeVar('_SupportsSumNoDefaultT', bound=_SupportsSumWithNoDefaultGiven)

@overload
def sum(iterable: Iterable[bool | _LiteralInteger], /, start: int = 0) -> int: ...
@overload
def sum(iterable: Iterable[_SupportsSumNoDefaultT], /) -> _SupportsSumNoDefaultT | Literal[0]: ...
@overload
def sum(iterable: Iterable[_AddableT1], /, start: _AddableT2) -> _AddableT1 | _AddableT2: ...
@disjoint_base
class zip(Generic[_T_co]):
    if sys.version_info >= (3, 10):
        @overload
        def __new__(cls, *, strict: bool = False) -> zip[Any]: ...
        @overload
        def __new__(cls, iter1: Iterable[_T1], /, *, strict: bool = False) -> zip[tuple[_T1]]: ...
        @overload
        def __new__(
            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /, *, strict: bool = False
        ) -> zip[tuple[_T1, _T2]]: ...
        @overload
        def __new__(
            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /, *, strict: bool = False
        ) -> zip[tuple[_T1, _T2, _T3]]: ...
        @overload
        def __new__(
            cls,
            iter1: Iterable[_T1],
            iter2: Iterable[_T2],
            iter3: Iterable[_T3],
            iter4: Iterable[_T4],
            /,
            *,
            strict: bool = False,
        ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...
        @overload
        def __new__(
            cls,
            iter1: Iterable[_T1],
            iter2: Iterable[_T2],
            iter3: Iterable[_T3],
            iter4: Iterable[_T4],
            iter5: Iterable[_T5],
            /,
            *,
            strict: bool = False,
        ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
        @overload
        def __new__(
            cls,
            iter1: Iterable[Any],
            iter2: Iterable[Any],
            iter3: Iterable[Any],
            iter4: Iterable[Any],
            iter5: Iterable[Any],
            iter6: Iterable[Any],
            /,
            *iterables: Iterable[Any],
            strict: bool = False,
        ) -> zip[tuple[Any, ...]]: ...
    else:
        @overload
        def __new__(cls) -> zip[Any]: ...
        @overload
        def __new__(cls, iter1: Iterable[_T1], /) -> zip[tuple[_T1]]: ...
        @overload
        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> zip[tuple[_T1, _T2]]: ...
        @overload
        def __new__(
            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /
        ) -> zip[tuple[_T1, _T2, _T3]]: ...
        @overload
        def __new__(
            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /
        ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...
        @overload
        def __new__(
            cls,
            iter1: Iterable[_T1],
            iter2: Iterable[_T2],
            iter3: Iterable[_T3],
            iter4: Iterable[_T4],
            iter5: Iterable[_T5],
            /,
        ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...
        @overload
        def __new__(
            cls,
            iter1: Iterable[Any],
            iter2: Iterable[Any],
            iter3: Iterable[Any],
            iter4: Iterable[Any],
            iter5: Iterable[Any],
            iter6: Iterable[Any],
            /,
            *iterables: Iterable[Any],
        ) -> zip[tuple[Any, ...]]: ...

    def __iter__(self) -> Self: ...
    def __next__(self) -> _T_co: ...

if sys.version_info >= (3, 10):
    from types import EllipsisType, NotImplementedType

    ellipsis = EllipsisType
    Ellipsis: EllipsisType
    NotImplemented: NotImplementedType
else:
    Ellipsis: ellipsis

    @final
    @type_check_only
    class _NotImplementedType(Any): ...

    NotImplemented: _NotImplementedType

@disjoint_base
class BaseException:
    args: tuple[Any, ...]
    __cause__: BaseException | None
    __context__: BaseException | None
    __suppress_context__: bool
    __traceback__: TracebackType | None

    def __init__(self, *args: object) -> None: ...
    def __new__(cls, *args: Any, **kwds: Any) -> Self: ...
    def __setstate__(self, state: dict[str, Any] | None, /) -> None: ...
    def with_traceback(self, tb: TracebackType | None, /) -> Self: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    if sys.version_info >= (3, 11):
        __notes__: list[str]

        def add_note(self, note: str, /) -> None: ...

class KeyboardInterrupt(BaseException): ...

@disjoint_base
class SystemExit(BaseException):
    code: sys._ExitCode

class Exception(BaseException): ...

@disjoint_base
class StopIteration(Exception):
    value: Any

@disjoint_base
class OSError(Exception):
    errno: int | None
    strerror: str | None
    filename: Any
    filename2: Any
    if sys.platform == 'win32':
        winerror: int

EnvironmentError = OSError
IOError = OSError
if sys.platform == 'win32':
    WindowsError = OSError

class ArithmeticError(Exception): ...
class AssertionError(Exception): ...

if sys.version_info >= (3, 10):
    @disjoint_base
    class AttributeError(Exception):
        def __init__(self, *args: object, name: str | None = None, obj: object = None) -> None: ...
        name: str | None
        obj: object

else:
    class AttributeError(Exception): ...

class LookupError(Exception): ...
class MemoryError(Exception): ...

if sys.version_info >= (3, 10):
    @disjoint_base
    class NameError(Exception):
        def __init__(self, *args: object, name: str | None = None) -> None: ...
        name: str | None

else:
    class NameError(Exception): ...

class RuntimeError(Exception): ...

@disjoint_base
class SyntaxError(Exception):
    msg: str
    filename: str | None
    lineno: int | None
    offset: int | None
    text: str | None
    print_file_and_line: None
    if sys.version_info >= (3, 10):
        end_lineno: int | None
        end_offset: int | None

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, msg: object, /) -> None: ...
    @overload
    def __init__(self, msg: str, info: tuple[str | None, int | None, int | None, str | None], /) -> None: ...
    if sys.version_info >= (3, 10):
        @overload
        def __init__(
            self, msg: str, info: tuple[str | None, int | None, int | None, str | None, int | None, int | None], /
        ) -> None: ...

class TypeError(Exception): ...
class ValueError(Exception): ...
class OverflowError(ArithmeticError): ...
class ZeroDivisionError(ArithmeticError): ...
class IndexError(LookupError): ...
class KeyError(LookupError): ...
class FileExistsError(OSError): ...
class FileNotFoundError(OSError): ...
class IsADirectoryError(OSError): ...
class NotADirectoryError(OSError): ...
class PermissionError(OSError): ...
class TimeoutError(OSError): ...
class NotImplementedError(RuntimeError): ...
class RecursionError(RuntimeError): ...

if sys.version_info >= (3, 11):
    _BaseExceptionT_co = TypeVar('_BaseExceptionT_co', bound=BaseException, covariant=True, default=BaseException)
    _BaseExceptionT = TypeVar('_BaseExceptionT', bound=BaseException)
    _ExceptionT_co = TypeVar('_ExceptionT_co', bound=Exception, covariant=True, default=Exception)
    _ExceptionT = TypeVar('_ExceptionT', bound=Exception)
